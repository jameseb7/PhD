Perna et al. present a system for compiling a programming language into hardware. The input language is extended with specification constructs to form a reasoning language and compilation is performed by reducing the program to a normal form that represents the operation of the hardware being produced. The reasoning language contains things such as timed constructs and parallel composition with merging of shared variables, in addition to the more usual elements of a reasoning language for compiler construction such as assignment, sequential composition, conditionals, recursion and refinement. The normal form reduction is done in two stages, with a normal form for each stage: the first normal form consists of a loop that contains guarded commands separated by the parallel composition operator so that the appropriate commands are run depending on the state of the machine; the second normal form expresses the program in terms of single variable assignments without guards and introduces wires that allow for the separation of expression calculation and variable assignment, permitting parallel composition with variable merge to be expressed in a form that can be more easily handled in hardware. The reduction of each program construct to each of the normal forms is performed by applying compilation rules, which are proved from laws that are themselves derived a model expressed in the semantics of Unifying Theories of Programming (UTP).

This approach is quite neat and covers features that have not been properly address by most other work on verified hardware generation such as parallelism with shared variables. The approach also has the advantage that the normal form produced can be easily transferred to an actual hardware implementation on an FPGA as it consists of simple assignments activated in parallel, with values that can be computed using combinatorial logic circuits. The fact that the laws are based on a UTP semantics rather than being simply postulated as axioms lends the system an integrity that is important if it is to be used in safety critical applications.

There are still some areas that this work does not handle, particularly pointers and optimisation. Pointers are challenging to implement but, as is noted in this paper, some work has already been done on implementing pointers in the UTP so that could be used to add a concept of pointers to the source language. Optimisation is a secondary concern after the correctness of the compiler but it would be necessary for the system presented in this work to be applied to FPGAs, which typically have limited resources. It would, however, require additional work to look into a correct optimiser since that would involve adding extra rules to handle removal of redundant hardware and addition of systems such as pipelines, which could be quite complicated to deal with in an algebraic framework.

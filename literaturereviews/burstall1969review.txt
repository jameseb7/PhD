Burstall and Landin present a mathematical treatment of computer programs, viewing program functions as homomorphisms between algebras. This algebraic method of looking at programs is then applied to prove the correctness of a compiler for a simple expression language similar to the one presented by McCarthy and Painter. The compilation process is split up into several stages, targetting different machines at each stage, starting by compiling for a stack machine, then proceeding to a machine that emulates a stack using memory and a stack pointer, then a machine where the operand address is provided in the program along with the operation, and finally targetting a more conventional machine with an accumulator. The proof of correctness for the stack machine proceeds by defining algebras for the source language, target language, expression values and stack transformations, using algebraic techniques to construct embeddings and homomorphisms between them. The diagram formed by the homomorphisms is then shown to commute. The stack-pointer machine, which is the second target machine, is then defined by a function that maps between states and a homomorphism is defined to perform the compilation, with correctness being shown by commutativity of another diagram involving a mapping from the second machine's states to the first machine's states. A compilation function for the second-to-last machine is derived by splitting the previous machine into two submachines, one of which is the second-to-last target machine, with a compilation function arising out of the split. The last machine is then reached by replacing the instructions of the second-to-last machine with equivalent sequences of accumulator machine instructions.

This approach works well and provides a more mathematically based concept of correctness than that provided by McCarthy and Painter, particularly as it removes the need for defining partial equality. The fact that some of the compilation functions occur naturally when constructing the target machine from a source machine is quite neat and the splitting of the compilation into several target machines allows for techniques like that to be shown.

However, Burstall and Landin still make use of the commuting diagram approach, requiring an encode function along the bottom of the commuting diagram mapping the value of the expression to the stack machine state transitions (though mapping to the operation of pushing the value onto the stack provides a simple solution). Another criticism is the mathematical complexity of the approach: it is noted in the introduction of the paper that it would have to be formalised in a higher order logic, though such logics had not been mechanised at the time the paper was written, whereas McCarthy and Painter wished to make their proof easy to mechanise.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{crproof}[\nameref{pc-expansion-rule}]
  \begin{argue}
    \begin{array}{l}
      HandleInstruction_{bc}
    \end{array} \\
    = & Law [\nameref{alt-intro-law}] \\
    \begin{array}{l}
      \circif {} \circelse_{i \in ProgramAddress} pc = i \circthen HandleInstruction_{bc} \circfi
    \end{array} \\
    = & separate alternation branches \\
    \begin{array}{l}
      \circif \\
      {} \circelse_{i \in \dom bc} pc = i \circthen HandleInstruction_{bc} \\
      {} \circelse_{i \in ProgramAddress \setminus \dom bc} pc = i \circthen HandleInstruction_{bc} \\
      \circfi
    \end{array} \\
    = & Law [\nameref{alt-assump-intro-law}] \\
    \begin{array}{l}
      \circif \\
      {} \circelse_{i \in \dom bc} pc = i \circthen \{ pc = i\} \circseq HandleInstruction_{bc} \\
      {} \circelse_{i \in ProgramAddress \setminus \dom bc} pc = i \circthen \{ pc = i\} \circseq HandleInstruction_{bc} \\
      \circfi
    \end{array} \\
    = & Law [\nameref{copy-rule-law}] and definition of $HandleInstruction$ \\
    \begin{array}{l}
      \circif \\
      {} \circelse_{i \in \dom bc} pc = i \circthen \{ pc = i\} \circseq HandleInstruction_{bc} \\
      {} \circelse_{i \in ProgramAddress \setminus \dom bc} pc = i \circthen \{ pc = i\} \circseq (HandleAconst\_null \extchoice HandleDup \extchoice HandleAload \extchoice HandleAstore \\
      \t1 {} \extchoice HandleIadd \extchoice HandleIconst \extchoice HandleIneg \extchoice HandleGoto \extchoice HandleIf\_icmple \extchoice HandleAreturn \\
      \t1 {}\extchoice HandleReturn \extchoice HandleGetfield \extchoice HandlePutfield \extchoice HandleGetstatic \extchoice HandlePutstatic \\
	\t1 {} \extchoice HandleInvokevirtual \extchoice HandleInvokespecial \extchoice HandleInvokestatic \\
        \t1 {} \extchoice \lcircguard pc \notin \dom bc \rcircguard \circguard \Chaos) \\
      \circfi
    \end{array} \\
    = & Law [\nameref{assump-extchoice-distr-law}] \\
    \begin{array}{l}
      \circif \\
      {} \circelse_{i \in \dom bc} pc = i \circthen \{ pc = i\} \circseq HandleInstruction_{bc} \\
      {} \circelse_{i \in ProgramAddress \setminus \dom bc} pc = i \circthen (\{ pc = i\} \circseq HandleAconst\_null) \extchoice (\{ pc = i\} \circseq HandleDup) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq HandleAload) \extchoice (\{ pc = i\} \circseq HandleAstore) \extchoice (\{ pc = i\} \circseq HandleIadd) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq HandleIconst) \extchoice (\{ pc = i\} \circseq HandleIneg) \extchoice (\{ pc = i\} \circseq HandleGoto) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq HandleIf\_icmple) \extchoice (\{ pc = i\} \circseq HandleAreturn) \extchoice (\{ pc = i\} \circseq HandleReturn) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq HandleGetfield) \extchoice (\{ pc = i\} \circseq HandlePutfield) \extchoice (\{ pc = i\} \circseq HandleGetstatic) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq HandlePutstatic) \extchoice (\{ pc = i\} \circseq HandleInvokevirtual) \extchoice (\{ pc = i\} \circseq HandleInvokespecial) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq HandleInvokestatic) \\
        \t1 {} \extchoice (\{ pc = i\} \circseq (\lcircguard pc \notin \dom bc \rcircguard \circguard \Chaos)) \\
      \circfi
    \end{array} \\
    = & Law~[\nameref{copy-rule-law}], definitions of $Handle*$ actions, and Law~[\nameref{assump-guard-elim2-law}] \\
    \begin{array}{l}
      \circif \\
      {} \circelse_{i \in \dom bc} pc = i \circthen \{ pc = i\} \circseq HandleInstruction_{bc} \\
      {} \circelse_{i \in ProgramAddress \setminus \dom bc} pc = i \circthen (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc = i\} \circseq (\lcircguard pc \notin \dom bc \rcircguard \circguard \Chaos)) \\
      \circfi
    \end{array} \\
    = & Law~[\nameref{assump-guard-elim1-law}] \\
    \begin{array}{l}
      \circif \\
      {} \circelse_{i \in \dom bc} pc = i \circthen \{ pc = i\} \circseq HandleInstruction_{bc} \\
      {} \circelse_{i \in ProgramAddress \setminus \dom bc} pc = i \circthen (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc = i\} \circseq \Chaos) \\
      \circfi
    \end{array} \\
    \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
    \begin{array}{l}
      \circif \\
      {} \circelse_{i \in \dom bc} pc = i \circthen HandleInstruction_{bc} \\
      {} \circelse_{i \in ProgramAddress \setminus \dom bc} pc = i \circthen \Stop \extchoice \Stop \extchoice \Stop \extchoice \Stop \extchoice \Stop \extchoice \Stop \extchoice \Stop \extchoice \Stop \\
      \t1 {} \extchoice \Stop \extchoice \Stop \extchoice \Stop \extchoice \Stop \extchoice \Stop \extchoice \Stop \extchoice \Stop \extchoice \Stop \extchoice \Stop \extchoice \Stop \extchoice \Chaos \\
      \circfi
    \end{array} \\
    = & Law~[\nameref{extchoice-unit-law}] \\
    \begin{array}{l}
      \circif \\
      {} \circelse_{i \in \dom bc} pc = i \circthen HandleInstruction_{bc} \\
      {} \circelse_{i \in ProgramAddress \setminus \dom bc} pc = i \circthen \Chaos \\
      \circfi
    \end{array} \\
    = & Law~[\nameref{alt-branch-elim-law}] \\
    \begin{array}{l}
      \circif {} \circelse_{i \in \dom bc} pc = i \circthen HandleInstruction_{bc} \circfi
    \end{array}
  \end{argue}
\end{crproof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{crproof}[\nameref{HandleInstruction-refinement-rule}]
  \begin{argue}
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen HandleInstruction_{bc} \\
      {} \cdots {} \\
      \circfi
    \end{array} \\
    = & Law~[\nameref{alt-assump-intro-law}] \\
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen \{ pc = i \} \circseq HandleInstruction_{bc} \\
      {} \cdots {} \\
      \circfi
    \end{array}
  \end{argue}
  From the assumption of the rule ($i \in \dom bc$), we know that
  $bc~i$ is a well-defined expression and its value is in $Bytecode$. 
  There are thus 19 cases for the value of $bc~i$. 
  We consider each separately:
  \begin{enumerate}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 1: aconst_null
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \item Suppose $bc~i = aconst\_null$ then,
    \begin{argue}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}\\
      = & Law~[\nameref{assump-assump-intro-law}], and rule and case assumptions \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq
        HandleInstruction_{bc}
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and definition of $HandleInstruction$ \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \\
        \t1 (HandleAconst\_null
        \extchoice HandleDup
        \extchoice HandleAload
        \extchoice HandleAstore \\
        \t1 {} \extchoice HandleIadd
        \extchoice HandleIconst
        \extchoice HandleIneg
        \extchoice HandleGoto
        \extchoice HandleIf\_icmple
        \extchoice HandleAreturn \\
        \t1 {}\extchoice HandleReturn
        \extchoice HandleNew
        \extchoice HandleGetfield
        \extchoice HandlePutfield
        \extchoice HandleGetstatic \\
	\t1 {} \extchoice HandlePutstatic
        \extchoice HandleInvokevirtual
        \extchoice HandleInvokespecial
        \extchoice HandleInvokestatic \\
        \t1 {} \extchoice \lcircguard pc \notin \dom bc \rcircguard \circguard \Chaos) \\
      \end{array}\\
      = & Law~[\nameref{assump-extchoice-distr-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        ((\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleAconst\_null) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleDup) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleAload) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleAstore) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleIadd) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleIconst) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleIneg) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleGoto) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleIf\_icmple) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleAreturn) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleReturn) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleNew) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleGetfield) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandlePutfield) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleGetstatic) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandlePutstatic) \\
	\t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleInvokevirtual) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleInvokespecial) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleInvokestatic) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \lcircguard pc \notin \dom bc \rcircguard \circguard \Chaos))
      \end{array} \\
      = & Law~[\nameref{copy-rule-law}], the definitions of the $Handle{*}$ actions, and Law~[\nameref{assump-guard-elim2-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        ((\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleAconst\_null) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
	\t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop)
      \end{array} \\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        ((\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleAconst\_null) \\
        \t1 {} \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop \\
        \t1 {} \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop)
      \end{array} \\
      = & Law~[\nameref{extchoice-comm-law}] and Law~[\nameref{extchoice-unit-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq
        HandleAconst\_null
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and definition of $HandleAconst\_null$ \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \\
        \t1 (\lcircguard pc \in \dom bc \land bc~pc = aconst\_null \rcircguard \circguard
        \lschexpract InterpreterAconst\_null \rschexpract)
      \end{array}\\
      = & Law~[\nameref{assump-guard-elim1-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq
        \lschexpract InterpreterAconst\_null \rschexpract
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and defintion of $InterpreterAconst\_null$ \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \\
        \t1 \lschexpract \exists \Delta StackFrame @
        StackFrameACONST\_NULL \land PromoteStackFrameOp \rschexpract
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq \lschexpract \exists \Delta StackFrame @ StackFrameACONST\_NULL \land PromoteStackFrameOp \rschexpract
      \end{array}\\
      = & Lemma~\ref{Handle-schema-refinement-lemma} \\
      \begin{array}{l}
        \lschexpract \exists \Delta StackFrame @ StackFrameACONST\_NULL \land PromoteStackFrameOpEPC \rschexpract \circseq pc := i + 1
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and defintion of $InterpreterAconst\_nullEPC$ \\
      \begin{array}{l}
        \lschexpract InterpreterAconst\_nullEPC \rschexpract \circseq pc := i + 1
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and defintion of $HandleAconst\_nullEPC$ \\
      \begin{array}{l}
        HandleAconst\_nullEPC \circseq pc := i + 1
      \end{array}\\
      = & Definition of $handleAction$ and case assumption $bc~i = aconst\_null$ \\
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}\\
    \end{argue}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 2: dup
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \item Suppose $bc~i = dup$ then, by similar reasoning to the
    previous case,
    \begin{circus}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}
      \circrefines_A
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}
    \end{circus}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 3: aload
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item Suppose $bc~i = aload~lvi$ for some $lvi \in \nat$ then,
    \begin{argue}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}\\
      \circrefines_A & Similarly to the proofs of the previous cases \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aload~lvi\} \circseq \\        
	\t1 (\circvar variableIndex : \nat \circspot variableIndex := (aload\inv)~(bc~pc) \circseq \lschexpract InterpreterAload \rschexpract)
      \end{array}\\
      = & Law~{\nameref{var-seq-extl-law}} \\
      \begin{array}{l}
        \{ pc = i \} \circseq (\circvar variableIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = aload~lvi\} \circseq        
        variableIndex := (aload\inv)~(bc~pc) \circseq
        \lschexpract InterpreterAload \rschexpract)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] and $(pc \in \dom bc \land bc~pc = aload~lvi) \implies (aload\inv)~(bc~pc) = lvi$ \\
      \begin{array}{l}
        \{ pc = i \} \circseq (\circvar variableIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = aload~lvi\} \circseq        
        variableIndex := (aload\inv)~(bc~pc) \circseq \\
        \t2 \{variableIndex = lvi\} \circseq
        \lschexpract InterpreterAload \rschexpract)
      \end{array}\\
      = & Law~{\nameref{var-seq-extl-law}} \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aload~lvi\} \circseq \\
        \t1 (\circvar variableIndex : \nat \circspot        
        variableIndex := (aload\inv)~(bc~pc) \circseq \\
        \t2 \{variableIndex = lvi\} \circseq
        \lschexpract InterpreterAload \rschexpract)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-seq-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aload~lvi\} \circseq \\
        \t1 (\circvar variableIndex : \nat \circspot        
        variableIndex := (aload\inv)~(bc~pc) \circseq \\
        \t2 \{variableIndex = lvi\} \circseq
        \lschexpract InterpreterAload[lvi/variableIndex?] \rschexpract)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aload~lvi\} \circseq \\
        \t1 (\circvar variableIndex : \nat \circspot        
        variableIndex := (aload\inv)~(bc~pc) \circseq \\
        \t2 \lschexpract InterpreterAload[lvi/variableIndex?] \rschexpract)
      \end{array}\\
      = & Law~[\nameref{var-assign-intro-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aload~lvi\} \circseq
        \lschexpract InterpreterAload[lvi/variableIndex?] \rschexpract
      \end{array}\\
      = & Law~[\nameref{var-assign-intro-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aload~lvi\} \circseq \\
        \t1 (\circvar variableIndex : \nat \circspot        
        variableIndex := lvi \circseq
        \lschexpract InterpreterAload[lvi/variableIndex?] \rschexpract)
      \end{array}\\
      = & Law~[\nameref{assign-seq-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aload~lvi\} \circseq \\
        \t1 (\circvar variableIndex : \nat \circspot        
        variableIndex := lvi \circseq \lschexpract InterpreterAload \rschexpract)
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and defintion of $InterpreterAload$ \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aload~lvi\} \circseq \\
        \t1 (\circvar variableIndex : \nat \circspot        
        variableIndex := lvi \circseq \\
        \t2 \lschexpract \exists \Delta StackFrame @
        StackFrameALOAD \land PromoteStackFrameOp \rschexpract)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar variableIndex : \nat \circspot        
        variableIndex := lvi \circseq \\
        \t2 \lschexpract \exists \Delta StackFrame @
        StackFrameALOAD \land PromoteStackFrameOp \rschexpract)
      \end{array}\\
      = & Lemma~\ref{Handle-schema-refinement-lemma} \\
      \begin{array}{l}
        (\circvar variableIndex : \nat \circspot        
        variableIndex := lvi \circseq \\
        \t2 \lschexpract \exists \Delta StackFrame @
        StackFrameALOAD \land PromoteStackFrameOpEPC \rschexpract \circseq
        pc := i + 1)
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and defintion of $InterpreterAloadEPC$ \\
      \begin{array}{l}
        (\circvar variableIndex : \nat \circspot        
        variableIndex := lvi \circseq
        \lschexpract InterpreterAloadEPC \rschexpract \circseq
        pc := i + 1)
      \end{array}\\
      = & Law~[\nameref{var-seq-extr-law}] \\
      \begin{array}{l}
        (\circvar variableIndex : \nat \circspot        
        variableIndex := lvi \circseq
        \lschexpract InterpreterAloadEPC \rschexpract) \circseq
        pc := i + 1
      \end{array}\\
      = & Law~[\nameref{val-def-law}] \\
      \begin{array}{l}
        (\circval variableIndex : \nat \circspot
        \lschexpract InterpreterAloadEPC \rschexpract)(lvi) \circseq
        pc := i + 1
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and defintion of $HandleAloadEPC$ \\
      \begin{array}{l}
        HandleAloadEPC(lvi) \circseq
        pc := i + 1
      \end{array}\\
      = & Definition of $handleAction$ and case assumption $bc~i = aload~lvi$ \\
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}\\
    \end{argue}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 4: astore
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \item Suppose $bc~i = astore~lvi$ for some $lvi \in \nat$ then, by
    similar reasoning to the previous case,
    \begin{circus}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}
      \circrefines_A
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}
    \end{circus}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 5: iadd
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item Suppose $bc~i = iadd$ then, by similar reasoning to case 1,
    \begin{circus}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}
      \circrefines_A
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}
    \end{circus}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 6: iconst
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \item Suppose $bc~i = iconst~n$ for some $n \in \nat$ then, by
    similar reasoning to case 3,
    \begin{circus}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}\\
      
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}\\
    \end{circus}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 7: ineg
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item Suppose $bc~i = ineg$ then, by similar reasoning to case 1
    \begin{circus}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}\\
      \circrefines_A
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}\\
    \end{circus}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 8: goto
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item Suppose $bc~i = goto~ofst$ for some $ofst \in ProgramAddress$ then,
    \begin{argue}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}\\
      \circrefines_A & Similarly to case 3 \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = goto~ofst\} \circseq
        \lschexpract InterpreterGoto[ofst/branchOffset?] \rschexpract
      \end{array} \\
      = &  Schema calculus \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = goto~ofst\} \circseq
        \lschexpract [\Delta InterpreterState | \\
	\t1 pc' = pc + ofst \land \\
	\t1 frameStack' = frameStack \land \\
	\t1 currentClass' = currentClass \land \\
	\t1 frameStackID' = frameStackID] \rschexpract
      \end{array} \\
      = & Law~[\nameref{assign-schema-conv-law}] and general assumption of bytecode passing JVM verification \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = goto~ofst\} \circseq
        \{inv(InterpreterState)\} \circseq
        pc := pc + ofst
      \end{array} \\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}]  \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        pc := pc + ofst
      \end{array} \\
      \circrefines_A & Law~[\nameref{assump-assign-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        pc := i + ofst
      \end{array} \\
      = & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}]  \\
      \begin{array}{l}
        pc := i + ofst
      \end{array} \\
      = & Definition of $handleAction$ and case assumption $bc~i = goto~ofst$ \\
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}\\
    \end{argue}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 9: if_icmple
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \item Suppose $bc~i = if\_icmple~ofst$ for some $ofst \in ProgramAddress$ then,
    \begin{argue}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}\\
      \circrefines_A & Similarly to previous case \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = if\_icmple~ofst\} \circseq
        \lschexpract InterpreterIf\_Icmple[ofst/branchOffset?] \rschexpract
      \end{array} \\
      = & Law~[\nameref{copy-rule-law}] and definition of $InterpreterIf\_icmple$  \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = if\_icmple~ofst\} \circseq
        \lschexpract [\Delta InterpreterState | \\
	\t1 (\exists value1!, value2! : Word @  \exists \Delta StackFrame | StackFramePop2 @ \\
	\t2 \theta StackFrame = last~frameStack \land \\
	\t2 frameStack' = (front~frameStack) \cat \langle \theta StackFrame~' \rangle \land \\
	\t2 pc' = pc + \IF (value1! \leq value2!) \THEN ofst \ELSE 1) \land \\
	\t1 currentClass' = currentClass \land \\
	\t1 frameStackID' = frameStackID] \rschexpract
      \end{array} \\
      = & Law~[\nameref{schema-var-intro-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = if\_icmple~ofst\} \circseq \\
        \t1 \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract [\Delta InterpreterState; value1, value2 : Word; value1', value2' : Word | \\
        \t2 \exists value1!, value2! : Word @  \exists \Delta StackFrame | StackFramePop2 @ \\
	\t3 \theta StackFrame = last~frameStack \land \\
	\t3 frameStack' = (front~frameStack) \cat \langle \theta StackFrame~' \rangle \land \\
	\t3 pc' = pc + \IF (value1! \leq value2!) \THEN ofst \ELSE 1) \land \\
	\t2 currentClass' = currentClass \land \\
	\t2 frameStackID' = frameStackID] \rschexpract
      \end{array} \\
      \circrefines_A & Law~[\nameref{schema-refinement-law}] and existential quantifier introduction \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = if\_icmple~ofst\} \circseq \\
        \t1 \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract [\Delta InterpreterState; value1, value2 : Word; value1', value2' : Word | \\
        \t2 \exists \Delta StackFrame | StackFramePop2[value1'/value1!, value2'/value2!] @ \\
	\t3 \theta StackFrame = last~frameStack \land \\
	\t3 frameStack' = (front~frameStack) \cat \langle \theta StackFrame~' \rangle \land \\
	\t3 pc' = pc + \IF (value1' \leq value2') \THEN ofst \ELSE 1) \land \\
	\t2 currentClass' = currentClass \land \\
	\t2 frameStackID' = frameStackID] \rschexpract
      \end{array} \\
      = & Schema calculus \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = if\_icmple~ofst\} \circseq \\
        \t1 \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract \exists value1mid, value2mid : Word @ [\Delta InterpreterState; value1, value2 : Word; value1', value2' : Word | \\
        \t2 \exists \Delta StackFrame | StackFramePop2[value1'/value1!, value2'/value2!] @ \\
	\t3 \theta StackFrame = last~frameStack \land \\
	\t3 frameStack' = (front~frameStack) \cat \langle \theta StackFrame~' \rangle \land \\
	\t3 pc' = pc \land \\
	\t2 currentClass' = currentClass \land \\
	\t2 frameStackID' = frameStackID][value1mid/value1', value2mid/value2'] \land \\
        \t1 [\Delta InterpreterState; value1, value2 : Word; value1', value2' : Word | \\
        \t2 pc' = pc + \IF (value1 \leq value2) \THEN ofst \ELSE 1) \land \\
        \t2 value1' = value1 \land value2' = value2 \land \\
        \t2 frameStack' = frameStack \land \\
        \t2 currentClass' = currentClass \land \\
	\t2 frameStackID' = frameStackID][value1mid/value1, value2mid/value2] \rschexpract
      \end{array} \\
      = & Definition of schema composition \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = if\_icmple~ofst\} \circseq \\
        \t1 \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract [\Delta InterpreterState; value1, value2 : Word; value1', value2' : Word | \\
        \t2 \exists \Delta StackFrame | StackFramePop2[value1'/value1!, value2'/value2!] @ \\
	\t3 \theta StackFrame = last~frameStack \land \\
	\t3 frameStack' = (front~frameStack) \cat \langle \theta StackFrame~' \rangle \land \\
	\t3 pc' = pc \land \\
	\t2 currentClass' = currentClass \land \\
	\t2 frameStackID' = frameStackID] \comp \\
        \t1 [\Delta InterpreterState; value1, value2 : Word; value1', value2' : Word | \\
        \t2 pc' = pc + \IF (value1 \leq value2) \THEN ofst \ELSE 1) \land \\
        \t2 value1' = value1 \land value2' = value2 \land \\
        \t2 frameStack' = frameStack \land \\
        \t2 currentClass' = currentClass \land \\
	\t2 frameStackID' = frameStackID] \rschexpract
      \end{array} \\
      = & Law~[\nameref{schema-comp-seq-conv-law}]\\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = if\_icmple~ofst\} \circseq \\
        \t1 \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract [\Delta InterpreterState; value1, value2 : Word; value1', value2' : Word | \\
        \t2 \exists \Delta StackFrame | StackFramePop2[value1'/value1!, value2'/value2!] @ \\
	\t3 \theta StackFrame = last~frameStack \land \\
	\t3 frameStack' = (front~frameStack) \cat \langle \theta StackFrame~' \rangle \land \\
	\t3 pc' = pc \land \\
	\t2 currentClass' = currentClass \land \\
	\t2 frameStackID' = frameStackID] \rschexpract \circseq \\
        \t1 \lschexpract [\Delta InterpreterState; value1, value2 : Word; value1', value2' : Word | \\
        \t2 pc' = pc + \IF (value1 \leq value2) \THEN ofst \ELSE 1) \land \\
        \t2 value1' = value1 \land value2' = value2 \land \\
        \t2 frameStack' = frameStack \land \\
        \t2 currentClass' = currentClass \land \\
	\t2 frameStackID' = frameStackID] \rschexpract
      \end{array} \\
      = & Law~[\nameref{assign-schema-conv-law}]\\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = if\_icmple~ofst\} \circseq \\
        \t1 \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract [\Delta InterpreterState; value1, value2 : Word; value1', value2' : Word | \\
        \t2 \exists \Delta StackFrame | StackFramePop2[value1'/value1!, value2'/value2!] @ \\
	\t3 \theta StackFrame = last~frameStack \land \\
	\t3 frameStack' = (front~frameStack) \cat \langle \theta StackFrame~' \rangle \land \\
	\t3 pc' = pc \land \\
	\t2 currentClass' = currentClass \land \\
	\t2 frameStackID' = frameStackID] \rschexpract \circseq \\
        \t1 pc := pc + \IF (value1 \leq value2) \THEN ofst \ELSE 1
      \end{array} \\
      = & Schema calculus \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = if\_icmple~ofst\} \circseq \\
        \t1 \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract \exists \Delta StackFrame @ StackFramePop2 \land \\
        \t2 [\Delta InterpreterState; \Delta StackFrame | \\
	\t2 \theta StackFrame = last~frameStack \land \\
	\t2 frameStack' = (front~frameStack) \cat \langle \theta StackFrame~' \rangle \land \\
	\t2 pc' = pc \land \\
	\t2 currentClass' = currentClass \land \\
	\t2 frameStackID' = frameStackID] \rschexpract \circseq \\
        \t1 pc := pc + \IF (value1 \leq value2) \THEN ofst \ELSE 1
      \end{array}\\
      = & Definition of $PromoteStackFrameOpEPC$ \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = if\_icmple~ofst\} \circseq \\
        \t1 \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract \exists \Delta StackFrame @ StackFramePop2 \land PromoteStackFrameOpEPC \rschexpract \circseq \\
        \t1 pc := pc + \IF (value1 \leq value2) \THEN branchOffset? \ELSE 1
      \end{array}\\
      = & Definition of $InterpreterPop2EPC$ \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = if\_icmple~ofst\} \circseq \\
        \t1 \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract InterpreterPop2EPC \rschexpract \circseq \\
        \t1 pc := pc + \IF (value1 \leq value2) \THEN ofst \ELSE 1 
      \end{array}\\
      = & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}]  \\
      \begin{array}{l}
        \{ pc = i \} \circseq \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract InterpreterPop2EPC \rschexpract \circseq \\
        \t1 pc := pc + \IF (value1! \leq value2!) \THEN ofst \ELSE 1 
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        \circvar value1, value2 : Word \circspot \{ pc = i \} \circseq \\
        \t1 \lschexpract InterpreterPop2EPC \rschexpract \circseq \\
        \t1 pc := pc + \IF (value1 \leq value2) \THEN ofst \ELSE 1 
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-schema-dist-law}] \\
      \begin{array}{l}
        \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract InterpreterPop2EPC \rschexpract \circseq \{ pc = i \} \circseq \\
        \t1 pc := pc + \IF (value1 \leq value2) \THEN ofst \ELSE 1 
      \end{array}\\
      = & Law~[\nameref{assump-assign-subst-law}] \\
      \begin{array}{l}
        \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract InterpreterPop2EPC \rschexpract \circseq \{ pc = i \} \circseq \\
        \t1 pc := i + \IF (value1 \leq value2) \THEN ofst \ELSE 1 
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}]  \\
      \begin{array}{l}
        \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract InterpreterPop2EPC \rschexpract \circseq \\
        \t1 pc := i + \IF (value1 \leq value2) \THEN ofst \ELSE 1 
      \end{array}\\
      = & Definition of $handleAction$ and case assumption $bc~i = if\_icmple~ofst$ \\
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}\\
    \end{argue}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 10: areturn
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \item Suppose $bc~i = areturn$ then,
    \begin{argue}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}\\
      \circrefines_A & Similar to previous cases \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = areturn\} \circseq
        \lschexpract InterpreterAreturn \rschexpract
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        \lschexpract InterpreterAreturn \rschexpract
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and definition of $HandleAreturnEPC$ \\
      \begin{array}{l}
        HandleAreturnEPC
      \end{array}\\
      = & Definition of $handleAction$ and case assumption $bc~i = areturn$ \\
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}\\
    \end{argue}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 11: return
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
  \item Suppose $bc~i = return$ then, by similar reasoning to the
    previous case,
    \begin{circus}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}
      \circrefines_A
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}
    \end{circus}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 12: new
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item Suppose $bc~i = new~cpi$ then,
    \begin{argue}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}\\
      \circrefines_A & Similar to previous cases \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = new~cpi\} \circseq \\
        \t1 (\circif (new\inv)~(bc~pc) \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~currentClass~((new\inv)~(bc~pc))) \\
        \t2 {} \then newObjectRet?oid \then \lschexpract InterpreterPush[oid/value?] \rschexpract \\
        \t1 {} \circelse (new\inv)~(bc~pc) \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-assign-intro-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = new~cpi\} \circseq \\
        \t1 (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif (new\inv)~(bc~pc) \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~currentClass~((new\inv)~(bc~pc))) \\
        \t2 {} \then newObjectRet?oid \then \lschexpract InterpreterPush[oid/value?] \rschexpract \\
        \t1 {} \circelse (new\inv)~(bc~pc) \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = new~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \circif (new\inv)~(bc~pc) \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~currentClass~((new\inv)~(bc~pc))) \\
        \t2 {} \then newObjectRet?oid \then \lschexpract InterpreterPush[oid/value?] \rschexpract \\
        \t1 {} \circelse (new\inv)~(bc~pc) \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = new~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = new~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif (new\inv)~(bc~pc) \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~currentClass~((new\inv)~(bc~pc))) \\
        \t2 {} \then newObjectRet?oid \then \lschexpract InterpreterPush[oid/value?] \rschexpract \\
        \t1 {} \circelse (new\inv)~(bc~pc) \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-alt-guard-replace-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = new~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = new~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~currentClass~((new\inv)~(bc~pc))) \\
        \t2 {} \then newObjectRet?oid \then \lschexpract InterpreterPush[oid/value?] \rschexpract \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-alt-dist-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = new~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = new~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = new~cpi \land cpIndex = cpi \} \circseq \\
        \t2 newObject!thread!(classOf~currentClass~((new\inv)~(bc~pc))) \\
        \t2 {} \then newObjectRet?oid \then \lschexpract InterpreterPush[oid/value?] \rschexpract \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = new~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-seq-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = new~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = new~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = new~cpi \land cpIndex = cpi \} \circseq \\
        \t2 newObject!thread!(classOf~cpIndex) \then newObjectRet?oid \then \lschexpract InterpreterPush[oid/value?] \rschexpract \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = new~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~cpIndex) \then newObjectRet?oid \then \lschexpract InterpreterPush[oid/value?] \rschexpract \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~cpIndex) \then newObjectRet?oid \then \lschexpract InterpreterPush[oid/value?] \rschexpract \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~cpIndex) \then newObjectRet?oid \then \lschexpract InterpreterPush[oid/value?] \rschexpract \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-alt-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 newObject!thread!(classOf~cpIndex) \then newObjectRet?oid \then \lschexpract InterpreterPush[oid/value?] \rschexpract \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-output-prefix-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 newObject!thread!(classOf~cpIndex) \then {} \\
        \t2 (\{ pc = i \} \circseq newObjectRet?oid \then \lschexpract InterpreterPush[oid/value?] \rschexpract) \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-input-prefix-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 newObject!thread!(classOf~cpIndex) \then {} \\
        \t2 (\{ pc = i \} \circseq newObjectRet?oid \then (\{ pc = i \} \circseq \lschexpract InterpreterPush[oid/value?] \rschexpract)) \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and definition of $InterpreterPush$ \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 newObject!thread!(classOf~cpIndex) \then {} \\
        \t2 (\{ pc = i \} \circseq newObjectRet?oid \then {} \\
        \t2 (\{ pc = i \} \circseq \lschexpract \exists \Delta StackFrame @ StackFramePush[oid/value?] \land PromoteStackFrameOp \rschexpract)) \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Lemma~\ref{Handle-schema-refinement-lemma} \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 newObject!thread!(classOf~cpIndex) \then {} \\
        \t2 (\{ pc = i \} \circseq newObjectRet?oid \then {} \\
        \t2 (\lschexpract \exists \Delta StackFrame @ StackFramePush[oid/value?] \land PromoteStackFrameOpEPC \rschexpract) \circseq pc := i + 1) \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~cpIndex) \then newObjectRet?oid \then {} \\
        \t2 \lschexpract \exists \Delta StackFrame @ StackFramePush[oid/value?] \land PromoteStackFrameOpEPC \rschexpract \circseq pc := i + 1 \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{seq-zerol-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~cpIndex) \then newObjectRet?oid \then {} \\
        \t2 \lschexpract \exists \Delta StackFrame @ StackFramePush[oid/value?] \land PromoteStackFrameOpEPC \rschexpract \circseq pc := i + 1 \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \circseq pc := i + 1 \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{alt-seq-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~cpIndex) \then newObjectRet?oid \then {} \\
        \t2 \lschexpract \exists \Delta StackFrame @ StackFramePush[oid/value?] \land PromoteStackFrameOpEPC \rschexpract \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi \circseq pc := i + 1)
      \end{array}\\
      = & Law~[\nameref{var-seq-extr-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~cpIndex) \then newObjectRet?oid \then {} \\
        \t2 \lschexpract \exists \Delta StackFrame @ StackFramePush[oid/value?] \land PromoteStackFrameOpEPC \rschexpract \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi) \circseq pc := i + 1
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and definition of $InterpreterPushEPC$ \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~cpIndex) \then newObjectRet?oid \then {} \\
        \t2 \lschexpract InterpreterPushEPC[oid/value?] \rschexpract) \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi) \circseq pc := i + 1
      \end{array}\\
      = & Law~[\nameref{val-def-law}] \\
      \begin{array}{l}
        (\circval cpIndex : \nat \circspot \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~cpIndex) \then \circseq newObjectRet?oid \then {} \\
        \t2 \lschexpract InterpreterPushEPC[oid/value?] \rschexpract \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)(cpi) \circseq pc := i + 1
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and definition of $HandleNewEPC$ \\
      \begin{array}{l}
        HandleNewEPC(cpi) \circseq pc := i + 1
      \end{array}\\
      = & Definition of $handleAction$ and case assumption $bc~i = new~cpi$ \\
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}\\
    \end{argue}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 13: getfield
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item Suppose $bc~i = getfield~cpi$ then,
    \begin{argue}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}\\
      \circrefines_A & Similar to previous cases \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = getfield~cpi\} \circseq \\
        \t1 (\circif (getfield\inv)~(bc~pc) \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 getField!oid!(fieldOf~currentClass~((getfield\inv)~(bc~pc))) \\
        \t2 {} \then getFieldRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse (getfield\inv)~(bc~pc) \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Similar to previous case \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = getfield~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = getfield~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = getfield~cpi \land cpIndex = cpi \} \circseq \\
        \t2 \circvar oid : ObjectID \circspot \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 getField!oid!(fieldOf~currentClass~((getfield\inv)~(bc~pc))) \\
        \t2 {} \then getFieldRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = getfield~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = getfield~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = getfield~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \\
        \t2 \{ pc \in \dom bc \land bc~pc = getfield~cpi \land cpIndex = cpi \} \circseq \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 getField!oid!(fieldOf~currentClass~((getfield\inv)~(bc~pc))) \\
        \t2 {} \then getFieldRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = getfield~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-seq-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = getfield~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = getfield~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \\
        \t2 \{ pc \in \dom bc \land bc~pc = getfield~cpi \land cpIndex = cpi \} \circseq \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 getField!oid!(fieldOf~currentClass~cpIndex) \\
        \t2 {} \then getFieldRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = getfield~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 getField!oid!(fieldOf~currentClass~cpIndex) \\
        \t2 {} \then getFieldRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 getField!oid!(fieldOf~currentClass~cpIndex) \\
        \t2 {} \then getFieldRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 getField!oid!(fieldOf~currentClass~cpIndex) \\
        \t2 {} \then getFieldRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-alt-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 \circvar oid : ObjectID \circspot \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 getField!oid!(fieldOf~currentClass~cpIndex) \\
        \t2 {} \then getFieldRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \{ pc = i \} \circseq \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 getField!oid!(fieldOf~currentClass~cpIndex) \\
        \t2 {} \then getFieldRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-schema-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq
        \{ pc = i \} \circseq \\
        \t2 getField!oid!(fieldOf~currentClass~cpIndex) \\
        \t2 {} \then getFieldRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-output-prefix-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq
        \{ pc = i \} \circseq \\
        \t2 getField!oid!(fieldOf~currentClass~cpIndex) \\
        \t2 {} \then ( \{ pc = i \} \circseq getFieldRet?value \then
        \lschexpract InterpreterPush \rschexpract) \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-input-prefix-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq
        \{ pc = i \} \circseq \\
        \t2 getField!oid!(fieldOf~currentClass~cpIndex) \\
        \t2 {} \then ( \{ pc = i \} \circseq getFieldRet?value \then
        (\{ pc = i \} \circseq \lschexpract InterpreterPush \rschexpract)) \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Definition of $InterpreterPush$ \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq
        \{ pc = i \} \circseq \\
        \t2 getField!oid!(fieldOf~currentClass~cpIndex) \\
        \t2 {} \then ( \{ pc = i \} \circseq getFieldRet?value \then {} \\
        \t2 (\{ pc = i \} \circseq
        \lschexpract \exists \Delta StackFrame @
        StackFramePush \land PromoteStackFrameOp \rschexpract)) \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Lemma~\ref{Handle-schema-refinement-lemma} \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq
        \{ pc = i \} \circseq \\
        \t2 getField!oid!(fieldOf~currentClass~cpIndex) \\
        \t2 {} \then ( \{ pc = i \} \circseq getFieldRet?value \then {} \\
        \t2 (\lschexpract \exists \Delta StackFrame @
        StackFramePush \land PromoteStackFrameOpEPC \rschexpract) \circseq
        pc := i + 1) \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 getField!oid!(fieldOf~currentClass~cpIndex) \then getFieldRet?value \then {} \\
        \t2 \lschexpract \exists \Delta StackFrame @ StackFramePush \land PromoteStackFrameOpEPC \rschexpract \circseq pc := i + 1 \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Similar to previous case \\
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}\\
    \end{argue}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 14: putfield
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item Suppose $bc~i = putfield~cpi$ then,
    \begin{argue}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}\\
      \circrefines_A & Similar to previous case \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = putfield~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~((getfield\inv)~(bc~pc)) \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \lschexpract InterpreterPop2[value!/value1!,oid!/value2!] \rschexpract \circseq \\
        \t2 putField!oid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = putfield~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar fid : FieldID \circspot \\
        \t2 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \\
        \t2 fid := fieldOf~currentClass~((getfield\inv)~(bc~pc)) \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot
        \lschexpract InterpreterPop2[value!/value1!,oid!/value2!] \rschexpract \circseq \\
        \t2 putField!oid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = putfield~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar fid : FieldID \circspot \\
        \t2 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \\
        \t2 fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot
        \lschexpract InterpreterPop2[value!/value1!,oid!/value2!] \rschexpract \circseq \\
        \t2 putField!oid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \circseq cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar fid : FieldID \circspot
        fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot
        \lschexpract InterpreterPop2[value!/value1!,oid!/value2!] \rschexpract \circseq \\
        \t2 putField!oid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar fid : FieldID \circspot
        fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot
        \lschexpract InterpreterPop2[value!/value1!,oid!/value2!] \rschexpract \circseq \\
        \t2 putField!oid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar fid : FieldID \circspot
        fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot
        \lschexpract InterpreterPop2[value!/value1!,oid!/value2!] \rschexpract \circseq \\
        \t2 putField!oid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-alt-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \lschexpract InterpreterPop2[value!/value1!,oid!/value2!] \rschexpract \circseq \\
        \t2 putField!oid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar fid : FieldID \circspot \\
        \t2 \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \lschexpract InterpreterPop2[value!/value1!,oid!/value2!] \rschexpract \circseq \\
        \t2 putField!oid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar fid : FieldID \circspot \\
        \t2 \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq \{ pc = i \} \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \lschexpract InterpreterPop2[value!/value1!,oid!/value2!] \rschexpract \circseq \\
        \t2 putField!oid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar fid : FieldID \circspot \\
        \t2 \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq  \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \{ pc = i \} \circseq
        \lschexpract InterpreterPop2[value!/value1!,oid!/value2!] \rschexpract \circseq \\
        \t2 putField!oid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Definition of $InterpreterPop2$ \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar fid : FieldID \circspot \\
        \t2 \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq  \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \{ pc = i \} \circseq \\
        \t2 \lschexpract \exists \Delta StackFrame @ StackFramePop2[value!/value1!,oid!/value2!] \land PromoteStackFrameOp \rschexpract \circseq \\
        \t2 putField!oid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Lemma~\ref{Handle-schema-refinement-lemma} \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar fid : FieldID \circspot \\
        \t2 \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq  \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract \exists \Delta StackFrame @ StackFramePop2[value!/value1!,oid!/value2!] \land PromoteStackFrameOpEPC \rschexpract \circseq \\
        \t2 pc := i + 1 \circseq putField!oid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assign-seq-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar fid : FieldID \circspot \\
        \t2 \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq  \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract \exists \Delta StackFrame @ StackFramePop2[value!/value1!,oid!/value2!] \land PromoteStackFrameOpEPC \rschexpract \circseq \\
        \t2 putField!oid!fid!value \then \Skip \circseq pc := i + 1 \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Defintion of $InterpreterPushEPC$ \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar fid : FieldID \circspot \\
        \t2 \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq  \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \lschexpract InterpreterPushEPC[value!/value1!,oid!/value2!] \rschexpract \circseq \\
        \t2 putField!oid!fid!value \then \Skip \circseq pc := i + 1 \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq  \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \lschexpract InterpreterPushEPC[value!/value1!,oid!/value2!] \rschexpract \circseq \\
        \t2 putField!oid!fid!value \then \Skip \circseq pc := i + 1 \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{seq-zerol-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq  \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \lschexpract InterpreterPushEPC[value!/value1!,oid!/value2!] \rschexpract \circseq \\
        \t2 putField!oid!fid!value \then \Skip \circseq pc := i + 1 \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \circseq pc := i + 1 \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{alt-seq-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq  \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \lschexpract InterpreterPushEPC[value!/value1!,oid!/value2!] \rschexpract \circseq \\
        \t2 putField!oid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi \circseq pc := i + 1)
      \end{array}\\
      = & Law~[\nameref{var-seq-extr-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq  \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \lschexpract InterpreterPushEPC[value!/value1!,oid!/value2!] \rschexpract \circseq \\
        \t2 putField!oid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi) \circseq pc := i + 1
      \end{array}\\
      = & Law~[\nameref{val-def-law}] \\
      \begin{array}{l}
        (\circval cpIndex : \nat \circspot \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq  \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \lschexpract InterpreterPushEPC[value!/value1!,oid!/value2!] \rschexpract \circseq \\
        \t2 putField!oid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)(cpi) \circseq pc := i + 1
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and definition of $HandlePutfieldEPC$ \\
      \begin{array}{l}
        HandlePutfieldEPC(cpi) \circseq pc := i + 1
      \end{array}\\
      = & Definition of $handleAction$ and case assumption $bc~i = putfield~cpi$ \\
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}\\
    \end{argue}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
    % Case 15: getstatic
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item Suppose $bc~i = getstatic~cpi$ then,
    \begin{argue}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}\\
      \circrefines_A & Similar to previous case \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = getstatic~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = getstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = getstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t2 getStatic!(classOf~currentClass~((getstatic\inv)~(bc~pc)))!(fieldOf~currentClass~((getstatic\inv)~(bc~pc))) \\
        \t2 {} \then getStaticRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = getstatic~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-seq-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = getstatic~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = getstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = getstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t2 getStatic!(classOf~currentClass~cpIndex)!(fieldOf~currentClass~cpIndex) \\
        \t2 {} \then getStaticRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = getstatic~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \circseq cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 getStatic!(classOf~currentClass~cpIndex)!(fieldOf~currentClass~cpIndex) \\
        \t2 {} \then getStaticRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 getStatic!(classOf~currentClass~cpIndex)!(fieldOf~currentClass~cpIndex) \\
        \t2 {} \then getStaticRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 getStatic!(classOf~currentClass~cpIndex)!(fieldOf~currentClass~cpIndex) \\
        \t2 {} \then getStaticRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-alt-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 getStatic!(classOf~currentClass~cpIndex)!(fieldOf~currentClass~cpIndex) \\
        \t2 {} \then getStaticRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-output-prefix-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 getStatic!(classOf~currentClass~cpIndex)!(fieldOf~currentClass~cpIndex) \\
        \t2 {} \then (\{ pc = i \} \circseq getStaticRet?value \then \lschexpract InterpreterPush \rschexpract) \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-input-prefix-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 getStatic!(classOf~currentClass~cpIndex)!(fieldOf~currentClass~cpIndex) \\
        \t2 {} \then (\{ pc = i \} \circseq getStaticRet?value \then (\{ pc = i \} \circseq \lschexpract InterpreterPush \rschexpract)) \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Definition of $InterpreterPush$ \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 getStatic!(classOf~currentClass~cpIndex)!(fieldOf~currentClass~cpIndex) \\
        \t2 {} \then (\{ pc = i \} \circseq getStaticRet?value \then (\{ pc = i \} \circseq \\
        \t2 \lschexpract \exists \Delta StackFrame @
        StackFramePush \land PromoteStackFrameOp \rschexpract)) \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Lemma~\ref{Handle-schema-refinement-lemma} \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 getStatic!(classOf~currentClass~cpIndex)!(fieldOf~currentClass~cpIndex) \\
        \t2 {} \then (\{ pc = i \} \circseq getStaticRet?value \then {} \\
        \t2 (\lschexpract \exists \Delta StackFrame @
        StackFramePush \land PromoteStackFrameOpEPC \rschexpract \circseq pc := i + 1)) \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Similar to case 12 \\
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}\\
    \end{argue}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
    % Case 16: putstatic
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item Suppose $bc~i = putstatic~cpi$ then,
    \begin{argue}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}\\
      \circrefines_A & Similar to previous case \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = putstatic~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~((putstatic\inv)~(bc~pc)) \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~((putstatic\inv)~(bc~pc)) \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = putstatic~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar cid : ClassID \circspot \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t2 cid := classOf~currentClass~((putstatic\inv)~(bc~pc)) \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~((putstatic\inv)~(bc~pc)) \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = putstatic~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar cid : ClassID \circspot \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t2 cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~((putstatic\inv)~(bc~pc)) \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = putstatic~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar cid : ClassID \circspot \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t2 cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~((putstatic\inv)~(bc~pc)) \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = putstatic~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar cid : ClassID \circspot \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t2 cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t2 fid := fieldOf~currentClass~((putstatic\inv)~(bc~pc)) \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = putstatic~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar cid : ClassID \circspot \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t2 cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t2 fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-alt-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \{ pc = i \} \circseq \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \{ pc = i \} \circseq \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \{ pc = i \} \circseq \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Definition of $InterpreterPop$ \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \{ pc = i \} \circseq \\
        \t2 \lschexpract \exists \Delta StackFrame @ StackFramePop \land PromoteStackFrameOp \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Lemma~\ref{Handle-schema-refinement-lemma} \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \\
        \t2 \lschexpract \exists \Delta StackFrame @ StackFramePop \land PromoteStackFrameOpEPC \rschexpract \circseq pc := i + 1 \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assign-seq-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \\
        \t2 \lschexpract \exists \Delta StackFrame @ StackFramePop \land PromoteStackFrameOpEPC \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \circseq pc := i + 1 \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Defintion of $InterpreterPopEPC$ \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPopEPC \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \circseq pc := i + 1 \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPopEPC \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \circseq pc := i + 1 \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{seq-zerol-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPopEPC \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \circseq pc := i + 1 \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \circseq pc := i + 1 \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{alt-seq-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPopEPC \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi \circseq pc := i + 1)
      \end{array}\\
      = & Law~[\nameref{var-seq-extr-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPopEPC \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi) \circseq pc := i + 1
      \end{array}\\
      = & Law~[\nameref{val-def-law}] \\
      \begin{array}{l}
        (\circval cpIndex : \nat \circspot \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPopEPC \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)(cpi) \circseq pc := i + 1
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and definition of $HandlePutstaticEPC$ \\
      \begin{array}{l}
        HandlePutstaticEPC(cpi) \circseq pc := i + 1
      \end{array}\\
      = & Definition of $handleAction$ and case assumption $bc~i = putstatic~cpi$ \\
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}\\
    \end{argue}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
    % Case 17: invokevirtual
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item Suppose $bc~i = invokevirtual~cpi$ for some $cpi \in \nat$ then,
    \begin{argue}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}\\
      \circrefines_A & Similar to previous cases \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = invokevirtual~cpi \} \circseq \\
        \t1 (\circvar cid : ClassID; mid : MethodID; poppedArgs : \seq Word \circspot \\
        \t1 \circif ((invokevirtual\inv)~(bc~pc)) \in methodRefIndices~currentClass \circthen {} \\
        \t2 mid := methodOf~currentClass~((invokevirtual\inv)~(bc~pc)) \circseq \\
        \t2 \lschexpract \exists argsToPop? == methodArguments~mid + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
        \t2 getClassIDOf!(head~poppedArgs)?cid \then Invoke(cid, mid, poppedArgs, \false) \\
        \t1 {} \circelse ((invokevirtual\inv)~(bc~pc)) \notin methodRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-assign-intro-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = invokevirtual~cpi \} \circseq \\
        \t1 (\circvar cpIndex : \nat \circspot cpIndex := (invokevirtual\inv)~(bc~pc) \circseq \\
        \t1 \circvar cid : ClassID; mid : MethodID; poppedArgs : \seq Word \circspot \\
        \t1 \circif ((invokevirtual\inv)~(bc~pc)) \in methodRefIndices~currentClass \circthen {} \\
        \t2 mid := methodOf~currentClass~((invokevirtual\inv)~(bc~pc)) \circseq \\
        \t2 \lschexpract \exists argsToPop? == methodArguments~mid + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
        \t2 getClassIDOf!(head~poppedArgs)?cid \then Invoke(cid, mid, poppedArgs, \false) \\
        \t1 {} \circelse ((invokevirtual\inv)~(bc~pc)) \notin methodRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = invokevirtual~cpi \} \circseq \\
        \t1 (\circvar cpIndex : \nat \circspot \circvar cid : ClassID; mid : MethodID; poppedArgs : \seq Word \circspot \\
        \t1 cpIndex := (invokevirtual\inv)~(bc~pc) \circseq \\
        \t1 \circif ((invokevirtual\inv)~(bc~pc)) \in methodRefIndices~currentClass \circthen {} \\
        \t2 mid := methodOf~currentClass~((invokevirtual\inv)~(bc~pc)) \circseq \\
        \t2 \lschexpract \exists argsToPop? == methodArguments~mid + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
        \t2 getClassIDOf!(head~poppedArgs)?cid \then Invoke(cid, mid, poppedArgs, \false) \\
        \t1 {} \circelse ((invokevirtual\inv)~(bc~pc)) \notin methodRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot
        \circvar cid : ClassID; mid : MethodID; poppedArgs : \seq Word \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = invokevirtual~cpi \} \circseq
        cpIndex := (invokevirtual\inv)~(bc~pc) \circseq \\
        \t1 \circif ((invokevirtual\inv)~(bc~pc)) \in methodRefIndices~currentClass \circthen {} \\
        \t2 mid := methodOf~currentClass~((invokevirtual\inv)~(bc~pc)) \circseq \\
        \t2 \lschexpract \exists argsToPop? == methodArguments~mid + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
        \t2 getClassIDOf!(head~poppedArgs)?cid \then Invoke(cid, mid, poppedArgs, \false) \\
        \t1 {} \circelse ((invokevirtual\inv)~(bc~pc)) \notin methodRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
       = & Law~[\nameref{assign-seq-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot
        \circvar cid : ClassID; mid : MethodID; poppedArgs : \seq Word \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = invokevirtual~cpi \} \circseq
        cpIndex := (invokevirtual\inv)~(bc~pc) \circseq \\
        \t1 \{ ((invokevirtual\inv)~(bc~pc)) = cpIndex \} \circseq \\
        \t1 \circif ((invokevirtual\inv)~(bc~pc)) \in methodRefIndices~currentClass \circthen {} \\
        \t2 mid := methodOf~currentClass~((invokevirtual\inv)~(bc~pc)) \circseq \\
        \t2 \lschexpract \exists argsToPop? == methodArguments~mid + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
        \t2 getClassIDOf!(head~poppedArgs)?cid \then Invoke(cid, mid, poppedArgs, \false) \\
        \t1 {} \circelse ((invokevirtual\inv)~(bc~pc)) \notin methodRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
       = & Law~[\nameref{assump-alt-guard-replace-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot
        \circvar cid : ClassID; mid : MethodID; poppedArgs : \seq Word \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = invokevirtual~cpi \} \circseq
        cpIndex := (invokevirtual\inv)~(bc~pc) \circseq \\
        \t1 \{ ((invokevirtual\inv)~(bc~pc)) = cpIndex \} \circseq \\
        \t1 \circif cpIndex \in methodRefIndices~currentClass \circthen {} \\
        \t2 mid := methodOf~currentClass~((invokevirtual\inv)~(bc~pc)) \circseq \\
        \t2 \lschexpract \exists argsToPop? == methodArguments~mid + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
        \t2 getClassIDOf!(head~poppedArgs)?cid \then Invoke(cid, mid, poppedArgs, \false) \\
        \t1 {} \circelse cpIndex \notin methodRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
       = & Law~[\nameref{assump-alt-dist-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot
        \circvar cid : ClassID; mid : MethodID; poppedArgs : \seq Word \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = invokevirtual~cpi \} \circseq
        cpIndex := (invokevirtual\inv)~(bc~pc) \circseq \\
        \t1 \{ ((invokevirtual\inv)~(bc~pc)) = cpIndex \} \circseq \\
        \t1 \circif cpIndex \in methodRefIndices~currentClass \circthen {} \\
        \t2 \{ ((invokevirtual\inv)~(bc~pc)) = cpIndex \} \circseq \\
        \t2 mid := methodOf~currentClass~((invokevirtual\inv)~(bc~pc)) \circseq \\
        \t2 \lschexpract \exists argsToPop? == methodArguments~mid + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
        \t2 getClassIDOf!(head~poppedArgs)?cid \then Invoke(cid, mid, poppedArgs, \false) \\
        \t1 {} \circelse cpIndex \notin methodRefIndices~currentClass \circthen {} \\
        \t2 \{ ((invokevirtual\inv)~(bc~pc)) = cpIndex \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
       = & Law~[\nameref{assump-seq-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot
        \circvar cid : ClassID; mid : MethodID; poppedArgs : \seq Word \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = invokevirtual~cpi \} \circseq
        cpIndex := (invokevirtual\inv)~(bc~pc) \circseq \\
        \t1 \{ ((invokevirtual\inv)~(bc~pc)) = cpIndex \} \circseq \\
        \t1 \circif cpIndex \in methodRefIndices~currentClass \circthen {} \\
        \t2 \{ ((invokevirtual\inv)~(bc~pc)) = cpIndex \} \circseq \\
        \t2 mid := methodOf~currentClass~cpIndex \circseq \\
        \t2 \lschexpract \exists argsToPop? == methodArguments~mid + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
        \t2 getClassIDOf!(head~poppedArgs)?cid \then Invoke(cid, mid, poppedArgs, \false) \\
        \t1 {} \circelse cpIndex \notin methodRefIndices~currentClass \circthen {} \\
        \t2 \{ ((invokevirtual\inv)~(bc~pc)) = cpIndex \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
       = & Law~[\nameref{assump-seq-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot
        \circvar cid : ClassID; mid : MethodID; poppedArgs : \seq Word \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = invokevirtual~cpi \} \circseq
        cpIndex := cpi \circseq \\
        \t1 \{ ((invokevirtual\inv)~(bc~pc)) = cpIndex \} \circseq \\
        \t1 \circif cpIndex \in methodRefIndices~currentClass \circthen {} \\
        \t2 \{ ((invokevirtual\inv)~(bc~pc)) = cpIndex \} \circseq \\
        \t2 mid := methodOf~currentClass~cpIndex \circseq \\
        \t2 \lschexpract \exists argsToPop? == methodArguments~mid + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
        \t2 getClassIDOf!(head~poppedArgs)?cid \then Invoke(cid, mid, poppedArgs, \false) \\
        \t1 {} \circelse cpIndex \notin methodRefIndices~currentClass \circthen {} \\
        \t2 \{ ((invokevirtual\inv)~(bc~pc)) = cpIndex \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot
        \circvar cid : ClassID; mid : MethodID; poppedArgs : \seq Word \circspot \\
        \t1 cpIndex := cpi \circseq \\
        \t1 \circif (cpIndex \in methodRefIndices~currentClass \circthen {} \\
        \t2 mid := methodOf~currentClass~cpIndex \circseq \\
        \t2 \lschexpract \exists argsToPop? == methodArguments~mid + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
        \t2 getClassIDOf!(head~poppedArgs)?cid \then Invoke(cid, mid, poppedArgs, \false) \\
        \t1 {} \circelse (cpIndex \notin methodRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circvar cid : ClassID; mid : MethodID; poppedArgs : \seq Word \circspot \\
        \t1 \circif (cpIndex \in methodRefIndices~currentClass \circthen {} \\
        \t2 mid := methodOf~currentClass~cpIndex \circseq \\
        \t2 \lschexpract \exists argsToPop? == methodArguments~mid + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
        \t2 getClassIDOf!(head~poppedArgs)?cid \then Invoke(cid, mid, poppedArgs, \false) \\
        \t1 {} \circelse (cpIndex \notin methodRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{val-def-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circval cpIndex : \nat \circspot \\
        \t1 \circvar cid : ClassID; mid : MethodID; poppedArgs : \seq Word \circspot \\
        \t1 \circif (cpIndex \in methodRefIndices~currentClass \circthen {} \\
        \t2 mid := methodOf~currentClass~cpIndex \circseq \\
        \t2 \lschexpract \exists argsToPop? == methodArguments~mid + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
        \t2 getClassIDOf!(head~poppedArgs)?cid \then Invoke(cid, mid, poppedArgs, \false) \\
        \t1 {} \circelse (cpIndex \notin methodRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)(cpi)
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and definition of $HandleInvokevirtualEPC$ \\
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInvokevirtualEPC(cpi)
      \end{array}\\
      = & Definition of $handleAction$ and case assumption $bc~i = invokevirtual~cpi$ \\
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}\\
    \end{argue}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 18: invokespecial
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \item Suppose $bc~i = invokespecial~cpi$ for some $cpi \in \nat$
    then, by similar reasoning to the previous case,
    \begin{circus}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}
      \circrefines_A 
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}
    \end{circus}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
    % Case 19: invokestatic
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \item Suppose $bc~i = invokestatic~cpi$ for some $cpi \in \nat$
    then, by similar reasoning to the previous case,
    \begin{circus}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}
      \circrefines_A
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}
    \end{circus}
  \end{enumerate}
  Thus
  $\{ pc = i \} \circseq HandleInstruction \circrefines_A
  handleAction~(bc~i)$ so the rule holds.
\end{crproof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{crproof}[\nameref{sequence-introduction-rule}]
  We seek to apply Law C.129, taking the RHS of the rule as $Y$, and the LHS as $\circmu X \circspot F(X)$, and proving $F(Y) \circrefines_A Y$:
  \begin{argue}
    \begin{array}{l}
      \circif frameStack = \emptyset \circthen \Skip \\
      {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t1 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \cdots
      \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq \\
      \t2 \begin{array}{l}
            \circmu X \circspot \\
            \circif frameStack = \emptyset \circthen \Skip \\
            {} \circelse frameStack \neq \emptyset \circthen {} \\
            \t1 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
            \circfi
          \end{array} \\
      \t1 \circfi \\
      \circfi
    \end{array}
    \\
    \circrefines_A & Law[alt-seq-dist] (needs to be extended to handle divergent case) \\
    \begin{array}{l}
      \circif frameStack = \emptyset \circthen \Skip \\
      {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t1 \circif {} \cdots {} \\
      \t1 {} \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq \\
      \t2 \begin{array}{l}
            \circmu X \circspot \\
            \t1 \circif frameStack = \emptyset \circthen \Skip \\
            \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
            \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
            \t1 \circfi
          \end{array} \\
      \t1 {} \cdots {} \\
      \t1 {} \circelse pc = j \circthen B \circseq Poll \circseq \\
      \t2 \begin{array}{l}
            \circmu X \circspot \\
            \t1 \circif frameStack = \emptyset \circthen \Skip \\
            \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
            \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
            \t1 \circfi
          \end{array} \\
      \t1 {} \cdots {} \\
      \t1 \circfi \\
      \circfi
    \end{array} \\
    \circrefines_A & Law[alt-assump-intro] \\
    \begin{array}{l}
      \circif frameStack = \emptyset \circthen \{ frameStack = \emptyset \} \\
      {} \circelse frameStack \neq \emptyset \circthen \{ frameStack \neq \emptyset \} \circseq \\
      \t1 \circif {} \cdots {} \\
      \t1 {} \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq \\
      \t2 \begin{array}{l}
            \circmu X \circspot \\
            \t1 \circif frameStack = \emptyset \circthen \Skip \\
            \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
            \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
            \t1 \circfi
          \end{array} \\
      \t1 {} \cdots {} \\
      \t1 {} \circelse pc = j \circthen B \circseq Poll \circseq \\
      \t2 \begin{array}{l}
            \circmu X \circspot \\
            \t1 \circif frameStack = \emptyset \circthen \Skip \\
            \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
            \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
            \t1 \circfi
          \end{array} \\
      \t1 {} \cdots {} \\
      \t1 \circfi \\
      \circfi
    \end{array} \\
    \circrefines_A & Law[assump-alt-dist-move] \\
    \begin{array}{l}
      \circif frameStack = \emptyset \circthen \{ frameStack = \emptyset \} \\
      {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t1 \circif {} \cdots {} \\
      \t1 {} \circelse pc = i \circthen  \{ frameStack \neq \emptyset \} \circseq A \circseq pc := j \circseq Poll \circseq \\
      \t2 \begin{array}{l}
            \circmu X \circspot \\
            \t1 \circif frameStack = \emptyset \circthen \Skip \\
            \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
            \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
            \t1 \circfi
          \end{array} \\
      \t1 {} \cdots {} \\
      \t1 {} \circelse pc = j \circthen  \{ frameStack \neq \emptyset \} \circseq B \circseq Poll \circseq \\
      \t2 \begin{array}{l}
            \circmu X \circspot \\
            \t1 \circif frameStack = \emptyset \circthen \Skip \\
            \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
            \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
            \t1 \circfi
          \end{array} \\
      \t1 {} \cdots {} \\
      \t1 \circfi \\
      \circfi
    \end{array} \\
    \circrefines_A & by assumption \\
    \begin{array}{l}
      \circif frameStack = \emptyset \circthen \{ frameStack = \emptyset \} \\
      {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t1 \circif {} \cdots {} \\
      \t1 {} \circelse pc = i \circthen  \{ frameStack \neq \emptyset \} \circseq A \circseq \{ frameStack \neq \emptyset \} \circseq pc := j \circseq Poll \circseq \\
      \t2 \begin{array}{l}
            \circmu X \circspot \\
            \t1 \circif frameStack = \emptyset \circthen \Skip \\
            \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
            \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
            \t1 \circfi
          \end{array} \\
      \t1 {} \cdots {} \\
      \t1 {} \circelse pc = j \circthen  \{ frameStack \neq \emptyset \} \circseq B \circseq Poll \circseq \\
      \t2 \begin{array}{l}
            \circmu X \circspot \\
            \t1 \circif frameStack = \emptyset \circthen \Skip \\
            \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
            \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
            \t1 \circfi
          \end{array} \\
      \t1 {} \cdots {} \\
      \t1 \circfi \\
      \circfi
    \end{array} \\
    \circrefines_A & Law [assump-assign-dist] \\
    \begin{array}{l}
      \circif frameStack = \emptyset \circthen \{ frameStack = \emptyset \} \\
      {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t1 \circif {} \cdots {} \\
      \t1 {} \circelse pc = i \circthen  \{ frameStack \neq \emptyset \} \circseq A \circseq pc := j \circseq \{ frameStack \neq \emptyset \} \circseq Poll \circseq \\
      \t2 \begin{array}{l}
            \circmu X \circspot \\
            \t1 \circif frameStack = \emptyset \circthen \Skip \\
            \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
            \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
            \t1 \circfi
          \end{array} \\
      \t1 {} \cdots {} \\
      \t1 {} \circelse pc = j \circthen  \{ frameStack \neq \emptyset \} \circseq B \circseq Poll \circseq \\
      \t2 \begin{array}{l}
            \circmu X \circspot \\
            \t1 \circif frameStack = \emptyset \circthen \Skip \\
            \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
            \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
            \t1 \circfi
          \end{array} \\
      \t1 {} \cdots {} \\
      \t1 \circfi \\
      \circfi
    \end{array} \\
    \circrefines_A & $Poll$ doesn't affect $frameStack$ (needs proof) \\
    \begin{array}{l}
      \circif frameStack = \emptyset \circthen \{ frameStack = \emptyset \} \\
      {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t1 \circif {} \cdots {} \\
      \t1 {} \circelse pc = i \circthen  \{ frameStack \neq \emptyset \} \circseq A \circseq pc := j \circseq Poll \circseq \{ frameStack \neq \emptyset \} \circseq \\
      \t2 \begin{array}{l}
            \circmu X \circspot \\
            \t1 \circif frameStack = \emptyset \circthen \Skip \\
            \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
            \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
            \t1 \circfi
          \end{array} \\
      \t1 {} \cdots {} \\
      \t1 {} \circelse pc = j \circthen  \{ frameStack \neq \emptyset \} \circseq B \circseq Poll \circseq \\
      \t2 \begin{array}{l}
            \circmu X \circspot \\
            \t1 \circif frameStack = \emptyset \circthen \Skip \\
            \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
            \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
            \t1 \circfi
          \end{array} \\
      \t1 {} \cdots {} \\
      \t1 \circfi \\
      \circfi
    \end{array} \\
    \circrefines_A & Law C.128 \\
    \begin{array}{l}
      \circif frameStack = \emptyset \circthen \{ frameStack = \emptyset \} \\
      {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t1 \circif {} \cdots {} \\
      \t1 {} \circelse pc = i \circthen  \{ frameStack \neq \emptyset \} \circseq A \circseq pc := j \circseq Poll \circseq \{ frameStack \neq \emptyset \} \circseq \\
      \t2 \begin{array}{l}
            \circif frameStack = \emptyset \circthen \Skip \\
            {} \circelse frameStack \neq \emptyset \circthen {} \\
            \t1 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq \\
            \t1 \begin{array}{l}
                  \circmu X \circspot \\
                  \t1 \circif frameStack = \emptyset \circthen \Skip \\
                  \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
                  \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
                  \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
                  \t1 \circfi
                \end{array} \\
            \circfi
          \end{array} \\
      \t1 {} \cdots {} \\
      \t1 {} \circelse pc = j \circthen  \{ frameStack \neq \emptyset \} \circseq B \circseq Poll \circseq \\
      \t2 \begin{array}{l}
            \circmu X \circspot \\
            \t1 \circif frameStack = \emptyset \circthen \Skip \\
            \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
            \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
            \t1 \circfi
          \end{array} \\
      \t1 {} \cdots {} \\
      \t1 \circfi \\
      \circfi
    \end{array} \\
    \circrefines_A & collapse conditional with assumption  \\
    \begin{array}{l}
      \circif frameStack = \emptyset \circthen \{ frameStack = \emptyset \} \\
      {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t1 \circif {} \cdots {} \\
      \t1 {} \circelse pc = i \circthen  \{ frameStack \neq \emptyset \} \circseq A \circseq pc := j \circseq Poll \circseq \{ frameStack \neq \emptyset \} \circseq \\
      \t2 \begin{array}{l}
            \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq \\
            \begin{array}{l}
              \circmu X \circspot \\
              \t1 \circif frameStack = \emptyset \circthen \Skip \\
              \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
              \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
              \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
              \t1 \circfi
            \end{array}
          \end{array} \\
      \t1 {} \cdots {} \\
      \t1 {} \circelse pc = j \circthen  \{ frameStack \neq \emptyset \} \circseq B \circseq Poll \circseq \\
      \t2 \begin{array}{l}
            \circmu X \circspot \\
            \t1 \circif frameStack = \emptyset \circthen \Skip \\
            \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
            \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
            \t1 \circfi
          \end{array} \\
      \t1 {} \cdots {} \\
      \t1 \circfi \\
      \circfi
    \end{array} \\
    \circrefines_A & Law [assign-assump-intro] \\
    \begin{array}{l}
      \circif frameStack = \emptyset \circthen \{ frameStack = \emptyset \} \\
      {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t1 \circif {} \cdots {} \\
      \t1 {} \circelse pc = i \circthen \{ frameStack \neq \emptyset \} \circseq A \circseq pc := j \circseq \{ pc = j \} \circseq Poll \circseq \{ frameStack \neq \emptyset \} \circseq \\
      \t2 \begin{array}{l}
            \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq \\
            \begin{array}{l}
              \circmu X \circspot \\
              \t1 \circif frameStack = \emptyset \circthen \Skip \\
              \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
              \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
              \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
              \t1 \circfi
            \end{array}
          \end{array} \\
      \t1 {} \cdots {} \\
      \t1 {} \circelse pc = j \circthen  \{ frameStack \neq \emptyset \} \circseq B \circseq Poll \circseq \\
      \t2 \begin{array}{l}
            \circmu X \circspot \\
            \t1 \circif frameStack = \emptyset \circthen \Skip \\
            \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
            \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
            \t1 \circfi
          \end{array} \\
      \t1 {} \cdots {} \\
      \t1 \circfi \\
      \circfi
    \end{array} \\
    \circrefines_A & $Poll$ doesn't affect $pc$ \\
    \begin{array}{l}
      \circif frameStack = \emptyset \circthen \{ frameStack = \emptyset \} \\
      {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t1 \circif {} \cdots {} \\
      \t1 {} \circelse pc = i \circthen \{ frameStack \neq \emptyset \} \circseq A \circseq pc := j \circseq Poll \circseq \{ pc = j \} \circseq \{ frameStack \neq \emptyset \} \circseq \\
      \t2 \begin{array}{l}
            \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq \\
            \begin{array}{l}
              \circmu X \circspot \\
              \t1 \circif frameStack = \emptyset \circthen \Skip \\
              \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
              \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
              \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
              \t1 \circfi
            \end{array}
          \end{array} \\
      \t1 {} \cdots {} \\
      \t1 {} \circelse pc = j \circthen  \{ frameStack \neq \emptyset \} \circseq B \circseq Poll \circseq \\
      \t2 \begin{array}{l}
            \circmu X \circspot \\
            \t1 \circif frameStack = \emptyset \circthen \Skip \\
            \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
            \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
            \t1 \circfi
          \end{array} \\
      \t1 {} \cdots {} \\
      \t1 \circfi \\
      \circfi
    \end{array} \\
    \circrefines_A & swap disjoint assumptions \\
    \begin{array}{l}
      \circif frameStack = \emptyset \circthen \{ frameStack = \emptyset \} \\
      {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t1 \circif {} \cdots {} \\
      \t1 {} \circelse pc = i \circthen \{ frameStack \neq \emptyset \} \circseq A \circseq pc := j \circseq Poll \circseq \{ frameStack \neq \emptyset \} \circseq \{ pc = j \} \circseq \\
      \t2 \begin{array}{l}
            \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq \\
            \begin{array}{l}
              \circmu X \circspot \\
              \t1 \circif frameStack = \emptyset \circthen \Skip \\
              \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
              \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
              \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
              \t1 \circfi
            \end{array}
          \end{array} \\
      \t1 {} \cdots {} \\
      \t1 {} \circelse pc = j \circthen  \{ frameStack \neq \emptyset \} \circseq B \circseq Poll \circseq \\
      \t2 \begin{array}{l}
            \circmu X \circspot \\
            \t1 \circif frameStack = \emptyset \circthen \Skip \\
            \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
            \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
            \t1 \circfi
          \end{array} \\
      \t1 {} \cdots {} \\
      \t1 \circfi \\
      \circfi
    \end{array} \\
    \circrefines_A & use assumption to collapse conditional \\
    \begin{array}{l}
      \circif frameStack = \emptyset \circthen \{ frameStack = \emptyset \} \\
      {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t1 \circif {} \cdots {} \\
      \t1 {} \circelse pc = i \circthen \{ frameStack \neq \emptyset \} \circseq A \circseq pc := j \circseq Poll \circseq \{ frameStack \neq \emptyset \} \circseq \{ pc = j \} \circseq B \circseq Poll \circseq \\
            \t2 \begin{array}{l}
              \circmu X \circspot \\
              \t1 \circif frameStack = \emptyset \circthen \Skip \\
              \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
              \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
              \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
              \t1 \circfi
            \end{array} \\
      \t1 {} \cdots {} \\
      \t1 {} \circelse pc = j \circthen  \{ frameStack \neq \emptyset \} \circseq B \circseq Poll \circseq \\
      \t2 \begin{array}{l}
            \circmu X \circspot \\
            \t1 \circif frameStack = \emptyset \circthen \Skip \\
            \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
            \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
            \t1 \circfi
          \end{array} \\
      \t1 {} \cdots {} \\
      \t1 \circfi \\
      \circfi
    \end{array} \\
    \circrefines_A & remove assumptions (Laws C.35 and C.132) \\
    \begin{array}{l}
      \circif frameStack = \emptyset \circthen \Skip \\
      {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t1 \circif {} \cdots {} \\
      \t1 {} \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \circseq Poll \circseq \\
            \t2 \begin{array}{l}
              \circmu X \circspot \\
              \t1 \circif frameStack = \emptyset \circthen \Skip \\
              \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
              \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
              \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
              \t1 \circfi
            \end{array} \\
      \t1 {} \cdots {} \\
      \t1 {} \circelse pc = j \circthen B \circseq Poll \circseq \\
      \t2 \begin{array}{l}
            \circmu X \circspot \\
            \t1 \circif frameStack = \emptyset \circthen \Skip \\
            \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
            \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
            \t1 \circfi
          \end{array} \\
      \t1 {} \cdots {} \\
      \t1 \circfi \\
      \circfi
    \end{array} \\
    \circrefines_A & Law [alt-seq-dist] in reverse \\
    \begin{array}{l}
      \circif frameStack = \emptyset \circthen \Skip \\
      {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t1 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq \\
      \t2 \begin{array}{l}
            \circmu X \circspot \\
            \t1 \circif frameStack = \emptyset \circthen \Skip \\
            \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
            \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
            \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
            \t1 \circfi
          \end{array} \\\\
      \circfi
    \end{array} \\
    \circrefines_A & Law C.128 in reverse \\
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif {} \cdots \circelse pc = i \circthen A \circseq pc := j \circseq Poll \circseq B \cdots
      \circelse pc = j \circthen B \cdots \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
  \end{argue}
  So we have $F(Y) \circrefines_A Y$ and so, by Law C.129, $\circmu X \circspot F(X) \circrefines Y$.
\end{crproof}

\begin{crproof}[\nameref{if-introduction-rule}]
  We seek to apply Law C.129, taking the RHS of the rule as $Y$, and the LHS as $\circmu X \circspot F(X)$, and proving $F(Y) \circrefines_A Y$:
  \begin{argue}
    \begin{array}{l}
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq pc := \IF b \THEN j \ELSE k \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq \\
      \t2 \circmu X \circspot \\
      \t2 \circif frameStack = \emptyset \circthen \Skip \\
      \t2 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t3 \circif \cdots \\
      \t3 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t4 \circif b \circthen \Skip \\
      \t4 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t4 \circfi \circseq pc := j \\
      \t3 {} \cdots {} \\
      \t3 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t3 {} \cdots {} \\
      \t3 \circfi \circseq Poll \circseq X \\
      \t2 \circfi \\ 
      \t1 \circfi
    \end{array} \\
    \circrefines_A & introduce alternation \\
    \begin{array}{l}
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 \circif b \circthen pc := \IF b \THEN j \ELSE k \\
      \t3 {} \circelse \lnot b \circthen pc := \IF b \THEN j \ELSE k \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq \\
      \t2 \circmu X \circspot \\
      \t2 \circif frameStack = \emptyset \circthen \Skip \\
      \t2 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t3 \circif \cdots \\
      \t3 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t4 \circif b \circthen \Skip \\
      \t4 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t4 \circfi \circseq pc := j \\
      \t3 {} \cdots {} \\
      \t3 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t3 {} \cdots {} \\
      \t3 \circfi \circseq Poll \circseq X \\
      \t2 \circfi \\ 
      \t1 \circfi
    \end{array} \\
    \circrefines_A & introduce assumptions \\
    \begin{array}{l}
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 \circif b \circthen \{b\} \circseq pc := \IF b \THEN j \ELSE k \\
      \t3 {} \circelse \lnot b \circthen \{\lnot b\} \circseq pc := \IF b \THEN j \ELSE k \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq \\
      \t2 \circmu X \circspot \\
      \t2 \circif frameStack = \emptyset \circthen \Skip \\
      \t2 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t3 \circif \cdots \\
      \t3 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t4 \circif b \circthen \Skip \\
      \t4 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t4 \circfi \circseq pc := j \\
      \t3 {} \cdots {} \\
      \t3 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t3 {} \cdots {} \\
      \t3 \circfi \circseq Poll \circseq X \\
      \t2 \circfi \\ 
      \t1 \circfi
    \end{array} \\
    \circrefines_A & collapse conditionals \\
    \begin{array}{l}
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 \circif b \circthen \{b\} \circseq pc := j \\
      \t3 {} \circelse \lnot b \circthen \{\lnot b\} \circseq pc := k \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq \\
      \t2 \circmu X \circspot \\
      \t2 \circif frameStack = \emptyset \circthen \Skip \\
      \t2 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t3 \circif \cdots \\
      \t3 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t4 \circif b \circthen \Skip \\
      \t4 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t4 \circfi \circseq pc := j \\
      \t3 {} \cdots {} \\
      \t3 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t3 {} \cdots {} \\
      \t3 \circfi \circseq Poll \circseq X \\
      \t2 \circfi \\ 
      \t1 \circfi
    \end{array} \\
    \circrefines_A & eliminate assumptions \\
    \begin{array}{l}
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 \circif b \circthen pc := j \\
      \t3 {} \circelse \lnot b \circthen pc := k \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq \\
      \t2 \circmu X \circspot \\
      \t2 \circif frameStack = \emptyset \circthen \Skip \\
      \t2 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t3 \circif \cdots \\
      \t3 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t4 \circif b \circthen \Skip \\
      \t4 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t4 \circfi \circseq pc := j \\
      \t3 {} \cdots {} \\
      \t3 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t3 {} \cdots {} \\
      \t3 \circfi \circseq Poll \circseq X \\
      \t2 \circfi \\ 
      \t1 \circfi
    \end{array} \\
    \circrefines_A & distribute sequential composition over alternation \\
    \begin{array}{l}
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 \circif b \circthen pc := j \\
      \t3 {} \circelse \lnot b \circthen pc := k \\
      \t3 \circfi \circseq Poll \circseq \circmu X \circspot \\
      \t3 \circif frameStack = \emptyset \circthen \Skip \\
      \t3 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t4 \circif \cdots \\
      \t4 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t5 \circif b \circthen \Skip \\
      \t5 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t5 \circfi \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 \circfi \circseq Poll \circseq X \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen B \circseq pc := j \circseq Poll \circseq \circmu X \circspot \\
      \t3 \circif frameStack = \emptyset \circthen \Skip \\
      \t3 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t4 \circif \cdots \\
      \t4 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t5 \circif b \circthen \Skip \\
      \t5 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t5 \circfi \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 \circfi \circseq Poll \circseq X \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 \circfi \\
      \t1 \circfi
    \end{array} \\
    \circrefines_A & distribute sequential composition over alternation \\
    \begin{array}{l}
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 \circif b \circthen pc := j \circseq Poll \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 {} \circelse \lnot b \circthen pc := k \circseq Poll \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen B \circseq pc := j \circseq Poll \circseq \circmu X \circspot \\
      \t3 \circif frameStack = \emptyset \circthen \Skip \\
      \t3 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t4 \circif \cdots \\
      \t4 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t5 \circif b \circthen \Skip \\
      \t5 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t5 \circfi \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 \circfi \circseq Poll \circseq X \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 \circfi \\
      \t1 \circfi
    \end{array} \\
    \circrefines_A & introduce assumption \\
    \begin{array}{l}
      \t1 \circif frameStack = \emptyset \circthen \{frameStack = \emptyset\} \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen \{frameStack \neq \emptyset\} \circseq \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 \circif b \circthen pc := j \circseq Poll \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 {} \circelse \lnot b \circthen pc := k \circseq Poll \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen B \circseq pc := j \circseq Poll \circseq \circmu X \circspot \\
      \t3 \circif frameStack = \emptyset \circthen \Skip \\
      \t3 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t4 \circif \cdots \\
      \t4 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t5 \circif b \circthen \Skip \\
      \t5 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t5 \circfi \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 \circfi \circseq Poll \circseq X \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 \circfi \\
      \t1 \circfi
    \end{array} \\
    \circrefines_A & distribute assumption into conditional \\
    \begin{array}{l}
      \t1 \circif frameStack = \emptyset \circthen \{frameStack = \emptyset\} \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen \{frameStack \neq \emptyset\} \circseq \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen \{frameStack \neq \emptyset\} \circseq A \circseq \\
      \t3 \circif b \circthen pc := j \circseq Poll \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 {} \circelse \lnot b \circthen pc := k \circseq Poll \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen \{frameStack \neq \emptyset\} \circseq B \circseq pc := j \circseq Poll \circseq \circmu X \circspot \\
      \t3 \circif frameStack = \emptyset \circthen \Skip \\
      \t3 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t4 \circif \cdots \\
      \t4 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t5 \circif b \circthen \Skip \\
      \t5 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t5 \circfi \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 \circfi \circseq Poll \circseq X \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 \circfi \\
      \t1 \circfi
    \end{array} \\
    \circrefines_A & precondition of rule \\
    \begin{array}{l}
      \t1 \circif frameStack = \emptyset \circthen \{frameStack = \emptyset\} \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen \{frameStack \neq \emptyset\} \circseq \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\} \circseq \\
      \t3 \circif b \circthen pc := j \circseq Poll \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 {} \circelse \lnot b \circthen pc := k \circseq Poll \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen \{frameStack \neq \emptyset\} \circseq B \circseq pc := j \circseq Poll \circseq \circmu X \circspot \\
      \t3 \circif frameStack = \emptyset \circthen \Skip \\
      \t3 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t4 \circif \cdots \\
      \t4 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t5 \circif b \circthen \Skip \\
      \t5 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t5 \circfi \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 \circfi \circseq Poll \circseq X \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 \circfi \\
      \t1 \circfi
    \end{array} \\
    \circrefines_A & distribute assumption into conditional \\
    \begin{array}{l}
      \t1 \circif frameStack = \emptyset \circthen \{frameStack = \emptyset\} \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen \{frameStack \neq \emptyset\} \circseq \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\} \circseq \\
      \t3 \circif b \circthen \{frameStack \neq \emptyset\} \circseq pc := j \circseq Poll \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 {} \circelse \lnot b \circthen \{frameStack \neq \emptyset\} \circseq pc := k \circseq Poll \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen \{frameStack \neq \emptyset\} \circseq B \circseq pc := j \circseq Poll \circseq \circmu X \circspot \\
      \t3 \circif frameStack = \emptyset \circthen \Skip \\
      \t3 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t4 \circif \cdots \\
      \t4 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t5 \circif b \circthen \Skip \\
      \t5 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t5 \circfi \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 \circfi \circseq Poll \circseq X \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 \circfi \\
      \t1 \circfi
    \end{array} \\
    \circrefines_A & $pc$ assignment doesn't affect $frameStack$ \\
    \begin{array}{l}
      \t1 \circif frameStack = \emptyset \circthen \{frameStack = \emptyset\} \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen \{frameStack \neq \emptyset\} \circseq \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\} \circseq \\
      \t3 \circif b \circthen pc := j \circseq \{frameStack \neq \emptyset\} \circseq Poll \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 {} \circelse \lnot b \circthen pc := k \circseq \{frameStack \neq \emptyset\} \circseq Poll \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen \{frameStack \neq \emptyset\} \circseq B \circseq pc := j \circseq Poll \circseq \circmu X \circspot \\
      \t3 \circif frameStack = \emptyset \circthen \Skip \\
      \t3 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t4 \circif \cdots \\
      \t4 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t5 \circif b \circthen \Skip \\
      \t5 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t5 \circfi \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 \circfi \circseq Poll \circseq X \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 \circfi \\
      \t1 \circfi
    \end{array} \\
    \circrefines_A & $Poll$ doesn't affect $frameStack$ \\
    \begin{array}{l}
      \t1 \circif frameStack = \emptyset \circthen \{frameStack = \emptyset\} \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen \{frameStack \neq \emptyset\} \circseq \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\} \circseq \\
      \t3 \circif b \circthen pc := j \circseq Poll \circseq \{frameStack \neq \emptyset\} \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 {} \circelse \lnot b \circthen pc := k \circseq Poll \circseq \{frameStack \neq \emptyset\} \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen \{frameStack \neq \emptyset\} \circseq B \circseq pc := j \circseq Poll \circseq \circmu X \circspot \\
      \t3 \circif frameStack = \emptyset \circthen \Skip \\
      \t3 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t4 \circif \cdots \\
      \t4 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t5 \circif b \circthen \Skip \\
      \t5 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t5 \circfi \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 \circfi \circseq Poll \circseq X \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 \circfi \\
      \t1 \circfi
    \end{array} \\
    \circrefines_A & unroll loop \\
    \begin{array}{l}
      \t1 \circif frameStack = \emptyset \circthen \{frameStack = \emptyset\} \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen \{frameStack \neq \emptyset\} \circseq \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\} \circseq \\
      \t3 \circif b \circthen pc := j \circseq Poll \circseq \{frameStack \neq \emptyset\} \circseq \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 {} \circelse \lnot b \circthen pc := k \circseq Poll \circseq \{frameStack \neq \emptyset\} \circseq \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen \{frameStack \neq \emptyset\} \circseq B \circseq pc := j \circseq Poll \circseq \circmu X \circspot \\
      \t3 \circif frameStack = \emptyset \circthen \Skip \\
      \t3 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t4 \circif \cdots \\
      \t4 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t5 \circif b \circthen \Skip \\
      \t5 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t5 \circfi \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 \circfi \circseq Poll \circseq X \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 \circfi \\
      \t1 \circfi
    \end{array} \\
    \circrefines_A & collapse conditionals \\
    \begin{array}{l}
      \t1 \circif frameStack = \emptyset \circthen \{frameStack = \emptyset\} \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen \{frameStack \neq \emptyset\} \circseq \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\} \circseq \\
      \t3 \circif b \circthen pc := j \circseq Poll \circseq \{frameStack \neq \emptyset\} \circseq \\
      \t4 \circif \cdots \\
      \t4 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t5 \circif b \circthen \Skip \\
      \t5 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t5 \circfi \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 \circfi \circseq Poll \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 {} \circelse \lnot b \circthen pc := k \circseq Poll \circseq \{frameStack \neq \emptyset\} \circseq \\
      \t4 \circif \cdots \\
      \t4 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t5 \circif b \circthen \Skip \\
      \t5 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t5 \circfi \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 \circfi \circseq Poll \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen \{frameStack \neq \emptyset\} \circseq B \circseq pc := j \circseq Poll \circseq \circmu X \circspot \\
      \t3 \circif frameStack = \emptyset \circthen \Skip \\
      \t3 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t4 \circif \cdots \\
      \t4 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t5 \circif b \circthen \Skip \\
      \t5 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t5 \circfi \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 \circfi \circseq Poll \circseq X \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 \circfi \\
      \t1 \circfi
    \end{array} \\
    \circrefines_A & introduce assumptions \\
    \begin{array}{l}
      \t1 \circif frameStack = \emptyset \circthen \{frameStack = \emptyset\} \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen \{frameStack \neq \emptyset\} \circseq \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\} \circseq \\
      \t3 \circif b \circthen pc := j \circseq \{pc = j\} \circseq Poll \circseq \{frameStack \neq \emptyset\} \circseq \\
      \t4 \circif \cdots \\
      \t4 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t5 \circif b \circthen \Skip \\
      \t5 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t5 \circfi \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 \circfi \circseq Poll \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 {} \circelse \lnot b \circthen pc := k \circseq \{ pc = k\} \circseq Poll \circseq \{frameStack \neq \emptyset\} \circseq \\
      \t4 \circif \cdots \\
      \t4 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t5 \circif b \circthen \Skip \\
      \t5 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t5 \circfi \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 \circfi \circseq Poll \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen \{frameStack \neq \emptyset\} \circseq B \circseq pc := j \circseq Poll \circseq \circmu X \circspot \\
      \t3 \circif frameStack = \emptyset \circthen \Skip \\
      \t3 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t4 \circif \cdots \\
      \t4 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t5 \circif b \circthen \Skip \\
      \t5 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t5 \circfi \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 \circfi \circseq Poll \circseq X \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 \circfi \\
      \t1 \circfi
    \end{array} \\
    \circrefines_A & $Poll$ doesn't affect $pc$ \\
    \begin{array}{l}
      \t1 \circif frameStack = \emptyset \circthen \{frameStack = \emptyset\} \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen \{frameStack \neq \emptyset\} \circseq \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\} \circseq \\
      \t3 \circif b \circthen pc := j \circseq Poll \circseq \{pc = j\} \circseq  \{frameStack \neq \emptyset\} \circseq \\
      \t4 \circif \cdots \\
      \t4 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t5 \circif b \circthen \Skip \\
      \t5 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t5 \circfi \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 \circfi \circseq Poll \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 {} \circelse \lnot b \circthen pc := k \circseq Poll \circseq \{ pc = k\} \circseq \{frameStack \neq \emptyset\} \circseq \\
      \t4 \circif \cdots \\
      \t4 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t5 \circif b \circthen \Skip \\
      \t5 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t5 \circfi \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 \circfi \circseq Poll \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen \{frameStack \neq \emptyset\} \circseq B \circseq pc := j \circseq Poll \circseq \circmu X \circspot \\
      \t3 \circif frameStack = \emptyset \circthen \Skip \\
      \t3 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t4 \circif \cdots \\
      \t4 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t5 \circif b \circthen \Skip \\
      \t5 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t5 \circfi \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 \circfi \circseq Poll \circseq X \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 \circfi \\
      \t1 \circfi
    \end{array} \\
    \circrefines_A & $frameStack$ and $pc$ are independent \\
    \begin{array}{l}
      \t1 \circif frameStack = \emptyset \circthen \{frameStack = \emptyset\} \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen \{frameStack \neq \emptyset\} \circseq \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\} \circseq \\
      \t3 \circif b \circthen pc := j \circseq Poll \circseq  \{frameStack \neq \emptyset\} \circseq \{pc = j\} \circseq \\
      \t4 \circif \cdots \\
      \t4 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t5 \circif b \circthen \Skip \\
      \t5 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t5 \circfi \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 \circfi \circseq Poll \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 {} \circelse \lnot b \circthen pc := k \circseq Poll \circseq \{frameStack \neq \emptyset\} \circseq \{ pc = k\} \circseq \\
      \t4 \circif \cdots \\
      \t4 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t5 \circif b \circthen \Skip \\
      \t5 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t5 \circfi \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 \circfi \circseq Poll \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen \{frameStack \neq \emptyset\} \circseq B \circseq pc := j \circseq Poll \circseq \circmu X \circspot \\
      \t3 \circif frameStack = \emptyset \circthen \Skip \\
      \t3 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t4 \circif \cdots \\
      \t4 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t5 \circif b \circthen \Skip \\
      \t5 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t5 \circfi \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 \circfi \circseq Poll \circseq X \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 \circfi \\
      \t1 \circfi
    \end{array} \\
    \circrefines_A & collapse conditional \\
    \begin{array}{l}
      \t1 \circif frameStack = \emptyset \circthen \{frameStack = \emptyset\} \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen \{frameStack \neq \emptyset\} \circseq \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\} \circseq \\
      \t3 \circif b \circthen pc := j \circseq Poll \circseq  \{frameStack \neq \emptyset\} \circseq \{pc = j\} \circseq \\
      \t4 \circif \cdots \\
      \t4 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t5 \circif b \circthen \Skip \\
      \t5 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t5 \circfi \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 \circfi \circseq Poll \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 {} \circelse \lnot b \circthen pc := k \circseq Poll \circseq \{frameStack \neq \emptyset\} \circseq \{ pc = k\} \circseq B \circseq pc := j \circseq Poll \circseq \circmu X \circspot \\
      \t4 \circif frameStack = \emptyset \circthen \Skip \\
      \t4 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t5 \circif \cdots \\
      \t5 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t6 \circif b \circthen \Skip \\
      \t6 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t6 \circfi \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t5 {} \cdots {} \\
      \t5 \circfi \circseq Poll \circseq X \\
      \t4 \circfi \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen \{frameStack \neq \emptyset\} \circseq B \circseq pc := j \circseq Poll \circseq \circmu X \circspot \\
      \t3 \circif frameStack = \emptyset \circthen \Skip \\
      \t3 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t4 \circif \cdots \\
      \t4 {} \circelse pc = i \circthen A \circseq Poll \circseq \\
      \t5 \circif b \circthen \Skip \\
      \t5 {} \circelse \lnot b \circthen pc := k \circseq B \\
      \t5 \circfi \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t4 {} \cdots {} \\
      \t4 \circfi \circseq Poll \circseq X \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 \circfi \\
      \t1 \circfi
    \end{array} \\
  \end{argue}
\end{crproof}

\section{Additional Lemmas for Compilation Rule Proofs}

\begin{lem}[$Handle$-schema-refinement]
  \label{Handle-schema-refinement-lemma}
  If the free variables of $S$ do not include $Interpreter$ or $Interpreter'$ then,
  \begin{circus}
    \{ pc = i \} \circseq \lschexpract \exists \Delta StackFrame @ S \land PromoteStackFrameOp \rschexpract \\
    {} \circrefines_A {} \\
    \lschexpract \exists \Delta StackFrame @ S \land PromoteStackFrameOpEPC \rschexpract \circseq pc := i + 1
  \end{circus}
  \begin{crproof}
    \begin{argue}
      \begin{array}{l}
        \{ pc = i \} \circseq \lschexpract \exists \Delta StackFrame @ S \land PromoteStackFrameOp \rschexpract
      \end{array}\\
      = & Definition of $PromoteStackFrameOp$ \\
      \begin{array}{l}
        \{ pc = i \} \circseq \lschexpract \exists \Delta StackFrame @ S \land [\Delta InterpreterState; \Delta StackFrame | \\
	\t1 \theta StackFrame = last~frameStack \land frameStack' = (front~frameStack) \cat \langle \theta StackFrame~' \rangle \land \\
	\t1 pc' = pc + 1 \land currentClass' = currentClass \land frameStackID' = frameStackID] \rschexpract
      \end{array}\\
      = & Definition of $PromoteStackFrameOp$ \\
      \begin{array}{l}
        \{ pc = i \} \circseq \lschexpract \exists \Delta StackFrame @ S \land [\Delta InterpreterState; \Delta StackFrame | \\
	\t1 \theta StackFrame = last~frameStack \land frameStack' = (front~frameStack) \cat \langle \theta StackFrame~' \rangle \land \\
	\t1 pc' = pc + 1 \land currentClass' = currentClass \land frameStackID' = frameStackID] \rschexpract
      \end{array}\\
      = & Schema calculus \\
      \begin{array}{l}
        \{ pc = i \} \circseq \lschexpract \exists \Delta StackFrame @ S \land ([\Delta InterpreterState; \Delta StackFrame | \\
	\t1 \theta StackFrame = last~frameStack \land frameStack' = (front~frameStack) \cat \langle \theta StackFrame~' \rangle \land \\
	\t1 pc' = pc \land currentClass' = currentClass \land frameStackID' = frameStackID] \semi \\
        \t1 [\Delta InterpreterState; \Delta StackFrame | \theta StackFrame~' = \theta StackFrame \land \\
	\t1 pc' = pc + 1 \land currentClass' = currentClass \land frameStackID' = frameStackID]) \rschexpract
      \end{array}\\
      = & Schema calculus \\
      \begin{array}{l}
        \{ pc = i \} \circseq \lschexpract (\exists \Delta StackFrame @ (S \land [\Delta InterpreterState; \Delta StackFrame | \\
	\t1 \theta StackFrame = last~frameStack \land frameStack' = (front~frameStack) \cat \langle \theta StackFrame~' \rangle \land \\
	\t1 pc' = pc \land currentClass' = currentClass \land frameStackID' = frameStackID])) \semi \\
        \t1 [\Delta InterpreterState | pc' = pc + 1 \land currentClass' = currentClass \land frameStackID' = frameStackID]) \rschexpract
      \end{array}\\
      = & Law~[\nameref{schema-comp-seq-conv-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq \lschexpract \exists \Delta StackFrame @ S \land [\Delta InterpreterState; \Delta StackFrame | \\
	\t1 \theta StackFrame = last~frameStack \land frameStack' = (front~frameStack) \cat \langle \theta StackFrame~' \rangle \land \\
	\t1 pc' = pc \land currentClass' = currentClass \land frameStackID' = frameStackID] \rschexpract \circseq \\
        \t1 \lschexpract [\Delta InterpreterState | pc' = pc + 1 \land currentClass' = currentClass \land frameStackID' = frameStackID]) \rschexpract
      \end{array}\\
      = & Law~[\nameref{assign-schema-conv-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq \lschexpract \exists \Delta StackFrame @ S \land [\Delta InterpreterState; \Delta StackFrame | \\
	\t1 \theta StackFrame = last~frameStack \land frameStack' = (front~frameStack) \cat \langle \theta StackFrame~' \rangle \land \\
	\t1 pc' = pc \land currentClass' = currentClass \land frameStackID' = frameStackID] \rschexpract \circseq \\
        \t1 pc := pc + 1 
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-schema-dist-law}] \\
      \begin{array}{l}
        \lschexpract \exists \Delta StackFrame @ S \land [\Delta InterpreterState; \Delta StackFrame | \\
	\t1 \theta StackFrame = last~frameStack \land frameStack' = (front~frameStack) \cat \langle \theta StackFrame~' \rangle \land \\
	\t1 pc' = pc \land currentClass' = currentClass \land frameStackID' = frameStackID] \rschexpract \circseq \\
        \t1 \{ pc = i \} \circseq pc := pc + 1 
      \end{array}\\
      = & Law~[\nameref{assump-assign-subst-law}] \\
      \begin{array}{l}
        \lschexpract \exists \Delta StackFrame @ S \land [\Delta InterpreterState; \Delta StackFrame | \\
	\t1 \theta StackFrame = last~frameStack \land frameStack' = (front~frameStack) \cat \langle \theta StackFrame~' \rangle \land \\
	\t1 pc' = pc \land currentClass' = currentClass \land frameStackID' = frameStackID] \rschexpract \circseq \\
        \t1 \{ pc = i \} \circseq pc := i + 1 
      \end{array}\\
      = & Definition of $PromoteStackFrameOpEPC$ \\
      \begin{array}{l}
        \lschexpract \exists \Delta StackFrame @ S \land PromoteStackFrameOpEPC \rschexpract \circseq \{ pc = i \} \circseq pc := i + 1 
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        \lschexpract \exists \Delta StackFrame @ S \land PromoteStackFrameOpEPC \rschexpract \circseq pc := i + 1 
      \end{array}\\
    \end{argue}
  \end{crproof}
\end{lem}

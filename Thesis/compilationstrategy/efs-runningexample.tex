After the elimination of program counter stage, each conditional
branch in a method ends with a return instruction or an infinite loop.
This can be seen in
Figure~\ref{pc-elimination-HandleAsyncEvent-example-figure}, presented
earlier, where $TPK\_handleAsyncEvent$ ends with a $HandleReturnEPC$
action.
In the first step of this stage, at
line~\ref{algorithm-remove-launcher-returns} of
Algorithm~\ref{efs-algorithm}, such actions are moved outside the
method and their definitions are expanded so that their communication
with the $Launcher$ can be handled.
This is performed as described in
Algorithm~\ref{remove-launcher-returns-algorithm}, which defines the
procedure \Call{RemoveLauncherReturns}{}.
\begin{algorithm}[ht]
  \begin{algorithmic}[1]
    \For{$m \gets methods$}
    \State \ApplyTo{Law~[\nameref{rec-action-intro-law}]}{$m$}
    \label{algorithm-introduce-infinite-loop-returns}
    \State \ApplyTo{Law~[\nameref{alt-seq-dist-law}]}{$m$}
    \label{algorithm-distribute-returns}
    \State \ApplyFor{Law~[\nameref{copy-rule-law}]}{$m$}
    \label{algorithm-eliminate-returns-copy-method-in}
    \State \ApplyFor{Law~[\nameref{action-intro-law}]}{$m$}
    \State \ApplyFor{Law~[\nameref{action-intro-law}]}{$m$}
    \State \ApplyFor{Law~[\nameref{copy-rule-law}]}{$m$}
    \label{algorithm-eliminate-returns-copy-method-out}
    \EndFor
    \State \Call{IntroduceFrameStackAssumptions}{}
    \label{algorithm-introduce-frameStack-assumptions}
    \For{$x \gets$ \Call{ReturnInstructions}{}}
    \Try
    \label{algorithm-eliminate-returns-try-begin}
    \State \ApplyFor{Rule~[\nameref{refine-HandleReturnEPC-empty-frameStack-rule}]}{$x$}
    \State \ApplyFor{Rule~[\nameref{refine-HandleReturnEPC-nonempty-frameStack-rule}]}{$x$}
    \State \ApplyFor{Rule~[\nameref{refine-HandleAreturnEPC-empty-frameStack-rule}]}{$x$}
    \State \ApplyFor{Rule~[\nameref{refine-HandleAreturnEPC-nonempty-frameStack-rule}]}{$x$}
    \EndTry
    \label{algorithm-eliminate-returns-try-end}
    \EndFor
    \State \ApplyToFor{Law~[\nameref{copy-rule-law}]}{$MainThread$}{$ExecuteMethod$}
    \label{algorithm-copy-ExecuteMethod-in-MainThread}
    \State \ApplyToFor{Law~[\nameref{copy-rule-law}]}{$Started$}{$ExecuteMethod$}
    \label{algorithm-copy-ExecuteMethod-in-Started}
    \State \ApplyTo{Rule~[\nameref{ExecuteMethod-refinement-rule}]}{$MainThread$}
    \label{algorithm-ExecuteMethod-refinement-MainThread}
    \State \ApplyTo{Rule~[\nameref{ExecuteMethod-refinement-rule}]}{$Started$}
    \label{algorithm-ExecuteMethod-refinement-Started}
    \State \ApplyFor{Law~[\nameref{action-intro-law}]}{$ExecuteMethod$}
    \label{algorithm-remove-ExecuteMethod}
    \State \ApplyFor{Law~[\nameref{action-intro-law}]}{$ExecuteMethod$}
    \label{algorithm-reintroduce-ExecuteMethod}
    \State \ApplyToFor{Law~[\nameref{copy-rule-law}]}{$MainThread$}{$ExecuteMethod$}
    \label{algorithm-copy-ExecuteMethod-out-MainThread}
    \State \ApplyToFor{Law~[\nameref{copy-rule-law}]}{$Started$}{$ExecuteMethod$}
    \label{algorithm-copy-ExecuteMethod-out-Started}
  \end{algorithmic}
  \caption{RemoveLauncherReturns}
  \label{remove-launcher-returns-algorithm}
\end{algorithm}

First, we observe that any method can be made into a form where it has
a single return instruction at the end of the method.
This can be achieved by adding return instructions after infinite
loops using Law~[\nameref{rec-action-intro-law}] and disributing them
outside conditionals using Law~[\nameref{alt-seq-dist-law}].
These laws are applied, if necessary, on
lines~\ref{algorithm-introduce-infinite-loop-returns}
and~\ref{algorithm-distribute-returns} of
Algorithm~\ref{remove-launcher-returns-algorithm}.

When the method has a single return instruction at the end, its
definition is expanded at every point it is called using
Law~[\nameref{copy-rule-law}]. 
The method action is then redefined to exclude the return instruction,
and the sequence of instructions is copied back out.
This is performed on
lines~\ref{algorithm-eliminate-returns-copy-method-in}
to~\ref{algorithm-eliminate-returns-copy-method-out}.

We then introduce assumptions that state whether the $frameStack$ is
empty or not.
These are introduced by extracting an assumption from the state
initialisation schema $InterpreterInit$, in the main action of $ThrCF$
(which has the same form as in $Thr$), stating that the $frameStack$
is empty.
This assumption is then distributed through each action using standard
laws, with most actions not affecting the depth of the $frameStack$,
$InterpreterNewStackFrame$ increasing its depth by one, and the return
instructions decreasing its depth by one.
The result is that the return instructions following the method
actions in $ExecuteMethod$ have an assumption $frameStack = \emptyset$
following them, and the return instructions occuring in the middle of
other methods have an assumption $frameStack \neq \emptyset$.
% This can be seen in
% Figure~\ref{efs-return-assumption-distribution-figure}.
This introduction of assumptions is indicated in
Algorithm~\ref{remove-launcher-returns-algorithm} by the call to an
\Call{IntroduceFrameStackAssumptions}{} procedure on
line~\ref{algorithm-introduce-frameStack-assumptions}.

% \begin{figure}[t!]
%   \centering
%   \setlength{\zedtab}{0.4cm}
%   \setlength{\zedindent}{0pt}
%   \setlength{\zedleftsep}{0pt}
%   \setlength{\abovedisplayskip}{0pt}
%   \setlength{\belowdisplayskip}{0pt}
%   \setlength{\abovedisplayshortskip}{0pt}
%   \setlength{\belowdisplayshortskip}{0pt}
%   \begin{circusaction}
%     ExecuteMethod \circdef \\
%     \t1 \circval classID : ClassID; \circval methodID : MethodID; \circval methodArgs : \seq Word \circspot \\
%     \t1 \circif (classID, methodID) = (TPKClassID, APEHinit) \circthen {} \\
%     \t2 InterpreterNewStackFrame[TPK/class?] \circseq \\
%     \t2 TPK\_APEHinit \circseq HandleReturnEPC \circseq \{ framestack = \emptyset \} \\
%     \t1 {} \circelse (classID, methodID) = (TPKClassID, handleAsyncEvent) \circthen {} \\
%     \t2 InterpreterNewStackFrame[TPK/class?] \circseq \\
%     \t2 TPK\_handleAsyncEvent \circseq HandleReturnEPC \circseq \{ framestack = \emptyset \} \\
%     \t1 {} \circelse (classID, methodID) = (TPKClassID, f) \circthen {} \\
%     \t2 InterpreterNewStackFrame[TPK/class?] \circseq \\
%     \t2 TPK\_f \circseq HandleAreturnEPC \circseq \{ framestack = \emptyset \} \\
%     \t1 {} \cdots {} \\
%     \t1 \circfi
%   \end{circusaction}

%   \begin{circusaction}
%     TPK\_handleAsyncEvent \circdef \\
%     \t1 HandleNewEPC(27) \circseq Poll \circseq HandleDupEPC \circseq Poll \circseq  HandleAconst\_nullEPC \circseq Poll \circseq \\
%     \t1 (\circvar poppedArgs : \seq Word \circspot \\
%     \t2 \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
%     \t2 \lschexpract InterpreterNewStackFrame[\\
%     \t3 ConsoleConnection/class?, CCinit/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq Poll \circseq \\
%     \t1 ConsoleConnection\_CCinit \circseq HandleReturnEPC \circseq \{ frameStack \neq \emptyset \} \circseq Poll \circseq \\
%     %\t1 HandleAstoreEPC(1) \circseq Poll \circseq HandleAloadEPC(1) \circseq \\
%     \t1 {} \cdots {} \\
%     % \t1 Poll \circseq (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
%     % \t1 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[ \\
%     % \t2 ConsoleConnection/class?, openInputStream/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq \\
%     % \t1 Poll \circseq ConsoleConnection\_openInputStream \circseq Poll \circseq  HandleAstoreEPC(2) \circseq Poll \circseq \\
%     % \t1 HandleAloadEPC(1) \circseq Poll \circseq (\circvar poppedArgs : \seq Word \circspot \\
%     % \t1 \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
%     % \t1 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[\\
%     % \t2 ConsoleConnection/class?, openOutputStream/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq \\
%     % \t1 Poll \circseq ConsoleConnection\_openOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq \\
%     %\t1 {} \cdots {} \\
%     % \t1 Poll \circseq HandleIconstEPC(0) \circseq Poll \circseq HandleAstoreEPC(4) \circseq Poll \circseq Poll \circseq \circmu Y \circspot \\
%     % \t2 HandleAloadEPC(4) \circseq Poll \circseq HandleIconstEPC(10) \circseq Poll \circseq \\
%     % \t2 \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
%     % \t2 \circif value1 \leq value2 \circthen \\
%     % \t3 {} \cdots {}  \\
%     % Poll \circseq HandleAloadEPC(2) \circseq Poll \circseq \\
%     % \t3 (\circvar poppedArgs : \seq Word \circspot \\
%     % \t4 \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
%     % \t4 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[ \\
%     % \t5 ConsoleInput/class?, read/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq \\
%     % \t3 Poll \circseq ConsoleInput\_read \circseq Poll \circseq \\
%     \t3 (\circvar poppedArgs : \seq Word \circspot \\
%     \t4 \lschexpract \exists argsToPop? == m @ InterpreterStackFrameInvoke \rschexpract \circseq \\
%     \t4 \lschexpract InterpreterNewStackFrame[\\
%     \t5 TPK/class?, f/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq \\
%     \t3 Poll \circseq TPK\_f \circseq HandleAreturnEPC \circseq \{ frameStack \neq \emptyset \} \circseq Poll \circseq \\
%     % \t3 HandleAstoreEPC(5) \circseq Poll \circseq HandleAloadEPC(5) \circseq \\
%     \t3 {} \cdots {} \\
%     % \t3 Poll \circseq HandleIconstEPC(400) \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
%     % \t3 \circif value1 \leq value2 \circthen HandleAloadEPC(3) \circseq Poll \circseq HandleAloadEPC(5) \circseq Poll \circseq \\
%     % \t4 (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
%     % \t4 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[ \\
%     % \t5 ConsoleOutput/class?, write/methodID?, poppedArgs/methodArgs?] \rschexpract)) \circseq \\
%     % \t4 Poll \circseq ConsoleOutput\_write \\
%     % \t3 {} \circelse value1 > value2 \circthen HandleAloadEPC(3) \circseq Poll \circseq HandleIconstEPC(0) \circseq Poll \circseq \\
%     % \t4 (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
%     % \t4 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[ \\
%     % \t5 ConsoleOutput/class?, write/methodID?, poppedArgs/methodArgs?] \rschexpract)) \circseq \\
%     % \t4 Poll \circseq ConsoleOutput\_write \\
%     % \t3 \circfi \circseq Poll \circseq HandleAloadEPC(4) \circseq Poll \circseq HandleIconstEPC(1) \circseq Poll \circseq HandleIaddEPC \circseq \\
%     \t3 Poll \circseq HandleAstoreEPC(4) \circseq Poll \circseq Y \\
%     \t2 {} \circelse value1 > value2 \circthen \Skip \\
%     \t2 \circfi \circseq Poll
%   \end{circusaction}
%   \caption{The $ExecuteMethod$ and $TPK\_handleAsyncEvent$ actions
%     after introduction of $frameStack$ assumptions}
%   \label{efs-return-assumption-distribution-figure}
% \end{figure}

After assumptions on the state of the $frameStack$ have been
introduced,we can handle the return actions at each point where they
occur, using the rules in the try block at
lines~\ref{algorithm-eliminate-returns-try-begin}
to~\ref{algorithm-eliminate-returns-try-end} of the algorithm.
An example of one of these rules is
Rule~[\nameref{refine-HandleReturnEPC-empty-frameStack-rule}], shown
in Figure~\ref{refine-HandleReturnEPC-empty-frameStack-rule-figure}.
This rule replaces an occurrence of $HandleReturnEPC$ that causes the
$frameStack$ to be empty with a call to the data operation
$InterpreterReturnEPC$ followed by a communication with the $Launcher$
on the $executeMethodRet$ channel.
The value communicated on $executeMethodRet$ is $returnValue$,
introduced in a variable block.
This is essentially expanding the definition of $HandleReturnEPC$ and
resolving the choice over whether $frameStack$ is empty.

\begin{figure}[tp!]
  \begin{restatable}[refine-$HandleReturnEPC$-empty-$frameStack$]{crule}{RefineHandleReturnEPCEmptyFrameStackRule}
  \label{refine-HandleReturnEPC-empty-frameStack-rule}
  \begin{circus}
    \begin{array}{l}
      HandleReturnEPC \circseq \\
      \{ frameStack = \emptyset \}
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circvar returnValue : Word \circspot \\
      \lschexpract InterpreterReturnEPC \rschexpract \circseq \\
      executeMethodRet!thread!returnValue \then \Skip
    \end{array}
  \end{circus}
\end{restatable}
\caption{Rule~[\nameref{refine-HandleReturnEPC-empty-frameStack-rule}]}
\label{refine-HandleReturnEPC-empty-frameStack-rule-figure}
\end{figure}

The other rules in the try block are similar, handling the cases for
the $frameStack$ being left nonempty and the $HandleAreturnEPC$
action.
They can be found in Appendix~\ref{compilation-rules-appendix}.
In the cases when the $frameStack$ is not empty after execution of the
return instruction, the communication on $executeMethodRet$ and the
variable block for $returnValue$ are removed, since they are not used.

After the return instructions have been refined, the $ExecuteMethod$
action contains a choice over method actions that end with a variable
block and communication on $executeMethodRet$.
The variable blocks are expanded to cover the whole of the
$ExecuteMethod$ action, and the communications on $executeMethodRet$
are distributed outside the action.
This is performed by first replacing $ExecuteMethod$ with its
definition, via an application of Law~[\nameref{copy-rule-law}] on
lines~\ref{algorithm-copy-ExecuteMethod-in-MainThread}
and~\ref{algorithm-copy-ExecuteMethod-in-Started}, then applying
Rule~[\nameref{ExecuteMethod-refinement-rule}], shown in
Figure~\ref{ExecuteMethod-refinement-rule-figure}, on
lines~\ref{algorithm-ExecuteMethod-refinement-MainThread}
and~\ref{algorithm-ExecuteMethod-refinement-Started}.

\begin{figure}[thp]
  \begin{restatable}[$ExecuteMethod$-refinement]{crule}{ExecuteMethodRefinementRule}
    \label{ExecuteMethod-refinement-rule}
    If, for all $i$, $returnValue$ is not free in $A_i$, then
    \setlength{\zedindent}{0.5cm}
  \begin{circus}
    \begin{array}{l}
      (\circval classID : ClassID; \\
      \circval methodID : MethodID; \\
      \circval methodArgs : \seq Word \circspot \\
      \circif {(classID, methodID) = (c_1,m_1)} \circthen {} \\
      \t1 A_1 \circseq \circvar returnValue : Word \circspot  B_1 \circseq \\
      \t1 executeMethodRet!thread!returnValue \\
      \t1 {} \then \Skip \\
      {} \cdots {} \\
      {} \circelse (classID, methodID) = (c_n,m_n) \circthen {} \\
      \t1 A_n \circseq \circvar returnValue : Word \circspot B_n \circseq \\
      \t1 executeMethodRet!thread!returnValue \\
      \t1 {} \then \Skip \\
      \circfi)(c, m, a)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circvar retVal : Word \circspot \\
       (\circval classID : ClassID; \\
      \circval methodID : MethodID; \\
      \circval methodArgs : \seq Word; \\
      \circres returnValue : Word \circspot \\
      \circif {(classID, methodID) = (c_1,m_1)} \circthen {} \\
      \t1 A_1 \circseq B_1 \\
      {} \cdots {} \\
      {} \circelse (classID, methodID) = (c_n,m_n) \circthen {} \\
      \t1 A_n \circseq B_n \\
      \circfi)(c, m, a, retVal) \circseq \\
      executeMethodRet!thread!retVal \\
      {} \then \Skip 
    \end{array}
  \end{circus}
\end{restatable}
\caption{Rule~[\nameref{ExecuteMethod-refinement-rule}]}
\label{ExecuteMethod-refinement-rule-figure}
\end{figure}

After Rule~[\nameref{ExecuteMethod-refinement-rule}] has been applied,
$ExecuteMethod$ is redefined to be the actions inside the parametrised
block on the left-hand side of
Rule~[\nameref{ExecuteMethod-refinement-rule}].
This is achieved by using Law~[\nameref{action-intro-law}], on
lines~\ref{algorithm-remove-ExecuteMethod}
and~\ref{algorithm-reintroduce-ExecuteMethod}, to remove the old
definition for $ExecuteMethod$ and introduce the new one.
The actions are then copied back out using the new definition by
application of Law~[\nameref{copy-rule-law}] on
lines~\ref{algorithm-copy-ExecuteMethod-out-MainThread}
and~\ref{algorithm-copy-ExecuteMethod-out-Started}.
For our example, this results in the $ExecuteMethod$, $MainThread$ and
$Started$ actions shown in
Figure~\ref{efs-eliminate-returns-example-figure1}.
The refinement of the return actions in methods causes
$TPK\_handleAsyncEvent$ to have the form shown in
Figure~\ref{efs-eliminate-returns-example-figure1}.

\begin{figure}[tp!]
  \centering
  \setlength{\zedtab}{0.4cm}
  \setlength{\zedindent}{0pt}
  \setlength{\zedleftsep}{0pt}
  \setlength{\abovedisplayskip}{0pt}
  \setlength{\belowdisplayskip}{0pt}
  \setlength{\abovedisplayshortskip}{0pt}
  \setlength{\belowdisplayshortskip}{0pt}
  \begin{circusaction}
    ExecuteMethod \circdef \\
    \t1 \circval classID : ClassID; \circval methodID : MethodID; \circval methodArgs : \seq Word \circspot \\
    \t1 \circres returnValue : Word \circspot \\
    \t1 \circif (classID, methodID) = (TPKClassID, APEHinit) \circthen {} \\
    \t2 InterpreterNewStackFrame[TPK/class?] \circseq TPK\_APEHinit \circseq \\
    \t2 \lschexpract InterpreterReturnEPC \rschexpract  \\
    \t1 {} \circelse (classID, methodID) = (TPKClassID, handleAsyncEvent) \circthen {} \\
    \t2 InterpreterNewStackFrame[TPK/class?] \circseq TPK\_handleAsyncEvent \circseq \\
    \t2 \lschexpract InterpreterReturnEPC \rschexpract \\
    \t1 {} \circelse (classID, methodID) = (TPKClassID, f) \circthen {} \\
    \t2 InterpreterNewStackFrame[TPK/class?] \circseq TPK\_f \circseq \\
    \t2 \lschexpract InterpreterAreturnEPC \rschexpract \\
    \t1 {} \cdots {} \\
    \t1 \circfi
  \end{circusaction}

  \begin{circusaction}
    MainThread \circdef \\
    \t1 setStack?t \prefixcolon (t = thread) ?stack \then frameStackID := Initialised~stack \circseq \circmu X \circspot \\
    \t1 \circblockbegin
    \circvar retVal : Word \circspot
    executeMethod? t \prefixcolon (t = thread)?c?m?a \then {} \\
    \t1 ExecuteMethod(c, m, a, retVal) \circseq
    executeMethodRet!thread!retVal \then Poll \circseq  X \\
    {} \extchoice {} \\
    CEEswitchThread?from?to \prefixcolon (from = thread) \then Blocked \circseq X
    \circblockend
  \end{circusaction}
  
  \begin{circusaction}
    Started \circdef \\
    \t1 \circblockbegin
    \circvar retVal : Word \circspot executeMethod? t \prefixcolon (t = thread)?c?m?a \then {} \\
    \t1 ExecuteMethod(c, m, a, retVal) \circseq executeMethodRet!thread!retVal \then Poll \circseq \\
    \t1 \circblockbegin
    continue?t \prefixcolon (t = thread) \then Started \\
    {} \extchoice {} \\
    endThread?t \prefixcolon (t = thread) \then \Skip
    \circblockend \\
    {} \extchoice {} \\
    CEEswitchThread?from?to \prefixcolon (from = thread) \then Blocked \circseq Started \\
    {} \extchoice {} \\
    endThread?t \prefixcolon (t = thread) \then \Skip
    \circblockend \circseq \\
    \t1 removeThreadMemory!thread \then CEEremoveThread!thread \\
    \t1 {} \then CEEswitchThread?from?to \prefixcolon (from = thread) \then NotStarted
  \end{circusaction}
  \caption{$ExecuteMethod$, $MainThread$ and $Started$ after
    $Launcher$ return elimination}
  \label{efs-eliminate-returns-example-figure1}
\end{figure}

\begin{figure}[tp!]
  \centering
  \setlength{\zedtab}{0.4cm}
  \setlength{\zedindent}{0pt}
  \setlength{\zedleftsep}{0pt}
  \setlength{\abovedisplayskip}{0pt}
  \setlength{\belowdisplayskip}{0pt}
  \setlength{\abovedisplayshortskip}{0pt}
  \setlength{\belowdisplayshortskip}{0pt}
  \begin{circusaction}
    TPK\_handleAsyncEvent \circdef \\
    \t1 HandleNewEPC(27) \circseq Poll \circseq HandleDupEPC \circseq Poll \circseq  HandleAconst\_nullEPC \circseq Poll \circseq \\
    \t1 (\circvar poppedArgs : \seq Word \circspot \\
    \t2 \lschexpract \exists argsToPop? == 2 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    \t2 \lschexpract InterpreterNewStackFrame[\\
    \t3 ConsoleConnection/class?, CCinit/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq Poll \circseq \\
    \t1 ConsoleConnection\_CCinit \circseq \lschexpract InterpreterReturnEPC \rschexpract \circseq Poll \circseq \\
    %\t1 HandleAstoreEPC(1) \circseq Poll \circseq HandleAloadEPC(1) \circseq \\
    \t1 {} \cdots {} \\
    % \t1 Poll \circseq (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    % \t1 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[ \\
    % \t2 ConsoleConnection/class?, openInputStream/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq \\
    % \t1 Poll \circseq ConsoleConnection\_openInputStream \circseq Poll \circseq  HandleAstoreEPC(2) \circseq Poll \circseq \\
    % \t1 HandleAloadEPC(1) \circseq Poll \circseq (\circvar poppedArgs : \seq Word \circspot \\
    % \t1 \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    % \t1 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[\\
    % \t2 ConsoleConnection/class?, openOutputStream/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq \\
    % \t1 Poll \circseq ConsoleConnection\_openOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq \\
    %\t1 {} \cdots {} \\
    % \t1 Poll \circseq HandleIconstEPC(0) \circseq Poll \circseq HandleAstoreEPC(4) \circseq Poll \circseq Poll \circseq \circmu Y \circspot \\
    % \t2 HandleAloadEPC(4) \circseq Poll \circseq HandleIconstEPC(10) \circseq Poll \circseq \\
    % \t2 \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t2 \circif value1 \leq value2 \circthen \\
    % \t3 {} \cdots {}  \\
    % Poll \circseq HandleAloadEPC(2) \circseq Poll \circseq \\
    % \t3 (\circvar poppedArgs : \seq Word \circspot \\
    % \t4 \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    % \t4 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[ \\
    % \t5 ConsoleInput/class?, read/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq \\
    % \t3 Poll \circseq ConsoleInput\_read \circseq Poll \circseq \\
    \t3 (\circvar poppedArgs : \seq Word \circspot \\
    \t4 \lschexpract \exists argsToPop? == 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    \t4 \lschexpract InterpreterNewStackFrame[\\
    \t5 TPK/class?, f/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq \\
    \t3 Poll \circseq TPK\_f \circseq \lschexpract InterpreterAreturn1 \rschexpract \circseq Poll \circseq \\
    % \t3 HandleAstoreEPC(5) \circseq Poll \circseq HandleAloadEPC(5) \circseq \\
    \t3 {} \cdots {} \\
    % \t3 Poll \circseq HandleIconstEPC(400) \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 \circif value1 \leq value2 \circthen HandleAloadEPC(3) \circseq Poll \circseq HandleAloadEPC(5) \circseq Poll \circseq \\
    % \t4 (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    % \t4 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[ \\
    % \t5 ConsoleOutput/class?, write/methodID?, poppedArgs/methodArgs?] \rschexpract)) \circseq \\
    % \t4 Poll \circseq ConsoleOutput\_write \\
    % \t3 {} \circelse value1 > value2 \circthen HandleAloadEPC(3) \circseq Poll \circseq HandleIconstEPC(0) \circseq Poll \circseq \\
    % \t4 (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    % \t4 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[ \\
    % \t5 ConsoleOutput/class?, write/methodID?, poppedArgs/methodArgs?] \rschexpract)) \circseq \\
    % \t4 Poll \circseq ConsoleOutput\_write \\
    % \t3 \circfi \circseq Poll \circseq HandleAloadEPC(4) \circseq Poll \circseq HandleIconstEPC(1) \circseq Poll \circseq HandleIaddEPC \circseq \\
    \t3 Poll \circseq HandleAstoreEPC(4) \circseq Poll \circseq Y \\
    \t2 {} \circelse value1 > value2 \circthen \Skip \\
    \t2 \circfi \circseq Poll 
  \end{circusaction}
  \caption{$TPK\_handleAsyncEvent$ after $Launcher$ return
    elimination}
  \label{efs-eliminate-returns-example-figure2}
\end{figure}

After the $CheckLauncherReturn$ actions have been handled, the process
no longer has any actions that use the whole $frameStack$.
We can therefore refine each method to only operate on a local stack
frame variable.
% However, we must first remove $frameStackID$ and $currentClass$ from
% the state.
% The $frameStackID$ is used in the intepreter model to guard whether
% the $frameStack$ is allowed to be non-empty, but it should not be
% present in the C code.
% Similarly, $currentClass$ is provided as a convenient way of accessing
% the $frameClass$ of the topmost stack frame, but we need direct access
% to the stack frame to perform the refinements in the remainder of this
% stage.
% We thus perform a data refinement on the process to remove them from
% the state.
This is performed as described in
Algorithm~\ref{localise-stack-frames-algorithm}, which defines the
procedure \Call{LocaliseStackFrames}{}.

\begin{algorithm}
  \begin{algorithmic}[1]
    \State \ApplyFor{Law~[\nameref{forwards-data-refinement-law}]}{$InterpreterStateFS$, $FrameStackCI$}
    \label{algorithm-remove-currentClass-data-refinement}
    \State $iterationOrder \gets$ \Call{MethodDependencyOrder}{$methods$}
    \label{algorithm-method-dependency-order-call}
    \For{$m \gets iterationOrder$}
    \label{algorithm-localise-stack-frames-loop}
    \State \ApplyFor{Law~[\nameref{copy-rule-law}]}{$m$}
    \label{algorithm-localise-stack-frames-copy-in}
    \State \ApplyFor{Rule~[\nameref{HandleReturnEPC-stackFrame-introduction-rule}]}{$m$}
    \EndFor
  \end{algorithmic}
  \caption{LocaliseStackFrames}
  \label{localise-stack-frames-algorithm}
\end{algorithm}

Since we must be able to operate directly on the $frameStack$ when
introducing stack frame variables, we first apply a data refinement to
remove $currentClass$ from the state.
We defined $currentClass$ in the model as a convenience when accessing
the $frameClass$ of the topmost stack frame, which is no longer
necessary when we have separate variables for each stack frame.
We also remove $frameStackID$ at this stage, since its only purpose is
to guard whether frameStack is permitted to be non-empty, which holds
from the form of the model.
The data refinement is applied on
line~\ref{algorithm-remove-currentClass-data-refinement} of
Algorithm~\ref{localise-stack-frames-algorithm}, and transforms the
state to $InterpreterStateFS$, shown below, which only contains
$frameStack$.
\begin{schema}{InterpreterStateFS}
  frameStack : StackFrameEPC
\end{schema}

The relationship between $InterpreterStateEPC$ and
$InterpreterStateFS$ is described by the coupling invariant
$FrameStackCI$, shown below.
It ensures $frameStack$ is unaffected by the refinement and replaces
occurrences of $currentClass$ with $(last~frameStack).frameClass$.
The $frameStackID$ is hidden from the new state.
\begin{schema}{FrameStackCI}
  InterpreterStateEPC \\
  InterpreterStateFS_1
\where
  frameStack = frameStack_1 \\
  currentClass = (last~frameStack_1).frameClass
\end{schema}

$FrameStackCI$ describes a functional data refinement, so the new
actions can be calculated in each case.
None of the actions in the process read from $frameStackID$, so it can
be safely hidden and the operations to set the $frameStackID$ are
reduced to $\Skip$.
As mentioned above, $(last~frameStack).frameClass$ is inserted
wherever $currentClass$ occurs in the old actions.
We can then proceed with introducing stack frame variables.

When introducing the variables to represent stack frames, we must
begin with those stack frames at the greatest depth on the stack.
This ensures uses of the $frameStack$ within a nested method do not
interfere with replacing uses of the $frameStack$ in an outer method.
The order in which we introduce stack frame variables to the methods
is specified by a procedure \Call{MethodDependencyOrder}{$methods$},
which constructs a sequence indicating the order in which the method
actions should be handled.
This sequence is constructed by first adding to the sequence any
methods that contain no method calls, then adding any methods that
only call methods already in the sequence, and repeating until all
methods are in the sequence.
Since we do not allow recursion, this will always terminate.
We construct this sequence, $iterationOrder$, on
line~\ref{algorithm-method-dependency-order-call} of
Algorithm~\ref{localise-stack-frames-algorithm}.

We then loop, introducing a stack frame variable for each method in
the order specified by $iterationOrder$, in the for loop on
line~\ref{algorithm-localise-stack-frames-loop}.
Within the for loop, for a method $m$, we expand all occurrences of
$m$ using Law~[\nameref{copy-rule-law}], on
line~{algorithm-localise-stack-frames-copy-in}.
A new variable, $stackFrame$, is then introduced using
Law~[\nameref{HandleReturnEPC-stackFrame-introduction-rule}], shown in
Figure~\ref{HandleReturnEPC-stackFrame-introduction-rule-figure}.

\begin{figure}[thp]
\begin{restatable}[$InterpreterReturn$-$stackFrame$-introduction]{crule}{HandleReturnEPCStackFrameIntroductionRule}
  \label{HandleReturnEPC-stackFrame-introduction-rule}
  %\setlength{\zedtab}{0.4cm}
  %\setlength{\zedindent}{0pt}
  %\setlength{\zedleftsep}{0pt}
  If the actions in $A$ operate solely on $last~frameStack$ and do not
  change the length of $frameStack$, then
  \begin{circus}
    \begin{array}{l}
      InterpreterNewStackFrame[ \\
      \t1 c/class?, \\
      \t1 m/methodID?, \\
      \t1 args/methodArgs?] \circseq \\
      A \circseq \lschexpract InterpreterReturn \rschexpract
    \end{array}
    \circrefines_A
    \begin{array}{l}
      (\circvar stackFrame : StackFrameEPC \circspot \\
      \t1 \lschexpract [stackFrame' : StackFrameEPC | \\
      \t2 args \subseteq stackFrame'.localVariables \land \\
      \t2 \# stackFrame'.localVariables = \ell \land \\
      \t2 stackFrame'.operandStack = \langle\rangle \land \\
      \t2 stackFrame'.frameClass = c \land \\
      \t2 stackFrame'.stackSize = s] \rschexpract \circseq \\
      \t1 A[stackFrame/last~frameStack, \\
      \t2 stackFrame'/last~frameStack'])
    \end{array}
  \end{circus}
  where $\ell = c.methodLocals~m$ and $s = c.methodStackSize~m$.
\end{restatable}
\caption{Rule~[\nameref{HandleReturnEPC-stackFrame-introduction-rule}]}
\label{HandleReturnEPC-stackFrame-introduction-rule-figure}
\end{figure}

Law~[\nameref{HandleReturnEPC-stackFrame-introduction-rule}]
introduces a variable $stackFrame$, of type $StackFrameEPC$, over the
body of a method that ends with an $InterpreterReturn$ operation.
The $stackFrame$ variable is initialised in the same way as for the
stack frame created by $InterpreterNewStackFrame$, and each reference
to $last~frameStack$ in the body of the method is replaced with a
reference to $stackFrame$.
Replacing the references to $last~frameStack$ requires that the size
of $frameStack$ does not change during the method.
However, this requirement is met since method calls are the only
operation that changes the size of $frameStack$ and we replace
references to the $frameStack$ in nested methods first, by the
definition of $iterationOrder$.

In our example, a $stackFrame$ variable will be introduced for
$TPK\_f$ first, since it does not call any other methods.
$TPK\_handleAsyncEvent$ only has its $stackFrame$ variable introduced
after $stackFrame$ variables have been introduced for all methods
called in $TPK\_handleAsyncEvent$.
When the $stackFrame$ variable for $TPK\_handleAsyncEvent$ has been
introduced, it has the form shown in
Figure~\ref{efs-localise-stack-frames-example-figure}.

For brevity, we define new actions, which we refer to as $Handle*SF$
actions.
The $Handle*SF$ actions are similar to the $Handle*EPC$ actions,
except they have every reference to $last~frameStack$ (or
$last~frameStack'$) replaced with a reference to $stackFrame$ (or
$stackFrame'$), and have undergone the data refinement described
above.
We name them by replacing $EPC$ in the names of the $Handle*EPC$
actions with $SF$.
Similarly, we define an $InvokeSF$ operation that performs the
operation of $InterpreterStackFrameInvoke$ over $stackFrame$ instead
of $last~frameStack$.


\begin{figure}[tp!]
  \centering
  \setlength{\zedtab}{0.4cm}
  \setlength{\zedindent}{0pt}
  \setlength{\zedleftsep}{0pt}
  \setlength{\abovedisplayskip}{0pt}
  \setlength{\belowdisplayskip}{0pt}
  \setlength{\abovedisplayshortskip}{0pt}
  \setlength{\belowdisplayshortskip}{0pt}
  \begin{circusaction}
    \t1 \circvar stackFrame : StackFrameEPC \circspot \\
    \t1 \lschexpract [stackFrame' : StackFrameEPC \\
    \t2 poppedArgs? : \seq Word | \\
    \t2 poppedArgs? \subseteq stackFrame'.localVariables \land \\
    \t2 \# stackFrame'.localVariables = 6 \land \\
    \t2 stackFrame'.operandStack = \langle\rangle \land \\
    \t2 stackFrame'.frameClass = TPK \land \\
    \t2 stackFrame'.stackSize = 3] \rschexpract \circseq \\
    \t1 Poll \circseq HandleNewSF(27) \circseq Poll \circseq HandleDupSF \circseq Poll \circseq  HandleAconst\_nullSF \circseq Poll \circseq \\
    % \t1 (\circvar poppedArgs : \seq Word \circspot \\
    % \t2 \lschexpract \exists argsToPop? == m + 1 @ InvokeSF \rschexpract \circseq \\
    % \t2 \lschexpract InterpreterNewStackFrame[\\
    % \t3 ConsoleConnection/class?, CCinit/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq Poll \circseq \\
    % \t1 ConsoleConnection\_CCinit \circseq \lschexpract InterpreterReturnEPC \rschexpract \circseq Poll \circseq \\
    %\t1 HandleAstoreEPC(1) \circseq Poll \circseq HandleAloadEPC(1) \circseq \\
    \t1 {} \cdots {} \\
    % \t1 Poll \circseq (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    % \t1 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[ \\
    % \t2 ConsoleConnection/class?, openInputStream/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq \\
    % \t1 Poll \circseq ConsoleConnection\_openInputStream \circseq Poll \circseq  HandleAstoreEPC(2) \circseq Poll \circseq \\
    % \t1 HandleAloadEPC(1) \circseq Poll \circseq (\circvar poppedArgs : \seq Word \circspot \\
    % \t1 \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    % \t1 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[\\
    % \t2 ConsoleConnection/class?, openOutputStream/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq \\
    % \t1 Poll \circseq ConsoleConnection\_openOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq \\
    %\t1 {} \cdots {} \\
    % \t1 Poll \circseq HandleIconstEPC(0) \circseq Poll \circseq HandleAstoreEPC(4) \circseq Poll \circseq Poll \circseq \circmu Y \circspot \\
    % \t2 HandleAloadEPC(4) \circseq Poll \circseq HandleIconstEPC(10) \circseq Poll \circseq \\
    % \t2 \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t2 \circif value1 \leq value2 \circthen \\
    % \t3 {} \cdots {}  \\
    % Poll \circseq HandleAloadEPC(2) \circseq Poll \circseq \\
    % \t3 (\circvar poppedArgs : \seq Word \circspot \\
    % \t4 \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    % \t4 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[ \\
    % \t5 ConsoleInput/class?, read/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq \\
    % \t3 Poll \circseq ConsoleInput\_read \circseq Poll \circseq \\
    \t3 (\circvar poppedArgs : \seq Word \circspot \\
    \t4 \lschexpract \exists argsToPop? == 1 @ InvokeSF \rschexpract \circseq \\
    \t4 \circvar stackFrame : StackFrameEPC \circspot \\
    \t4 \lschexpract [stackFrame' : StackFrameEPC \\
    \t5 poppedArgs? : \seq Word | \\
    \t5 poppedArgs? \subseteq stackFrame'.localVariables \land \\
    \t5 \# stackFrame'.localVariables = 1 \land \\
    \t5 stackFrame'.operandStack = \langle\rangle \land \\
    \t5 stackFrame'.frameClass = TPK \land \\
    \t5 stackFrame'.stackSize = 2] \rschexpract \circseq \\
    \t4 Poll \circseq \cdots ) \\
    % TPK\_f \circseq \lschexpract InterpreterAreturn1 \rschexpract \circseq Poll \circseq \\
    % \t3 HandleAstoreEPC(5) \circseq Poll \circseq HandleAloadEPC(5) \circseq \\
    \t3 {} \cdots {} \\
    % \t3 Poll \circseq HandleIconstEPC(400) \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 \circif value1 \leq value2 \circthen HandleAloadEPC(3) \circseq Poll \circseq HandleAloadEPC(5) \circseq Poll \circseq \\
    % \t4 (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    % \t4 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[ \\
    % \t5 ConsoleOutput/class?, write/methodID?, poppedArgs/methodArgs?] \rschexpract)) \circseq \\
    % \t4 Poll \circseq ConsoleOutput\_write \\
    % \t3 {} \circelse value1 > value2 \circthen HandleAloadEPC(3) \circseq Poll \circseq HandleIconstEPC(0) \circseq Poll \circseq \\
    % \t4 (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    % \t4 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[ \\
    % \t5 ConsoleOutput/class?, write/methodID?, poppedArgs/methodArgs?] \rschexpract)) \circseq \\
    % \t4 Poll \circseq ConsoleOutput\_write \\
    % \t3 \circfi \circseq Poll \circseq HandleAloadEPC(4) \circseq Poll \circseq HandleIconstEPC(1) \circseq Poll \circseq HandleIaddEPC \circseq \\
    \t3 Poll \circseq HandleAstoreSF(4) \circseq Poll \circseq Y \\
    \t2 {} \circelse value1 > value2 \circthen \Skip \\
    \t2 \circfi \circseq Poll
  \end{circusaction}
  \caption{$TPK\_handleAsyncEvent$ after its $stackFrame$ variable is
    introduced}
  \label{efs-localise-stack-frames-example-figure}
\end{figure}

Following the introduction of local $stackFrame$ variables, we perform
local data refinements to introduce the local variables and stack
slots for each $stackFrame$, on
line~\ref{algorithm-introduce-variables} of
Algorithm~\ref{efs-algorithm}.
This is performed as described in
Algorithm~\ref{introduce-variables-algorithm}, which defines the
\Call{IntroduceVariables}{} procedure.

\begin{algorithm}
  \begin{algorithmic}[1]
    \State \Call{IntroduceFrameClassAssumptions}{}
    \label{algorithm-introduce-frameClass-assumptions}
    \State \Apply{Rule~[\nameref{refine-PutfieldSF-rule}]}
    \label{algorithm-apply-refine-PutfieldSF}
    \State \Apply{Rule~[\nameref{refine-GetfieldSF-rule}]}
    \State \Apply{Rule~[\nameref{refine-PutstaticSF-rule}]}
    \State \Apply{Rule~[\nameref{refine-GetstaticSF-rule}]}
    \State \Apply{Rule~[\nameref{refine-NewSF-rule}]}
    \label{algorithm-apply-refine-NewSF}
    % introduce operand stack assumptions
    \State \Call{IntroduceOperandStackAssumptions}{}
    \label{algorithm-introduce-operandStack-assumptions}
    \For{$m \gets methods$}
    \label{algorithm-introduce-variables-loop}
    \State \ApplyToFor{Law~[\nameref{forwards-data-refinement-law}]}{$m$}{$CI{<}m{>}$}
    \label{algorithm-local-data-refinement}
    \EndFor
    \State \Apply{Rule~[\nameref{eliminate-value1-value2-conditional-rule}]}
    \label{algorithm-apply-eliminate-value1-value2-conditional-rule}
    \State \Apply{Rule~[\nameref{eliminate-oid-getField-rule}]}
    \State \Apply{Rule~[\nameref{eliminate-oid-value-putField-rule}]}
    \State \Apply{Rule~[\nameref{eliminate-value-putStatic-rule}]}
    \label{algorithm-apply-eliminate-value-putStatic-rule}
    \State \Apply{Rule~[\nameref{method-parameter-introduction-rule}]}
    \label{algorithm-method-parameter-introduction}
    \State \Apply{Rule~[\nameref{getClassIDOf-method-parameter-introduction-rule}]}
    \State \Apply{Rule~[\nameref{getClassIDOf-multi-method-parameter-introduction-rule}]}
    \State \Apply{Rule~[\nameref{toplevel-method-parameter-introduction-rule}]}
    \label{algorithm-toplevel-method-parameter-introduction}
    % introduce and copy out method actions
    \For{$m \gets methods$}
    \State \ApplyFor{Law~[\nameref{action-intro-law}]}{$m$}
    \label{algorithm-efs-eliminate-old-method-action}
    \State \ApplyFor{Law~[\nameref{action-intro-law}]}{$m$}
    \State \ApplyFor{Law~[\nameref{copy-rule-law}]}{$m$}
    \label{algorithm-local-variables-copy-method-out}
    \EndFor
  \end{algorithmic}
  \caption{IntroduceVariables}
  \label{introduce-variables-algorithm}
\end{algorithm}

Algorithm~\ref{introduce-variables-algorithm} begins by refining field
access operations to remove their reliance on the $frameClass$
component of the $stackFrame$, which is removed in the data
refinement.
This is done by first introducing and distributing assumptions stating
the value of $frameClass$, indicated by the procedure
\Call{IntroduceFrameClassAssumptions}{} on
line~\ref{algorithm-introduce-frameClass-assumptions}.
This introduces assumptions from the schema actions initialising
$stackFrame$, using Law~[\nameref{schema-assump-intro-law}], and
distributing it using standard refinement laws.
This is straightforward as none of the operations affect the value of
$frameClass$.
We can then apply Rules~[\nameref{refine-PutfieldSF-rule}],
[\nameref{refine-GetfieldSF-rule}],
[\nameref{refine-PutstaticSF-rule}],
[\nameref{refine-GetstaticSF-rule}] and~[\nameref{refine-NewSF-rule}]
wherever possible to refine the field accesses, on
lines~\ref{algorithm-apply-refine-PutfieldSF}
to~\ref{algorithm-apply-refine-NewSF}.

We show Rule~[\nameref{refine-PutfieldSF-rule}] in
Figure~\ref{refine-PutfieldSF-rule-figure}.
It refines a $PutfieldSF(cpi)$ instruction preceded by an assumption
stating the value of the $frameClass$ component of $stackFrame$.
After the application of the rule, the definition of $PutfieldSF$ has
been expanded and the class identifier, $cid$, and field identifier,
$fid$, at the constant pool index $cpi$ are substituted in place of
the accesses to the constant pool.
This removes the reference to the $constantPool$ of the $frameClass$,
and hence the reference to the $frameClass$.
Rule~[\nameref{refine-GetfieldSF-rule}],
Rule~[\nameref{refine-PutstaticSF-rule}],
Rule~[\nameref{refine-GetstaticSF-rule}] and
Rule~[\nameref{refine-NewSF-rule}] are similar so we omit them
here.
They can be found, along with the other compilation rules, in
Appendix~\ref{compilation-rules-appendix}.

\begin{figure}
  \centering
  % \setlength{\zedtab}{0.4cm}
  % \setlength{\zedindent}{0pt}
  % \setlength{\zedleftsep}{0pt}
  % \setlength{\abovedisplayskip}{0pt}
  % \setlength{\belowdisplayskip}{0pt}
  % \setlength{\abovedisplayshortskip}{0pt}
  % \setlength{\belowdisplayshortskip}{0pt}
  \begin{restatable}[refine-$PutfieldSF$]{crule}{RefinePutfieldSFRule}
    \label{refine-PutfieldSF-rule}
    \begin{circus}
      \begin{array}{l}
        \{stackFrame.frameClass = c\} \circseq \\
        PutfieldSF(cpi)
      \end{array}
      \circrefines_A
      \begin{array}{l}
        (\circvar oid : ObjectID; value : Word \circspot \\
        \t1 \lschexpract InterpreterPop[ \\
        \t2 stackFrame/last~frameStack, \\
        \t2 stackFrame'/last~frameStack'] \rschexpract \circseq \\
        \t1 \lschexpract InterpreterPop[ \\
        \t2 oid!/value!, \\
        \t2 stackFrame/last~frameStack, \\
        \t2 stackFrame'/last~frameStack'] \rschexpract \circseq \\
        \t1 putField!oid!cid!fid!value \then \Skip)
      \end{array}
    \end{circus}
    where
    \begin{circus}
      cpi \in fieldRefIndices~c \land \\
      c.constantPool~cpi = FieldRef~(cid, fid)
    \end{circus}
  \end{restatable}
  \caption{Rule~[\nameref{refine-PutfieldSF-rule}]}
  \label{refine-PutfieldSF-rule-figure}
\end{figure}

When refining the $stackFrame$ operations to operations over variables
representing the operand stack, we must know what the size of the
operand stack at each point where the operations occur.
This is necessary to determine which stack slot variables the refined
operations should operate on.
We ensure that this information is available, by introducing and
distributing assumptions on the size of the $operandStack$ component
of $stackFrame$.

An assumption that $operandStack$ is empty can be generated from the
$stackFrame$ initialisation operation (introduced by rules such as
Rule~[\nameref{HandleReturnEPC-stackFrame-introduction-rule}]), using
Law~[\nameref{schema-assump-intro-law}].
This assumption is distributed through each method using standard
algebraic laws, with the size of $operandStack$ updated after each
data operation on $stackFrame$.
Of course, this requires that the size of the $operandStack$ is the
same at the end of a loop as at the beginning of the loop, and also
the same at the end of each branch of a conditional.
These requirements are, however, ensured by bytecode verification so
we are always able to distribute well-defined assumptions about the
$operandStack$ size.
We perform the introduction of $operandStack$ size assumptions in this
way in the procedure \Call{IntroduceOperandStackAssumptions}{}, on
line~\ref{algorithm-introduce-operandStack-assumptions}.

After an $operandStack$ assumption has been introduced before each
data operation, the data operations can be refined to operate over
individual variables representing local variable and operand stack
slots.
This is performed using a local data refinement.
The new state for the data refinement contains the local variables,
which are all of type $Word$, and are named with $var$ followed by an
integer beginning at $1$ and going up to the total number of local
variables for the method, $\ell$.
It also contains operand stack slots, named with $stack$ followed by
an integer from $1$ up to the maximum stack size for the method, $s$.
The coupling invariant for the data refinement of a method $m$ is then
given by the template $CI{<}m{>}$, shown below.

% I don't think this is functional...does that matter?
\begin{schema}{CI{<}m{>}}
  stackFrame : StackFrameEPC \\
  var1, \ldots, var{<}\ell{>} : Word \\
  stack1, \ldots, stack{<}s{>} : Word
\where
  \# stackFrame.localVariables = {<}\ell{>} \\
  stackFrame.localVariables~1 = var1 \\
  \t1 \vdots \\
  stackFrame.localVariables~{<}\ell{>} = var{<}\ell{>} \\
  stackFrame.stackSize = {<}s{>} \\
  \# stackFrame.operandStack \leq {<}s{>} \\
  \# stackFrame.operandStack \geq 1 \implies \\
  \t1 stackFrame.operandStack~1 = stack1 \\
  \t1 \vdots \\
  \# stackFrame.operandStack \geq {<}s{>} \implies \\
  \t1 stackFrame.operandStack~{<}s{>} = stack{<}s{>}
\end{schema}

$CI{<}m{>}$ relates each of the values in the $localVariables$
sequence in $stackFrame$ to the corresponding local variables, $var1$
to $var{<}\ell{>}$.
It also relates each value in $operandStack$ to the corresponding
stack slots, $stack1$ to $stack{<}s{>}$, but only if $operandStack$ is
long enough to contain such a value.
The values of the stack slots outside the length of the $operandStack$
at each point in the program are left nondeterministic, since they are
not used until they have been intialised with the correct value.
This nondeterminism allows us to avoid introducing unnecessary
assignments to initialise the stack slots and return them to a default
value when they are no longer used, which would be required if we
specified a value for unused stack slots in the coupling invariant.

However, the nondeterminism in $CI{<}m{>}$ means that it is not a
function, since there are multiple possible states for the operand
stack slots that correspond to a non-full $operandStack$.
This means that we cannot directly compute the actions resulting from
the refinement (since there are multiple possibilities), so we must
specify how each of the data operations is refined.
We therefore state compilation rules in terms of \Circus{} simulation
between actions, which is the relation that captures an individual
data refinement, with the data refinement itself made up of simulation
of all the actions over the state.

Most of the bytecode instructions at this stage in the strategy have
their semantics stated in terms of a data operation over $stackFrame$,
in the form of a $Handle*SF$ action.
We state the simulations for such instructions as simulations of the
sequential composition of the $Handle*SF$ action with an
$operandStack$ size assumption, which can be viewed as adding an extra
precondition to the action.
An example of such a simulation is
Rule~[\nameref{HandleAloadSF-simulation-rule}], shown in
Figure~\ref{HandleAloadSF-simulation-rule-figure}.
It sates that $HandleAloadSF(lvi)$, with an assumption that the size
of $operandStack$ is $k$, is simulated by an assignment
$stack{<}k+1{>} := var{<}lvi{>}$.
This rule applies, for example, to the $HandleAloadSF(1)$ action
deriving from the $aload~1$ instruction at $pc = 12$ in
$TPK\_handleAsyncEvent$, which is refined to $stack1 := var1$, since
the stack is empty at that point.

\begin{figure}[thp]
  \begin{restatable}[$HandleAloadSF$-simulation]{crule}{HandleAloadSFSimulationRule}
    \label{HandleAloadSF-simulation-rule}
    \begin{circus}
      \begin{array}{l}
        \{\# stackFrame.operandStack = k\} \circseq \\
        HandleAloadSF(lvi)
      \end{array}
      \circsimulates
      \begin{array}{l}
        stack{<}k+1{>} := var{<}lvi{>}
      \end{array}
    \end{circus}
  \end{restatable}
  \caption{Rule~[\nameref{HandleAloadSF-simulation-rule}]}
  \label{HandleAloadSF-simulation-rule-figure}
\end{figure}

The instructions that manipulate objects by communicating with the
object manager have already had their definitions expanded earlier in
this stage.
Their communication with the object manager need not be changed by the
data refinement.
However, the data operations used by these operations to pop or push
the values communicated from or to the operand stack must be refined.
An example of the simulation of such an operation is
Rule~[\nameref{InterpreterPopEPC-simulation-rule}], shown in
Figure~\ref{InterpreterPopEPC-simulation-rule-figure}.
This establishes a simulation between $InterpreterPopEPC$, modified to
act over $stackFrame$, and an assignment of a stack slot value to the
variable $value$, which is in scope in the contexts where
$InterpreterPopEPC$ is used.

\begin{figure}[thp]
  \begin{restatable}[$InterpreterPopEPC$-simulation]{crule}{InterpreterPopEPCSimulationRule}
    \label{InterpreterPopEPC-simulation-rule}
    \begin{circus}
      \begin{array}{l}
        \{\# stackFrame.operandStack = k\} \circseq \\
        \lschexpract InterpreterPopEPC[ \\
        \t1 stackFrame/last~frameStack, \\
        \t1 stackFrame'/last~frameStack']\rschexpract
      \end{array}
      \circsimulates
      \begin{array}{l}
        value := stack{<}k{>}
      \end{array}
    \end{circus}
  \end{restatable}
  \caption{Rule~[\nameref{InterpreterPopEPC-simulation-rule}]}
  \label{InterpreterPopEPC-simulation-rule-figure}
\end{figure}

Method invocations also use data operations to pop the method's
arguments from the stack and pass them to the method, which must be
refined in the data refinement.
The $InvokeSF$ operation, which pops the method's arguments from the
stack, is simulated by an assignment of a sequence of operand stack
values to the $poppedArgs$ variables, as stated in
Rule~[\nameref{InvokeSF-simulation-rule}], shown in
Figure~\ref{InvokeSF-simulation-rule-figure}.

\begin{figure}[thp]
  \begin{restatable}[$InvokeSF$-simulation]{crule}{InvokeSFSimulationRule}
    \label{InvokeSF-simulation-rule}
    \begin{circus}
      \begin{array}{l}
        \{\# stackFrame.operandStack = k\} \circseq \\
        \lschexpract \exists argsToPop? == m @ InvokeSF \rschexpract
      \end{array}
      \circsimulates
      \begin{array}{l}
        poppedArgs := \\
        \t1 \langle stack{<}k-m+1{>}, \ldots , stack{<}k{>} \rangle
      \end{array}
    \end{circus}
  \end{restatable}
  \caption{Rule~[\nameref{InvokeSF-simulation-rule}]}
  \label{InvokeSF-simulation-rule-figure}
\end{figure}

The passing of the arguments to the invoked method has already been
refined in the introduction of the $stackFrame$ variable, but the
schema initialising $stackFrame$ must be further refined to initialise
the local variables.
The simulation of the $stackFrame$ intialisation schema is stated by
Rule~[\nameref{stackFrame-init-simulation-rule}], shown in
Figure~\ref{stackFrame-init-simulation-rule-figure}.
It is simulated by a sequence of assignments setting the local
variables to the values of the arguments.
The initialisation sets $operandStack$ to be empty, so there is no
need to assign values to the stack slot variables; they can be left
arbitrary.

\begin{figure}[thp]
  \begin{restatable}[$stackFrame$-init-simulation]{crule}{StackFrameInitSimulationRule}
    \label{stackFrame-init-simulation-rule}
    \begin{circus}
      \begin{array}{l}
        \lschexpract [stackFrame' : StackFrameEPC | \\
        \t1 args \subseteq stackFrame'.localVariables \land \\
        \t1 \# stackFrame'.localVariables = \ell \land \\
        \t1 stackFrame'.operandStack = \langle\rangle \land \\
        \t1 stackFrame'.frameClass = c \land \\
        \t1 stackFrame'.stackSize = s] \rschexpract
      \end{array}
      \circsimulates
      \begin{array}{l}
        var{<}1{>} := args~1 \circseq \\
        \t1 \vdots \\
        var{<}\# args{>} := args~(\# args)
      \end{array}
    \end{circus}
  \end{restatable}
  \caption{Rule~[\nameref{stackFrame-init-simulation-rule}]}
  \label{stackFrame-init-simulation-rule-figure}
\end{figure}

The simulation rules we have omitted here can be found with the rest
of the compilation rules in Appendix~\ref{compilation-rules-appendix}.
These, together with the standard laws for distributing simulations
through \Circus{} constructs, are sufficient to unambiguously define
the local data refinement to be applied to each method.
We apply this data refinement on
line~\ref{algorithm-local-data-refinement}, inside a for loop in which
we iterate over each method.
Unlike the introduction of the $stackFrame$ variables, the order in
which the methods are iterated over does not matter in this case,
since each has its own $stackFrame$ variable that undergoes local
refinement.

After the data refinement of each method, we can eliminate the
additional variables used in the data operations that pop values from
the stack.
Those that push values to the stack are pushing values received from a
channel, which require a separate assignment operation and so cannot
be eliminated.
The additional variables are eliminated using the rules applied on
lines~\ref{algorithm-apply-eliminate-value1-value2-conditional-rule}
to~\ref{algorithm-apply-eliminate-value-putStatic-rule}.
In particular,
Rule~[\nameref{eliminate-value1-value2-conditional-rule}], shown in
Figure~\ref{eliminate-value1-value2-conditional-rule-figure}, applies
to the $TPK\_handleAsyncEvent$ action in our example.
It removes the need for additional $value1$ and $value2$ variables,
replacing the references to them in the conditional with the stack
slot variables whose values they store.

\begin{figure}
  \begin{restatable}[eliminate-$value1$-$value2$-conditional]{crule}{EliminateValueOneValueTwoConditional}
    \label{eliminate-value1-value2-conditional-rule}
    \begin{circus}
      \begin{array}{l}
        (\circvar value1, value2 : Word \circspot \\
        \t1 value1 := stack{<}k{>} \circseq \\
        \t1 value2 := stack{<}k+1{>} \circseq \\
        \t1 \circif value1 \leq value2 \circthen {} \\
        \t2 {} \cdots {} \\
        \t1 {} \circelse value1 > value2 \circthen {} \\
        \t2 {} \cdots {} \\
        \t1 \circfi)
      \end{array}
      \circrefines_A
      \begin{array}{l}
        \circif stack{<}k{>} \leq stack{<}k+1{>} \circthen {} \\
        \t1 {} \cdots {} \\
        {} \circelse stack{<}k{>} > stack{<}k+1{>} \circthen {} \\
        \t1 {} \cdots {} \\
        \circfi)
      \end{array}
    \end{circus}
  \end{restatable}
  \caption{Rule~[\nameref{eliminate-value1-value2-conditional-rule}]}
  \label{eliminate-value1-value2-conditional-rule-figure}
\end{figure}

We can then split the sequence of instructions for each method back
out into a separate action.
This happens inside a separate for loop, since all the method data
refinements must be completed before the methods can be separated out.
To do this, we must first convert the values passed into the method
into parameters, by applying
Rule~[\nameref{method-parameter-introduction-rule}], show in
Figure~\ref{method-parameter-introduction-rule-figure}.
This rule eliminates the $poppedArgs$ variable and transforms the
arguments passed via it into value parameters.
There are similar rules to handle the cases of virtual methods, where
there is an additional $getClassIDOf$
communication:~Rule~[\nameref{getClassIDOf-method-parameter-introduction-rule}]
and
Rule~[\nameref{getClassIDOf-multi-method-parameter-introduction-rule}].
We also provide
Rule~[\nameref{toplevel-method-parameter-introduction-rule}] to handle
the introduction of parameters to the method actions in
$ExecuteMethod$, where the arguments are not popped from the stack but
obtained from the parameter to $ExecuteMethod$.
These rules are applied, where necessary, on
lines~\ref{algorithm-method-parameter-introduction}
to~\ref{algorithm-toplevel-method-parameter-introduction} of
Algorithm~\ref{introduce-variables-algorithm}.

\begin{figure}[thp]
  \begin{restatable}[method-parameter-introduction]{crule}{MethodParameterIntroductionRule}
    \label{method-parameter-introduction-rule}
    \begin{circus}
      \begin{array}{l}
        (\circvar poppedArgs : \seq Word \circspot \\
        poppedArgs := \langle arg_1, \ldots, arg_n \rangle \circseq \\
        (\circvar var1, \ldots, var{<}\ell{>} : Word \circspot \\
        \circvar stack1, \ldots, stack{<}s{>} : Word \circspot \\
        var1 := poppedArgs~1 \circseq \\
        \t1 \vdots \\
        var{<}n{>} := poppedArgs~1 \circseq \\
        \t1 {} \cdots {})) \\
        % Remember: Poll starts the \cdots
      \end{array}
      \circrefines_A
      \begin{array}{l}
        (\circval var1, \ldots, var{<}n{>} : Word \circspot \\
        \circvar var{<}n+1{>}, \ldots, var{<}\ell{>}) : Word \circspot \\
        \circvar stack1, \ldots, stack{<}s{>} : Word \circspot \\
        \t1 {} \cdots {})(arg_1, \ldots, arg_n) \\
      \end{array}
    \end{circus}
  \end{restatable}
  \caption{Rule~[\nameref{method-parameter-introduction-rule}]}
  \label{method-parameter-introduction-rule-figure}
\end{figure}

After these transformations of the methods have been completed, the
sequence of actions that forms each method is the sequence of actions
within the newly introduced parametrised block, which is the same at
each place where the method occurs.
We thus eliminate the method's old action via an application of
Law~[\nameref{action-intro-law}] and introduce a new action via a
second application of Law~[\nameref{action-intro-law}].
The new action is the sequence of actions in the parametrised block
that forms the body of the method.
The method is then replaced with a reference to the new action at each
placed where it occurs, using Law~[\nameref{copy-rule-law}].
These steps occur on
lines~\ref{algorithm-efs-eliminate-old-method-action}
to~\ref{algorithm-local-variables-copy-method-out}, inside a for loop
that iterates over each method.

When the variables have been introduced to our example, the
$TPK\_handleAsyncEvent$ action has the form shown in
Figure~\ref{efs-localise-stack-frames-example-figure}.
This code is fairly close to the corresponding C code, and we show the
whole method, with each statement on a separate line, to emphasise
that.
Note that there are still communications with the object manager to
determine the class of an object, even when the object's class is not
used because it can be determined uniquely.
Eliminating such communications requires a wider view of the model
that includes the object manager, so we defer it until the next stage
of the compilation strategy.

\begin{figure}[tp!]
  \centering
  \setlength{\zedtab}{0.5cm}
  \setlength{\zedindent}{0pt}
  \setlength{\zedleftsep}{0pt}
  \setlength{\abovedisplayskip}{0pt}
  \setlength{\belowdisplayskip}{0pt}
  \setlength{\abovedisplayshortskip}{0pt}
  \setlength{\belowdisplayshortskip}{0pt}
  \begin{circusaction}
    TPK\_handleAsyncEvent \circdef \circval var1 : Word \circspot \\
    \t1 \circvar var2, var3, var4, var5, var6 : Word \circspot \\
    \t1 \circvar stack1, stack2, stack3 : Word \circspot Poll \circseq \\
    \t1 newObject!thread!ConsoleConnectionClassID \\
    \t2 {} \then newObjectRet!oid \then stack1 := oid \circseq Poll \circseq \\
    \t1 stack2 := stack1 \circseq Poll \circseq \\
    \t1 stack3 := null \circseq Poll \circseq \\
    \t1 ConsoleConnection\_CCinit(stack2, stack3) \circseq Poll \circseq \\
    \t1 var1 := stack1 \circseq Poll \circseq \\
    \t1 stack1 := var1 \circseq Poll \circseq \\
    \t1 getClassIDOf!stack1?cid \\
    \t2 {} \then ConsoleConnection\_openInputStream(stack1, stack1) \circseq Poll \circseq \\
    \t1 var2 := stack1 \circseq Poll \circseq \\
    \t1 stack1 := var1 \circseq Poll \circseq \\
    \t1 getClassIDOf!stack1?cid \\
    \t2 {} \then ConsoleConnection\_openOutputStream(stack1, stack1) \circseq Poll \circseq \\
    \t1 var3 := stack1 \circseq Poll \circseq \\
    \t1 stack1 := 0 \circseq Poll \circseq \\
    \t1 var4 := stack1 \circseq Poll \circseq Poll \circseq \\
    \t1 \circmu Y \circspot \\
    \t2 stack1 := var4 \circseq Poll \circseq \\
    \t2 stack2 := 10 \circseq Poll \circseq \\
    \t2 \circif stack1 \leq stack2 \circthen Poll \circseq \\
    \t3 stack1 := var2 \circseq Poll \circseq \\
    \t3 getClassIDOf!stack1?cid \\
    \t4 {} \then ConsoleInput\_read(stack1, stack1) \circseq Poll \circseq \\
    \t3 TPK\_f(stack1, stack1) \circseq Poll \circseq \\
    \t3 var5 := stack1 \circseq Poll \circseq \\
    \t3 stack1 := var5 \circseq Poll \circseq \\
    \t3 stack2 := 400 \circseq Poll \circseq \\
    \t3 \circif stack1 \leq stack2 \circthen Poll \circseq \\
    \t4 stack1 := var3 \circseq Poll \circseq \\
    \t4 stack2 := var5 \circseq Poll \circseq \\
    \t4 getClassIDOf!stack1?cid \\
    \t5 {} \then ConsoleOutput\_write(stack1, stack2) \\
    \t3 {} \circelse stack1 > stack2 \circthen Poll \circseq \\
    \t4 stack1 := var3 \circseq Poll \circseq \\
    \t4 stack2 := 0 \circseq Poll \circseq \\
    \t4 getClassIDOf!stack1?cid \\
    \t5 {} \then ConsoleOutput\_write(stack1, stack2) \\
    \t3 \circfi \circseq Poll \circseq \\
    \t3 stack1 := var4 \circseq Poll \circseq \\
    \t3 stack2 := 1 \circseq Poll \circseq \\
    \t3 stack1 := stack1 + stack2 \circseq Poll \circseq \\
    \t3 var4 := stack1 \circseq Poll \circseq Y \\
    \t2 {} \circelse stack1 > stack2 \circthen \Skip \\
    \t2 \circfi \circseq Poll
  \end{circusaction}
  \caption{$TPK\_handleAsyncEvent$ after its variables have been introduced}
  \label{efs-introduce-variables-example-figure}
\end{figure}

After this, all actions have been refined to use individual variables
and the $frameStack$ is no longer used.
We can thus eliminate the $frameStack$ from the state. 
This is performed as described in
Algorithm~\ref{remove-frameStack-from-state-algorithm}, which defines
the \Call{RemoveFrameStackFromState}{} procedure.

\begin{algorithm}
  \begin{algorithmic}
    \State \ApplyFor{Law~[\nameref{forwards-data-refinement-law}]}{$[]$, $FrameStackEliminationCI$}
    \label{algorithm-remove-frameStack-data-refinement}
    \State \ApplyFor{Law~[\nameref{process-param-elim-law}]}{$cs$}
    \label{algorithm-cs-elimination}
  \end{algorithmic}
  \caption{RemoveFrameStackFromState}
  \label{remove-frameStack-from-state-algorithm}
\end{algorithm}

First, on line~\ref{algorithm-remove-frameStack-data-refinement}, we
perform a data refinement to remove the $frameStack$ from the state.
The new state after the data refinement is the empty schema, and the
coupling invariant, $FrameStackEliminationCI$, maps all $frameStack$
values onto the empty state.
Since $frameStack$ is no longer used in the process, the only action
affected is the state initialisation, which becomes $Skip$.
After this, on line~\ref{algorithm-cs-elimination}, we eliminate the
$cs$ parameter from the process, since it is no longer used.
The result is the process $ThrLV_{bc,cs}(t)$, mentioned in
Theorem~\ref{efs-thm}.
The only thing remaining to be done is to refine the representation of
objects, which is performed in the next stage of the strategy.

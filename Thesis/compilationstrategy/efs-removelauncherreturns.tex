After the elimination of program counter stage, each conditional
branch in a method ends with a return instruction or an infinite loop.
This can be seen in
Figure~\ref{pc-elimination-HandleAsyncEvent-example-figure}, presented
earlier, where $TPK\_handleAsyncEvent$ ends with a $HandleReturnEPC$
action.
In the first step of this stage, at
line~\ref{algorithm-remove-launcher-returns} of
Algorithm~\ref{efs-algorithm}, such actions are moved outside the
method and their definitions are expanded so that their communication
with the $Launcher$ can be handled.
This is performed as described in
Algorithm~\ref{remove-launcher-returns-algorithm}, which defines the
procedure \Call{RemoveLauncherReturns}{}.
\begin{algorithm}[ht]
  \begin{algorithmic}[1]
    \For{$methodName \gets $ \Call{MethodActionNames}{$cs$}}
    \label{algorithm-method-single-return-loop}
    \State $methodBody \gets$ \Call{ActionBody}{$methodName$}
    \State $returnAction \gets$ \Call{ReturnAction}{$methodBody$}
    \label{algorithm-determine-return-action}
    \State \ExhaustivelyApplyToFor{Law~[\nameref{rec-action-intro-law}]}{$methodBody$}{$returnAction$}
    \label{algorithm-introduce-infinite-loop-returns}
    \State \ExhaustivelyApplyTo{Law~[\nameref{alt-seq-dist-law}]}{$methodBody$}
    \label{algorithm-distribute-returns}
    \State \ExhaustivelyApplyFor{Law~[\nameref{copy-rule-law}]}{$methodName$}
    \label{algorithm-eliminate-returns-copy-method-in}
    \State \ApplyReverseFor{Law~[\nameref{action-intro-law}]}{$methodName$, $methodBody$}
    \label{algorithm-remove-returns-eliminate-method-action}
    \Match{$methodBody$}{($A \circseq returnAction$)}
    \State \ApplyFor{Law~[\nameref{action-intro-law}]}{$methodName$, $A$}
    \label{algorithm-remove-returns-introduce-method-action}
    \State \ExhaustivelyApplyReverseFor{Law~[\nameref{copy-rule-law}]}{$methodName$}
    \label{algorithm-eliminate-returns-copy-method-out}
    \EndFor
    \State \Call{IntroduceFrameStackAssumptions}{}
    \label{algorithm-introduce-frameStack-assumptions}
    \State \ExhaustivelyApply{Rule~[\nameref{refine-HandleReturnEPC-empty-frameStack-rule}]}
    \label{algorithm-eliminate-returns-try-begin}
    \State \ExhaustivelyApply{Rule~[\nameref{refine-HandleReturnEPC-nonempty-frameStack-rule}]}
    \State \ExhaustivelyApply{Rule~[\nameref{refine-HandleAreturnEPC-empty-frameStack-rule}]}
    \State \ExhaustivelyApply{Rule~[\nameref{refine-HandleAreturnEPC-nonempty-frameStack-rule}]}
    \label{algorithm-eliminate-returns-try-end}
    \State \ApplyToFor{Law~[\nameref{copy-rule-law}]}{\Call{ActionBody}{$MainThread$}}{$ExecuteMethod$}
    \label{algorithm-copy-ExecuteMethod-in-MainThread}
    \State \ApplyToFor{Law~[\nameref{copy-rule-law}]}{\Call{ActionBody}{$Started$}}{$ExecuteMethod$}
    \label{algorithm-copy-ExecuteMethod-in-Started}
    \State \ApplyTo{Rule~[\nameref{ExecuteMethod-refinement-rule}]}{\Call{ActionBody}{$MainThread$}}
    \label{algorithm-ExecuteMethod-refinement-MainThread}
    \State \ApplyTo{Rule~[\nameref{ExecuteMethod-refinement-rule}]}{\Call{ActionBody}{$Started$}}
    \label{algorithm-ExecuteMethod-refinement-Started}
    \State \ApplyReverseFor{Law~[\nameref{action-intro-law}]}{$ExecuteMethod$, \Call{ActionBody}{$ExecuteMethod$}}
    \label{algorithm-remove-ExecuteMethod}
    \MatchIn{$\begin{array}[t]{l}(\circvar retVal : Word \circspot (A)(c, m, a, retVal) \circseq \\\t1 executeMethodRet!thread!retVal \then \Skip)\end{array}$}{\Call{ActionBody}{Started}}
  \State \ApplyFor{Law~[\nameref{action-intro-law}]}{$ExecuteMethod$, $A$}
    \label{algorithm-reintroduce-ExecuteMethod}
    \State \ApplyReverseToFor{Law~[\nameref{copy-rule-law}]}{$MainThread$}{$ExecuteMethod$}
    \label{algorithm-copy-ExecuteMethod-out-MainThread}
    \State \ApplyReverseToFor{Law~[\nameref{copy-rule-law}]}{$Started$}{$ExecuteMethod$}
    \label{algorithm-copy-ExecuteMethod-out-Started}
  \end{algorithmic}
  \caption{RemoveLauncherReturns}
  \label{remove-launcher-returns-algorithm}
\end{algorithm}

Algorithm~\ref{remove-launcher-returns-algorithm} begins by iterating
over each of the method actions, in the for loop beginning on
line~\ref{algorithm-method-single-return-loop}.
This determines the name, $methodName$, for each method's action from
the class information, $cs$, via a function
\Call{MethodActionNames}{}.
We take the method's body, $methodBody$, as the body of the action
corresponding to $methodName$.

The return actions that may occur at the end of method branches are
either $HandleAreturnEPC$ or $HandleReturnEPC$.
$HandleAreturnEPC$ only occurs in methods that return a value and,
conversely, $HandleReturnEPC$ only occurs in methods that do not
return a value.
We can thus determine which return action a method uses by examining
the syntax of $methodBody$ to see which action occurs at the end of
the branches.
A method in which all branches end in infinite loops is treated as
using the return action $HandleReturnEPC$, since it does not produce a
value.
We determine the return action type, $returnAction$, for $methodBody$
on line~\ref{algorithm-determine-return-action}, using a syntactic
function \Call{ReturnAction}.

Having determined the return action for a method, we convert the
method to a form in which it has one occurence of that action at the
end of its body.
This is achieved by introducing occurrences of $returnAction$ after
infinite loops in $methodBody$ using
Law~[\nameref{rec-action-intro-law}] and distributing occurences of
$returnAction$ outside conditionals using
Law~[\nameref{alt-seq-dist-law}].
These laws are applied on
lines~\ref{algorithm-introduce-infinite-loop-returns}
and~\ref{algorithm-distribute-returns} of
Algorithm~\ref{remove-launcher-returns-algorithm}.

When the method has a single return instruction at the end, its
definition is expanded at every point it is referenced using
Law~[\nameref{copy-rule-law}] on
line~\ref{algorithm-eliminate-returns-copy-method-in}. 
We then redefine the method action by eliminating it on
line~\ref{algorithm-remove-returns-eliminate-method-action} and
reintroducing it with a new definition that excludes the return action
at the end of the method.
This is performed using Law~[\nameref{action-intro-law}], on
lines~\ref{algorithm-remove-returns-eliminate-method-action}
to~\ref{algorithm-remove-returns-introduce-method-action}.
Law~[\nameref{copy-rule-law}] is then used to copy out the method into
its action using the new definition, on
line~\ref{algorithm-eliminate-returns-copy-method-out}.

We then introduce assumptions that state whether the $frameStack$ is
empty or not.
These are introduced by extracting an assumption from the state
initialisation schema $InterpreterInit$, in the main action of $ThrCF$
(which has the same form as in $Thr$), stating that the $frameStack$
is empty.
This assumption is then distributed through each action using standard
laws, with most actions not affecting the depth of the $frameStack$,
$InterpreterNewStackFrame$ increasing its depth by one, and the return
instructions decreasing its depth by one.
The result is that the return instructions following the method
actions in $ExecuteMethod$ have an assumption $frameStack = \emptyset$
following them, and the return instructions occuring in the middle of
other methods have an assumption $frameStack \neq \emptyset$.
% This can be seen in
% Figure~\ref{efs-return-assumption-distribution-figure}.
This introduction of assumptions is indicated in
Algorithm~\ref{remove-launcher-returns-algorithm} by the call to an
\Call{IntroduceFrameStackAssumptions}{} procedure on
line~\ref{algorithm-introduce-frameStack-assumptions}.

% \begin{figure}[t!]
%   \centering
%   \setlength{\zedtab}{0.4cm}
%   \setlength{\zedindent}{0pt}
%   \setlength{\zedleftsep}{0pt}
%   \setlength{\abovedisplayskip}{0pt}
%   \setlength{\belowdisplayskip}{0pt}
%   \setlength{\abovedisplayshortskip}{0pt}
%   \setlength{\belowdisplayshortskip}{0pt}
%   \begin{circusaction}
%     ExecuteMethod \circdef \\
%     \t1 \circval classID : ClassID; \circval methodID : MethodID; \circval methodArgs : \seq Word \circspot \\
%     \t1 \circif (classID, methodID) = (TPKClassID, APEHinit) \circthen {} \\
%     \t2 InterpreterNewStackFrame[TPK/class?] \circseq \\
%     \t2 TPK\_APEHinit \circseq HandleReturnEPC \circseq \{ framestack = \emptyset \} \\
%     \t1 {} \circelse (classID, methodID) = (TPKClassID, handleAsyncEvent) \circthen {} \\
%     \t2 InterpreterNewStackFrame[TPK/class?] \circseq \\
%     \t2 TPK\_handleAsyncEvent \circseq HandleReturnEPC \circseq \{ framestack = \emptyset \} \\
%     \t1 {} \circelse (classID, methodID) = (TPKClassID, f) \circthen {} \\
%     \t2 InterpreterNewStackFrame[TPK/class?] \circseq \\
%     \t2 TPK\_f \circseq HandleAreturnEPC \circseq \{ framestack = \emptyset \} \\
%     \t1 {} \cdots {} \\
%     \t1 \circfi
%   \end{circusaction}

%   \begin{circusaction}
%     TPK\_handleAsyncEvent \circdef \\
%     \t1 HandleNewEPC(27) \circseq Poll \circseq HandleDupEPC \circseq Poll \circseq  HandleAconst\_nullEPC \circseq Poll \circseq \\
%     \t1 (\circvar poppedArgs : \seq Word \circspot \\
%     \t2 \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
%     \t2 \lschexpract InterpreterNewStackFrame[\\
%     \t3 ConsoleConnection/class?, CCinit/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq Poll \circseq \\
%     \t1 ConsoleConnection\_CCinit \circseq HandleReturnEPC \circseq \{ frameStack \neq \emptyset \} \circseq Poll \circseq \\
%     %\t1 HandleAstoreEPC(1) \circseq Poll \circseq HandleAloadEPC(1) \circseq \\
%     \t1 {} \cdots {} \\
%     % \t1 Poll \circseq (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
%     % \t1 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[ \\
%     % \t2 ConsoleConnection/class?, openInputStream/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq \\
%     % \t1 Poll \circseq ConsoleConnection\_openInputStream \circseq Poll \circseq  HandleAstoreEPC(2) \circseq Poll \circseq \\
%     % \t1 HandleAloadEPC(1) \circseq Poll \circseq (\circvar poppedArgs : \seq Word \circspot \\
%     % \t1 \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
%     % \t1 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[\\
%     % \t2 ConsoleConnection/class?, openOutputStream/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq \\
%     % \t1 Poll \circseq ConsoleConnection\_openOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq \\
%     %\t1 {} \cdots {} \\
%     % \t1 Poll \circseq HandleIconstEPC(0) \circseq Poll \circseq HandleAstoreEPC(4) \circseq Poll \circseq Poll \circseq \circmu Y \circspot \\
%     % \t2 HandleAloadEPC(4) \circseq Poll \circseq HandleIconstEPC(10) \circseq Poll \circseq \\
%     % \t2 \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
%     % \t2 \circif value1 \leq value2 \circthen \\
%     % \t3 {} \cdots {}  \\
%     % Poll \circseq HandleAloadEPC(2) \circseq Poll \circseq \\
%     % \t3 (\circvar poppedArgs : \seq Word \circspot \\
%     % \t4 \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
%     % \t4 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[ \\
%     % \t5 ConsoleInput/class?, read/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq \\
%     % \t3 Poll \circseq ConsoleInput\_read \circseq Poll \circseq \\
%     \t3 (\circvar poppedArgs : \seq Word \circspot \\
%     \t4 \lschexpract \exists argsToPop? == m @ InterpreterStackFrameInvoke \rschexpract \circseq \\
%     \t4 \lschexpract InterpreterNewStackFrame[\\
%     \t5 TPK/class?, f/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq \\
%     \t3 Poll \circseq TPK\_f \circseq HandleAreturnEPC \circseq \{ frameStack \neq \emptyset \} \circseq Poll \circseq \\
%     % \t3 HandleAstoreEPC(5) \circseq Poll \circseq HandleAloadEPC(5) \circseq \\
%     \t3 {} \cdots {} \\
%     % \t3 Poll \circseq HandleIconstEPC(400) \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
%     % \t3 \circif value1 \leq value2 \circthen HandleAloadEPC(3) \circseq Poll \circseq HandleAloadEPC(5) \circseq Poll \circseq \\
%     % \t4 (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
%     % \t4 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[ \\
%     % \t5 ConsoleOutput/class?, write/methodID?, poppedArgs/methodArgs?] \rschexpract)) \circseq \\
%     % \t4 Poll \circseq ConsoleOutput\_write \\
%     % \t3 {} \circelse value1 > value2 \circthen HandleAloadEPC(3) \circseq Poll \circseq HandleIconstEPC(0) \circseq Poll \circseq \\
%     % \t4 (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
%     % \t4 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[ \\
%     % \t5 ConsoleOutput/class?, write/methodID?, poppedArgs/methodArgs?] \rschexpract)) \circseq \\
%     % \t4 Poll \circseq ConsoleOutput\_write \\
%     % \t3 \circfi \circseq Poll \circseq HandleAloadEPC(4) \circseq Poll \circseq HandleIconstEPC(1) \circseq Poll \circseq HandleIaddEPC \circseq \\
%     \t3 Poll \circseq HandleAstoreEPC(4) \circseq Poll \circseq Y \\
%     \t2 {} \circelse value1 > value2 \circthen \Skip \\
%     \t2 \circfi \circseq Poll
%   \end{circusaction}
%   \caption{The $ExecuteMethod$ and $TPK\_handleAsyncEvent$ actions
%     after introduction of $frameStack$ assumptions}
%   \label{efs-return-assumption-distribution-figure}
% \end{figure}

After assumptions on the state of the $frameStack$ have been
introduced,we can handle the return actions at each point where they
occur, applying the rules on
lines~\ref{algorithm-eliminate-returns-try-begin}
to~\ref{algorithm-eliminate-returns-try-end} of the algorithm wherever
possible.
An example of one of these rules is
Rule~[\nameref{refine-HandleReturnEPC-empty-frameStack-rule}], shown
in Figure~\ref{refine-HandleReturnEPC-empty-frameStack-rule-figure}.
This rule replaces an occurrence of $HandleReturnEPC$ that causes the
$frameStack$ to be empty with a call to the data operation
$InterpreterReturnEPC$ followed by a communication with the $Launcher$
on the $executeMethodRet$ channel.
The value communicated on $executeMethodRet$ is $returnValue$,
introduced in a variable block.
This essentially expands the definition of $HandleReturnEPC$ and
resolves the choice over whether $frameStack$ is empty.

\begin{figure}[tp!]
  \begin{restatable}[refine-$HandleReturnEPC$-empty-$frameStack$]{crule}{RefineHandleReturnEPCEmptyFrameStackRule}
  \label{refine-HandleReturnEPC-empty-frameStack-rule}
  \begin{circus}
    \begin{array}{l}
      HandleReturnEPC \circseq \\
      \{ frameStack = \emptyset \}
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circvar returnValue : Word \circspot \\
      \lschexpract InterpreterReturnEPC \rschexpract \circseq \\
      executeMethodRet!thread!returnValue \then \Skip
    \end{array}
  \end{circus}
\end{restatable}
\caption{Rule~[\nameref{refine-HandleReturnEPC-empty-frameStack-rule}]}
\label{refine-HandleReturnEPC-empty-frameStack-rule-figure}
\end{figure}

The other rules in the try block are similar, handling the cases for
the $frameStack$ being left nonempty and the $HandleAreturnEPC$
action.
They can be found in Appendix~\ref{compilation-rules-appendix}.
In the cases when the $frameStack$ is not empty after execution of the
return instruction, which occurs when a method is called from within
another method, the communication on $executeMethodRet$ and the
variable block for $returnValue$ are removed, since they are not used.

After the return instructions have been refined, the $ExecuteMethod$
action contains a choice over method actions that end with a variable
block and communication on $executeMethodRet$.
The variable blocks are expanded to cover the whole of the
$ExecuteMethod$ action, and the communications on $executeMethodRet$
are distributed outside the action.
This is performed by first replacing $ExecuteMethod$ with its
definition, via an application of Law~[\nameref{copy-rule-law}] on
lines~\ref{algorithm-copy-ExecuteMethod-in-MainThread}
and~\ref{algorithm-copy-ExecuteMethod-in-Started}, then applying
Rule~[\nameref{ExecuteMethod-refinement-rule}], shown in
Figure~\ref{ExecuteMethod-refinement-rule-figure}, on
lines~\ref{algorithm-ExecuteMethod-refinement-MainThread}
and~\ref{algorithm-ExecuteMethod-refinement-Started}.

\begin{figure}[thp]
  \begin{restatable}[$ExecuteMethod$-refinement]{crule}{ExecuteMethodRefinementRule}
    \label{ExecuteMethod-refinement-rule}
    If, for all $i$, $returnValue$ is not free in $A_i$, then
    \setlength{\zedindent}{0.5cm}
  \begin{circus}
    \begin{array}{l}
      (\circval classID : ClassID; \\
      \circval methodID : MethodID; \\
      \circval methodArgs : \seq Word \circspot \\
      \circif {(classID, methodID) = (c_1,m_1)} \circthen {} \\
      \t1 A_1 \circseq \circvar returnValue : Word \circspot  B_1 \circseq \\
      \t1 executeMethodRet!thread!returnValue \\
      \t1 {} \then \Skip \\
      {} \cdots {} \\
      {} \circelse (classID, methodID) = (c_n,m_n) \circthen {} \\
      \t1 A_n \circseq \circvar returnValue : Word \circspot B_n \circseq \\
      \t1 executeMethodRet!thread!returnValue \\
      \t1 {} \then \Skip \\
      \circfi)(c, m, a)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circvar retVal : Word \circspot \\
       (\circval classID : ClassID; \\
      \circval methodID : MethodID; \\
      \circval methodArgs : \seq Word; \\
      \circres returnValue : Word \circspot \\
      \circif {(classID, methodID) = (c_1,m_1)} \circthen {} \\
      \t1 A_1 \circseq B_1 \\
      {} \cdots {} \\
      {} \circelse (classID, methodID) = (c_n,m_n) \circthen {} \\
      \t1 A_n \circseq B_n \\
      \circfi)(c, m, a, retVal) \circseq \\
      executeMethodRet!thread!retVal \\
      {} \then \Skip 
    \end{array}
  \end{circus}
\end{restatable}
\caption{Rule~[\nameref{ExecuteMethod-refinement-rule}]}
\label{ExecuteMethod-refinement-rule-figure}
\end{figure}

After Rule~[\nameref{ExecuteMethod-refinement-rule}] has been applied,
$ExecuteMethod$ is redefined as the actions inside the parametrised
block on the left-hand side of
Rule~[\nameref{ExecuteMethod-refinement-rule}].
This is performed using Law~[\nameref{action-intro-law}] on
lines~\ref{algorithm-remove-ExecuteMethod}
to~\ref{algorithm-reintroduce-ExecuteMethod}, eliminating the existing
definition of $ExecuteMethod$ and introducing a new definition.
The actions are then copied back out using the new definition by
application of Law~[\nameref{copy-rule-law}] on
lines~\ref{algorithm-copy-ExecuteMethod-out-MainThread}
and~\ref{algorithm-copy-ExecuteMethod-out-Started}.
For our example, this results in the $ExecuteMethod$, $MainThread$ and
$Started$ actions shown in
Figure~\ref{efs-eliminate-returns-example-figure1}.
The refinement of the return actions in methods causes
$TPK\_handleAsyncEvent$ to have the form shown in
Figure~\ref{efs-eliminate-returns-example-figure1}.

\begin{figure}[tp!]
  \centering
  \setlength{\zedtab}{0.4cm}
  \setlength{\zedindent}{0pt}
  \setlength{\zedleftsep}{0pt}
  \setlength{\abovedisplayskip}{0pt}
  \setlength{\belowdisplayskip}{0pt}
  \setlength{\abovedisplayshortskip}{0pt}
  \setlength{\belowdisplayshortskip}{0pt}
  \begin{circusaction}
    ExecuteMethod \circdef \\
    \t1 \circval classID : ClassID; \circval methodID : MethodID; \circval methodArgs : \seq Word \circspot \\
    \t1 \circres returnValue : Word \circspot \\
    \t1 \circif (classID, methodID) = (TPKClassID, APEHinit) \circthen {} \\
    \t2 InterpreterNewStackFrame[TPK/class?] \circseq TPK\_APEHinit \circseq \\
    \t2 \lschexpract InterpreterReturnEPC \rschexpract  \\
    \t1 {} \circelse (classID, methodID) = (TPKClassID, handleAsyncEvent) \circthen {} \\
    \t2 InterpreterNewStackFrame[TPK/class?] \circseq TPK\_handleAsyncEvent \circseq \\
    \t2 \lschexpract InterpreterReturnEPC \rschexpract \\
    \t1 {} \circelse (classID, methodID) = (TPKClassID, f) \circthen {} \\
    \t2 InterpreterNewStackFrame[TPK/class?] \circseq TPK\_f \circseq \\
    \t2 \lschexpract InterpreterAreturnEPC \rschexpract \\
    \t1 {} \cdots {} \\
    \t1 \circfi
  \end{circusaction}

  \begin{circusaction}
    MainThread \circdef \\
    \t1 setStack?t \prefixcolon (t = thread) ?stack \then frameStackID := Initialised~stack \circseq \circmu X \circspot \\
    \t1 \circblockbegin
    \circvar retVal : Word \circspot
    executeMethod? t \prefixcolon (t = thread)?c?m?a \then {} \\
    \t1 ExecuteMethod(c, m, a, retVal) \circseq
    executeMethodRet!thread!retVal \then Poll \circseq  X \\
    {} \extchoice {} \\
    CEEswitchThread?from?to \prefixcolon (from = thread) \then Blocked \circseq X
    \circblockend
  \end{circusaction}
  
  \begin{circusaction}
    Started \circdef \\
    \t1 \circblockbegin
    \circvar retVal : Word \circspot executeMethod? t \prefixcolon (t = thread)?c?m?a \then {} \\
    \t1 ExecuteMethod(c, m, a, retVal) \circseq executeMethodRet!thread!retVal \then Poll \circseq \\
    \t1 \circblockbegin
    continue?t \prefixcolon (t = thread) \then Started \\
    {} \extchoice {} \\
    endThread?t \prefixcolon (t = thread) \then \Skip
    \circblockend \\
    {} \extchoice {} \\
    CEEswitchThread?from?to \prefixcolon (from = thread) \then Blocked \circseq Started \\
    {} \extchoice {} \\
    endThread?t \prefixcolon (t = thread) \then \Skip
    \circblockend \circseq \\
    \t1 removeThreadMemory!thread \then CEEremoveThread!thread \\
    \t1 {} \then CEEswitchThread?from?to \prefixcolon (from = thread) \then NotStarted
  \end{circusaction}
  \caption{$ExecuteMethod$, $MainThread$ and $Started$ after
    $Launcher$ return elimination}
  \label{efs-eliminate-returns-example-figure1}
\end{figure}

\begin{figure}[tp!]
  \centering
  \setlength{\zedtab}{0.4cm}
  \setlength{\zedindent}{0pt}
  \setlength{\zedleftsep}{0pt}
  \setlength{\abovedisplayskip}{0pt}
  \setlength{\belowdisplayskip}{0pt}
  \setlength{\abovedisplayshortskip}{0pt}
  \setlength{\belowdisplayshortskip}{0pt}
  \begin{circusaction}
    TPK\_handleAsyncEvent \circdef \\
    \t1 HandleNewEPC(27) \circseq Poll \circseq HandleDupEPC \circseq Poll \circseq  HandleAconst\_nullEPC \circseq Poll \circseq \\
    \t1 (\circvar poppedArgs : \seq Word \circspot \\
    \t2 \lschexpract \exists argsToPop? == 2 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    \t2 \lschexpract InterpreterNewStackFrame[\\
    \t3 ConsoleConnection/class?, CCinit/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq Poll \circseq \\
    \t1 ConsoleConnection\_CCinit \circseq \lschexpract InterpreterReturnEPC \rschexpract \circseq Poll \circseq \\
    %\t1 HandleAstoreEPC(1) \circseq Poll \circseq HandleAloadEPC(1) \circseq \\
    \t1 {} \cdots {} \\
    % \t1 Poll \circseq (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    % \t1 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[ \\
    % \t2 ConsoleConnection/class?, openInputStream/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq \\
    % \t1 Poll \circseq ConsoleConnection\_openInputStream \circseq Poll \circseq  HandleAstoreEPC(2) \circseq Poll \circseq \\
    % \t1 HandleAloadEPC(1) \circseq Poll \circseq (\circvar poppedArgs : \seq Word \circspot \\
    % \t1 \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    % \t1 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[\\
    % \t2 ConsoleConnection/class?, openOutputStream/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq \\
    % \t1 Poll \circseq ConsoleConnection\_openOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq \\
    %\t1 {} \cdots {} \\
    % \t1 Poll \circseq HandleIconstEPC(0) \circseq Poll \circseq HandleAstoreEPC(4) \circseq Poll \circseq Poll \circseq \circmu Y \circspot \\
    % \t2 HandleAloadEPC(4) \circseq Poll \circseq HandleIconstEPC(10) \circseq Poll \circseq \\
    % \t2 \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t2 \circif value1 \leq value2 \circthen \\
    % \t3 {} \cdots {}  \\
    % Poll \circseq HandleAloadEPC(2) \circseq Poll \circseq \\
    % \t3 (\circvar poppedArgs : \seq Word \circspot \\
    % \t4 \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    % \t4 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[ \\
    % \t5 ConsoleInput/class?, read/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq \\
    % \t3 Poll \circseq ConsoleInput\_read \circseq Poll \circseq \\
    \t3 (\circvar poppedArgs : \seq Word \circspot \\
    \t4 \lschexpract \exists argsToPop? == 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    \t4 \lschexpract InterpreterNewStackFrame[\\
    \t5 TPK/class?, f/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq \\
    \t3 Poll \circseq TPK\_f \circseq \lschexpract InterpreterAreturn1 \rschexpract \circseq Poll \circseq \\
    % \t3 HandleAstoreEPC(5) \circseq Poll \circseq HandleAloadEPC(5) \circseq \\
    \t3 {} \cdots {} \\
    % \t3 Poll \circseq HandleIconstEPC(400) \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 \circif value1 \leq value2 \circthen HandleAloadEPC(3) \circseq Poll \circseq HandleAloadEPC(5) \circseq Poll \circseq \\
    % \t4 (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    % \t4 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[ \\
    % \t5 ConsoleOutput/class?, write/methodID?, poppedArgs/methodArgs?] \rschexpract)) \circseq \\
    % \t4 Poll \circseq ConsoleOutput\_write \\
    % \t3 {} \circelse value1 > value2 \circthen HandleAloadEPC(3) \circseq Poll \circseq HandleIconstEPC(0) \circseq Poll \circseq \\
    % \t4 (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    % \t4 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[ \\
    % \t5 ConsoleOutput/class?, write/methodID?, poppedArgs/methodArgs?] \rschexpract)) \circseq \\
    % \t4 Poll \circseq ConsoleOutput\_write \\
    % \t3 \circfi \circseq Poll \circseq HandleAloadEPC(4) \circseq Poll \circseq HandleIconstEPC(1) \circseq Poll \circseq HandleIaddEPC \circseq \\
    \t3 Poll \circseq HandleAstoreEPC(4) \circseq Poll \circseq Y \\
    \t2 {} \circelse value1 > value2 \circthen \Skip \\
    \t2 \circfi \circseq Poll 
  \end{circusaction}
  \caption{$TPK\_handleAsyncEvent$ after $Launcher$ return
    elimination}
  \label{efs-eliminate-returns-example-figure2}
\end{figure}
When a method is complete, calls to that method can then be resolved.
This is performed after introduction of loops and conditionals,
ensuring methods with loops and conditionals are complete so that this
step can be applied.
% As mentioned previously, since this requires all the method calls in a
% given method to be resolved first, we do not allow recursion.

This step begins with the copying of the method into a separate
action, so that it can be referenced elsewhere.
This is performed by as described by
Algorithm~\ref{separate-complete-methods-algorithm}.
\begin{algorithm}
  \begin{algorithmic}[1]
    \For{$m \gets methods$} \label{algorithm-method-separation-loop}
    \If{\Call{MethodIsComplete}{$m$}} \label{algorithm-check-method-completeness}
    \State \ApplyFor{Rule~[\nameref{introduce-class-information-rule}]}{$m$}
    \label{algorithm-introduce-class-information}
    \State \ApplyFor{Law~[\nameref{action-intro-law}]}{$m$} \label{algorithm-introduce-method-action}
    \State \ApplyFor{Law~[\nameref{copy-rule-law}]}{$m$} \label{algorithm-copy-method-action}
    \EndIf
    \EndFor
  \end{algorithmic}
  \caption{SeparateCompleteMethods}
  \label{separate-complete-methods-algorithm}
\end{algorithm}

Algorithm~\ref{separate-complete-methods-algorithm} looks at each
method separately, as specified by the loop on
line~\ref{algorithm-method-separation-loop}, and determines if it is
complete, on line~\ref{algorithm-check-method-completeness}.
This involves a simple syntactic check that each conditional branch
ends in a return instruction or a recursion.

If a method is complete, we first introduce an assumption at the start
of the sequence of actions for the method that establishes what the
value of $currentClass$ is during the method's execution.
This ensures that the information can be used during the
\emph{Elimination of Frame Stack} stage of the compilation, since it
cannot be determined from the $pc$ value during that stage.
The introduction of the assumption is performed by an application of
Rule~[\nameref{introduce-class-information-rule}], shown below, on
line~\ref{algorithm-introduce-class-information}.
This determines the $currentClass$ by finding the class information
$c$ in the range of $cs$ that contains a method $m$ with the same
entry point, $i$, as the complete method being operated on.
\begin{restatable}[introduce-class-information]{crule}{IntroduceClassInformationRule}
  \label{introduce-class-information-rule}
  Given $i : ProgramAddress$,
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen \{currentClass = c\} \circseq A \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
  \end{circus}
  where $c : Class$ is such that
  \begin{displaymath}
    c \in \ran cs \land \exists  m : MethodID | m \in \dom c.methodEntry @ c.methodEntry~m = i.
  \end{displaymath}
\end{restatable}

For the methods that are complete, the sequence of actions for the
method are placed in a separate action, which is introduced using
Law~[\nameref{action-intro-law}] on
line~\ref{algorithm-introduce-method-action}.
We form the name of this action from the name of the class to which
the method belongs and the name of the method, concatenated together
with an underscore.
The name used for the action does not have an effect upon the
correctness of the strategy, provided it is unique.
Once the method action has been introduced, the sequence of actions at
the method's entry point in the $Running$ action is replaced with a
reference to the newly introduced action by applying
Law~[\nameref{copy-rule-law}] on
line~\ref{algorithm-copy-method-action}.

In our example, the method \texttt{f()} of the \texttt{TPK} class,
which starts at $pc = 43$, is complete on the first iteration of the
loop on line~\ref{algorithm-method-loop} of
Algorithm~\ref{epc-algorithm}.
This can be seen in
Figure~\ref{forward-sequence-introduction-example-figure}.
The method is complete in this case because it consists of a straight
sequence of instructions ending with $HandleAreturnEPC$, which
represents the \texttt{areturn} instruction.
The sequence of instructions at $pc = 43$ is copied into the action $TPK\_f$,
which can be seen in
Figure~\ref{method-call-resolution-example-figure}.
The $pc = 43$ branch is replaced with a call to $TPK\_f$.

After all the complete methods have been copied into separate actions,
calls to those methods are resolved.
This is performed as described by
Algorithm~\ref{resolve-method-calls-algorithm}.
In this algorithm, while we indicate the parameters supplied to a rule
with the word \textbf{for}, as in previous algorithms, we use the word
\textbf{to} to indicate which part of the $Running$ action the rule is
applied to.
\begin{algorithm}[th]
  \begin{algorithmic}[1]
    \For{$m \gets methods$}
    \label{algorithm-mci-method-loop} 
    \For{$mc \gets$ \Call{UnresolvedMethodsCalls}{$m$}}
    \label{algorithm-mci-method-call-loop}
    \If{\Call{IsResolvable}{$mc$}}
    \label{algorithm-is-resolvable-check}
    \If{\Call{HasSingleTarget}{$mc$}}
    \label{algorithm-multiple-targets-check}
    \Try
    \label{algorithm-try-block-begin}
    \State \ApplyTo{Rule~[\nameref{refine-invokespecial-rule}]}{$mc$}
    \State \ApplyTo{Rule~[\nameref{refine-invokestatic-rule}]}{$mc$}
    \State \ApplyTo{Rule~[\nameref{refine-invokevirtual-single-rule}]}{$mc$}
    \EndTry
    \Try
    \label{algorithm-try-block2-start}
    \State \ApplyTo{Rule~[\nameref{resolve-special-method-rule}]}{$mc$}
    \State \ApplyTo{Rule~[\nameref{resolve-special-method-virtual-rule}]}{$mc$}
    \State \ApplyFor{Rule~[\nameref{resolve-normal-method-rule}]}{$mc$}
    \State \ApplyFor{Rule~[\nameref{resolve-normal-method-virtual-rule}]}{$mc$}
    \EndTry
    \Else
    \State \ApplyTo{Rule~[\nameref{refine-invokevirtual-multi-rule}]}{$mc$}
    \label{algorithm-refine-invokevirtual-multi}
    \For{$target \gets $\Call{Targets}{$mc$}}
    \label{algorithm-targets-loop}
    \Try
    \State \ApplyToFor{Rule~[\nameref{resolve-special-method-branch-rule}]}{$mc$}{$target$}
    \State \ApplyFor{Rule~[\nameref{resolve-normal-method-branch-rule}]}{$mc$, $target$}
    \EndTry
    \EndFor
    \State \ApplyFor{Law~[\nameref{alt-seq-dist-law}]}{$mc$}
    \label{algorithm-move-pc-assignments}
    \EndIf
    \If{\Call{HasSimpleSequence}{$node$}}
    \label{algorithm-mci-sequence-introduction-start}
    \State \ApplyFor{Rule~[\nameref{sequence-introduction-rule}]}{$node$}
    \EndIf
    \label{algorithm-mci-sequence-introduction-end}
    \EndIf
    \EndFor
    \EndFor
  \end{algorithmic}
  \caption{ResolveMethodCalls}
  \label{resolve-method-calls-algorithm}
\end{algorithm}

The algorithm begins by checking each unresolved method call in each
method, as specified by the loops on
lines~\ref{algorithm-mci-method-loop}
and~\ref{algorithm-mci-method-call-loop}.
The list of unresolved method calls for a given method, $m$, is
computed by \Call{UnresolvedMethodsCalls}{$m$}, which finds the $pc$
values for which the sequence of instructions ends with a method
invocation instruction with no $pc$ assignment following it.
An example of an unresolved method call can be seen in the $pc = 14$
branch of Figure~\ref{forward-sequence-introduction-example-figure},
reproduced in part below.
\begin{circusaction}
  \t2 {} \cdots {} \\
  \t2 {} \circelse pc = 14 \circthen \cdots \circseq pc := 16 \circseq Poll \circseq HandleInvokevirtualEPC(36) \\
  \t2 {} \cdots {}
\end{circusaction}
This ends with the action $HandleInvokeVirtualEPC(36)$, which handles
the \texttt{invokevirtual} instruction for the constant pool index
$36$.
It is unresolved because it does not have any $pc$ assignment or other
actions following it.

For each method call that needs resolving, we check if it can be
resolved at this point in the compilation strategy.
This is performed on line~\ref{algorithm-is-resolvable-check}, where
the boolean value \Call{IsResolvable}{$mc$} is checked.
\Call{IsResolvable}{$mc$} is true if all the targets of the method
call $mc$ are either special methods or non-special methods that are
already complete and have been separated into their own actions (as
described in Algorithm~\ref{separate-complete-methods-algorithm}).

If the method call is resolvable, then we check whether there is a
single target for the method call or multiple targets.
Calls to a single target can be transformed to a simple reference to
the corresponding method action.
Calls with multiple targets are transformed into a choice over the
behaviours for each of the possible targets.
The check of the number of targets is performed on
line~\ref{algorithm-multiple-targets-check} of
Algorithm~\ref{resolve-method-calls-algorithm}.
This checks the condition \Call{HasSingleTarget}{$mc$}, which is true
if the instruction to be handled is \texttt{invokespecial} or
\texttt{invokestatic}, or an \texttt{invokevirtual} instruction
referencing a class with no subclasses (other than itself).
It is false otherwise, that is, if the instruction is
\texttt{invokevirtual} and there are multiple subclasses of the class
referenced by the instruction.

For method calls with a single target, we replace the action that
handles the method invocation instruction with an action that pops the
arguments for the method from the stack and handles invocation of the
specific method referenced by the instruction.
This is handled slightly differently for each of the method invocation
instructions in our bytecode subset, so we have three rules for
performing this transformation, one for each
instruction:~Rule~[\nameref{refine-invokestatic-rule}],
Rule~[\nameref{refine-invokespecial-rule}] and
Rule~[\nameref{refine-invokevirtual-single-rule}].
These rules are applied in a try block, beginning on
line~\ref{algorithm-try-block-begin}, which tries to apply each rule in
turn, stopping when one succeeds.

Below, we show Rule~[\nameref{refine-invokestatic-rule}], which
handles \texttt{invokestatic} instructions.
This rule, as with other rules in this section, is applied to an
action beginning with an assumption on the value of $pc$.
This allows it to be applied at the start of a branch of the choice in
$Running$, introducing the assumption using
Law~[\nameref{alt-assump-intro-law}], or after a sequential
composition, introducing the assumption using
Law~[\nameref{assign-assump-intro-law}] and distributing it over
$Poll$ using Lemma~\ref{Poll-assumption-distribution-lemma}.
After the application of the rule, the assumption can be eliminated
using Law~[\nameref{assump-elim-law}] and
Law~[\nameref{seq-unitl-law}].
For brevity, we omit the application of these laws from the algorithm,
and we understand that assumptions are introduced at the points
required for the rules to be applied.
Rule~[\nameref{refine-invokestatic-rule}] refines the
$HandleInvokeStaticEPC(cpi)$ to an action that pops the method's
arguments from the stack using the $InterpreterStackFrameInvoke$
operation and then behaves as the $Invoke$ action described in
Section~\ref{cee-interpreter-section}, for the class and method
referenced by $cpi$.
\begin{restatable}[refine-invokestatic]{crule}{RefineInvokestaticRule}
  \label{refine-invokestatic-rule}
  \setlength{\zedindent}{0.25cm}
  \begin{circus}
    \begin{array}{l}
      \{ pc = i \} \circseq HandleInvokestaticEPC(cpi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ pc = i \} \circseq \circvar poppedArgs : \seq Word \circspot \\
      \t1 \lschexpract \exists argsToPop? == methodArguments~m @ \\
      \t2 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t1 Invoke(c, m, poppedArgs, \true)
    \end{array}
  \end{circus}
  where $m : MethodID$ and $c : ClassID$ are such that
  \begin{displaymath}
    \exists c_0 : Class | c_0 \in \ran cs @ \\
    \t1 (\exists m_0 : MethodID | m_0 \in \dom c_0.methodEntry @ i \in c_0.methodEntry~m_0 \upto c_0.methodEnd~m_0) \\
    \t1 cpi \in methodRefIndices~c_0 \land c_0.constantPool~cpi = MethodRef~(c,m).
  \end{displaymath}
\end{restatable}
The identifiers of the class, $c$, and method, $m$, referenced by
$cpi$ are determined by first finding the class information, $c_0$,for
the current class.
The $c_0$ information is obtained from the $pc$ value, $i$, when the
method invocation instruction is executed by finding $Class$
information in the range of $cs$ that contains a method with $j$
between its entry point and end.
If $cpi$ is the index of a $MethodRef$ in the $constantPool$ of $c_0$,
then the class identifier, $c$ and method identifier, $m$, of the
method to be invoked are those given in the $MethodRef$.
The are passed to $Invoke$, along with the arguments popped from the
stack, $poppedArgs$, and a boolean value indicating whether the method
call is static, which is $\true$ in the case of \texttt{invokestatic}.

Rule~[\nameref{refine-invokespecial-rule}] and
Rule~[\nameref{refine-invokevirtual-single-rule}] are similar to
Rule~[\nameref{refine-invokestatic-rule}], but they produce slightly
different sequences of actions due to the differences in the semantics
of the method invocation instructions, described in
Section~\ref{cee-interpreter-subsection}.
They provide for popping an additional \texttt{this} argument from the
stack and pass a $\false$ boolean value to $Invoke$.
Rule~[\nameref{refine-invokevirtual-single-rule}] also leaves a
communication on the $getClassIDOf$ channel in place.
The communication is eliminated later in the strategy, during the
\emph{Data Refinement of Objects} stage, described in
Section~\ref{data-refinement-of-objects-section}.

After the action that handles the method invocation instruction has
been transformed, the method invocation is resolved by transforming
the $Invoke$ action to the behaviour of the method being invoked.
A $pc$ assignment is also introduced after the method's behaviour so
that it can be sequentially composed with the instructions after the
method call.
There are four rules for this in the case of method calls with a
single target, applied in another try block on
line~\ref{algorithm-try-block2-start}:~Rule~[\nameref{resolve-special-method-rule}]
and Rule~[\nameref{resolve-special-method-virtual-rule}], which
handles resolution of special methods, and
Rule~[\nameref{resolve-normal-method-rule}] and
Rule~[\nameref{resolve-normal-method-virtual-rule}], which handle
resolution of non-special methods.

Rule~[\nameref{resolve-special-method-rule}], shown below, operates by
simply replacing the $Invoke$ action with the behaviour for the
special method and moving a $pc$ assignment after the methods
behaviour.
This collapses the choice in the definition of the $Invoke$ action.
The behaviour of the special method is represented by the syntactic
function $specialMethodAction$, which is defined by
Table~\ref{special-method-action-table}.
It determines which behaviour should be used based on the class and
method identifiers passed to $Invoke$ and the boolean value indicating
whether the method is static.
\begin{restatable}[resolve-special-method]{crule}{ResolveSpecialMethodRule}
  \label{resolve-special-method-rule}
  If $c$, $m$ and $static$ match one of the rows of
  Table~\ref{special-method-action-table}, then
  \setlength{\zedindent}{0.25cm} \setlength{\zedtab}{0.5cm}
  \begin{circus}
    \begin{array}{l}
      \{ pc = i \} \circseq \circvar poppedArgs : \seq Word \circspot \\
      \lschexpract \exists argsToPop? == e @ \\
      \t1 InterpreterStackFrameInvoke \rschexpract \circseq \\
      Invoke(c, m, poppedArgs, static)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ pc = i \} \circseq \circvar poppedArgs : \seq Word \circspot \\
      \lschexpract \exists argsToPop? == e @ \\
      \t1 InterpreterStackFrameInvoke \rschexpract \circseq \\
      specialMethodAction(c, m, static) \circseq \\
      pc := i + 1
    \end{array}
  \end{circus}
  where $specialMethodAction$ is the syntactic function defined by
  Table~\ref{special-method-action-table}.
\end{restatable}
Rule~[\nameref{resolve-special-method-virtual-rule}] is similar to
Rule~[\nameref{resolve-special-method-rule}], but handles the extra
communication on $getClassIDOf$ in the case of an
\texttt{invokevirtual} instruction.

\begin{table}
  \centering
  \setlength{\abovedisplayskip}{-5pt}
  \setlength{\belowdisplayskip}{-10pt}
  \setlength{\abovedisplayshortskip}{0pt}
  \setlength{\belowdisplayshortskip}{0pt}
  \setlength{\zedindent}{-0.1cm}
  \setlength{\zedleftsep}{0cm}
  \renewcommand{\arraystretch}{1}
  \rowcolors{1}{white}{lightgray}
  \begin{tabular}{p{6.5cm}p{7.7cm}}
    \hline
    Conditions on $c$, $m$ and $static$ & $specialMethodAction(c, m, static)$ \\
    \hline
    \begin{circus}
      (c,resumeThreadClass) \in subclassRel~cs \\
      \land m = resumeThreadID \\
      \land static = \true
    \end{circus} &
                   \begin{circus}
                     resumeThread!(WordToThreadID~(methodArgs~1)) \\
                     \t1 {} \then resumeThreadRet \then \Skip
                   \end{circus}\\
    \begin{circus}
      (c,suspendClass) \in subclassRel~cs \\
      \land m = suspendID \\
      \land static = \true
    \end{circus} &
                   \begin{circus}
                     suspend \then suspendRet \then \Skip
                   \end{circus}\\
    \begin{circus}
      (c,writeClass) \in subclassRel~cs \\
      \land m = writeID \\
      \land static = \true
    \end{circus} &
                   \begin{circus}
                     output!(methodArgs~1) \then \Skip
                   \end{circus}\\
    \begin{circus}
      (c,readClass) \in subclassRel~cs \\
      \land m = readID \\
      \land static = \true
    \end{circus} &
                   \begin{circus}
                     input?value \then \lschexpract InterpreterPush \hide (pc,pc') \rschexpract
                   \end{circus}\\
    \begin{circus}
      (c,managedSchedulableClass) \\
      \t1 {} \in subclassRel~cs \\
      \land m = registerID \\
      \land static = \false
    \end{circus} &
                   \begin{circus}
                     register!thread!(head~methodArgs) \\
                     \t1 {} \then registerRet \then \Skip
                   \end{circus}\\
    \begin{circus}
      (c,managedMemoryClass) \in subclassRel~cs \\
      \land m = enterPrivateMemoryHelperID \\
      \land static = \true
    \end{circus} &
                   \begin{circus}
                     enterPrivateMemory!thread!(methodArgs~1) \\
                     \t1 {} \then enterPrivateMemoryRet \then \Skip 
                   \end{circus}\\
    \begin{circus}
      (c,managedMemoryClass) \in subclassRel~cs \\
      \land m = executeInAreaOfHelperID \\
      \land static = \true
    \end{circus} &
                   \begin{circus}
                     executeInAreaOf!thread!(methodArgs~1) \\
                     \t1 {} \then executeInAreaOfRet \then \Skip
                   \end{circus}\\
    \begin{circus}
      (c,managedMemoryClass) \in subclassRel~cs \\
      \land m = executeInOuterAreaHelperID \\
      \land static = \true
    \end{circus} &
                   \begin{circus}
                     executeInOuterArea!thread \\
                     \t1 {} \then executeInOuterAreaRet \then \Skip
                   \end{circus}\\
    \begin{circus}
      (c,managedMemoryClass) \in subclassRel~cs \\
      \land m = exitMemoryID \\
      \land static = \true
    \end{circus} &
                   \begin{circus}
                     exitMemory!thread \\
                     \t1 {} \then exitMemoryRet \then \Skip
                   \end{circus}\\
    \begin{circus}
      (c,aperiodicEventHandlerClass) \\
      \t1 {} \in subclassRel~cs \\
      \land m = initAPEHID \\
      \land static = \false
    \end{circus} &
                   \begin{circus}
                     initAPEH!thread!(seqTo5Tuple~methodArgs) \\
                     \t1 {} \then initAPEHRet \then \Skip
                   \end{circus}\\
    \begin{circus}
      (c,periodicEventHandlerClass) \\
      \t1 {} \in subclassRel~cs \\
      \land m = initPEHID \\
      \land static = \false
    \end{circus} &
                   \begin{circus}
                     initPEH!thread!(seqTo7Tuple~methodArgs) \\
                     \t1 {} \then initPEHRet \then \Skip
                   \end{circus}\\
    \begin{circus}
      (c,oneShotEventHandlerClass) \\
      \t1 {} \in subclassRel~cs \\
      \land m = initOSEHAbsID \\
      \land static = \false
    \end{circus} &
                   \begin{circus}
                     initOSEHAbs!thread!(seqTo6Tuple~methodArgs) \\
                     \t1 {} \then initOSEHAbsRet \then \Skip
                   \end{circus}\\
    \begin{circus}
      (c,oneShotEventHandlerClass) \\
      \t1 {} \in subclassRel~cs \\
      \land m = initOSEHRelID \\
      \land static = \false
    \end{circus} &
                   \begin{circus}
                     initOSEHRel!thread!(seqTo6Tuple~methodArgs) \\
                     \t1 {} \then initOSEHRelRet \then \Skip
                   \end{circus}\\
  \end{tabular}
  \caption{The syntactic function $specialMethodAction(c, m, static)$}
  \label{special-method-action-table}
\end{table}

Rule~[\nameref{resolve-normal-method-rule}], shown below, resolves
non-special methods by unrolling the loop in $Running$ to sequence the
method call with the action containing the method's behaviour.
The entry point of the method is obtained from the class information
for the method, which is determined as described by the data operation
$ResolveMethod$.
The first proviso of the rule ensures that the entry point, $k$, is
that given in the class information provided by $ResolveMethod$ for
the class identifier $c$ and method identifier $m$.
The action containing the behaviour of the method is the action $M$ at
the $pc = k$ branch of the choice in Running.
The second proviso requires that the execution of $M$ must result in
the top stack frame being popped and the $pc$ being set to the value
stored in the next stack frame.
This is needed to ensure that the method can be sequenced with the
behaviour after it.
It is true for all complete methods, since the return instructions
establish the required property and any property may be assumed to
hold after an infinite loop.
\begin{restatable}[resolve-normal-method]{crule}{ResolveNormalMethodRule}
  \label{resolve-normal-method-rule}
  Given $i : ProgramAddress$, if
  \setlength{\zedindent}{0.5cm}
  \begin{circus}
    \{ methodID? = m \land classID? = c \land cs? = cs \} \circseq \lschexpract ResolveMethod \rschexpract \\
    {} = {} \\
    \{ methodID? = m \land classID? = c \land cs? = cs \} \circseq \lschexpract ResolveMethod \rschexpract \circseq
    \{ class!.methodEntry~m = k \},
  \end{circus}
  and, for any $x : ProgramAddress$,
  \begin{circus}
    \{ (last~(front~fs)).storedPC = x \land frameStack = fs \} \circseq M \\
    {} = {} \\
    \{ (last~(front~fs)).storedPC = x \land frameStack = fs \} \circseq M \circseq \{ pc = x \land \# frameStack = \# fs - 1 \},
  \end{circus}
  and $m$ and $c$ do not match any of the conditions in
  Table~\ref{special-method-action-table} then,
  \setlength{\zedindent}{0.2cm}
  \setlength{\zedtab}{0.45cm}
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \{ pc = j \} \circseq \\
      \t3 \circvar poppedArgs : \seq Word \circspot \\
      \t3 \lschexpract \exists argsToPop? == e @ \\
      \t4 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t3 Invoke(c, m, poppedArgs, static) \\
      \t2 {} \circelse pc = k \circthen M \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \{ pc = j \} \circseq \\
      \t3 \circvar poppedArgs : \seq Word \circspot \\
      \t3 \lschexpract \exists argsToPop? == e @ \\
      \t4 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t3 InvokeOther(c, m, poppedArgs, static) \circseq \\
      \t3 Poll \circseq M \circseq pc := j + 1 \\
      \t2 {} \circelse pc = k \circthen M \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}
Rule~[\nameref{resolve-normal-method-rule}] applies only to those
class and method identifiers that are not handled by
Rule~[\nameref{resolve-special-method-rule}].
Because of this, Rule~[\nameref{resolve-normal-method-rule}] collapses
the choice in the $Invoke$ action, replacing it with $InvokeOther$.
The $InvokeOther$ action is sequenced with the action $Poll$ and the
method action, $M$, containing the methods behaviour.
An assignment is placed after $M$ to set $pc$ to the address of the
next instruction, allowing a sequential composition with the
instructions after the method call to be introduced.
Rule~[\nameref{resolve-normal-method-virtual-rule}] is similar but, as
with Rule~[\nameref{resolve-special-method-virtual-rule}], handles the
$getClassIDOf$ communication.

For method calls with multiple targets, then we introduce the choice
over those targets using
Rule~[\nameref{refine-invokevirtual-multi-rule}], which is applied on
line~\ref{algorithm-refine-invokevirtual-multi}.
This replaces the $HandleInvokeVirtualEPC$ action with an action that
pops the arguments of the function from the stack using the
$InterpreterStackFrameInvoke$ data operation and then makes a choice
of which method to invoke using the class of the \texttt{this}
argument for the method.
The method invocations are left as references to the $Invoke$ actions,
to be resolved later in
Algorithm~\ref{resolve-method-calls-algorithm}.
\begin{restatable}[refine-invokevirtual-multi]{crule}{RefineInvokeVirtualMultiRule}
  \label{refine-invokevirtual-multi-rule}
  Given $i : ProgramAddress$,
  \setlength{\zedindent}{0.15cm}
  \setlength{\zedtab}{0.5cm}
  \begin{circus}
    \begin{array}{l}
      \{ pc = j \} \circseq HandleInvokevirtualEPC(cpi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ pc = j \} \circseq \circvar poppedArgs : \seq Word \circspot \\
      \t1 \lschexpract \exists argsToPop? == methodArguments~m @ \\
      \t2 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t1 getClassIDOf!(head~poppedArgs)?cid \then {} \\
      \t1 \circif cid = c_1 \circthen Invoke(c_1, m, poppedArgs, \false) \\
      \t1 {} \cdots {} \\
      \t1 {} \circelse cid = c_n \circthen Invoke(c_n, m, poppedArgs, \false) \\
      \t1 \circfi
    \end{array}
  \end{circus}
  where $m : MethodID$ and $c_1, \ldots, c_n : ClassID$ are such that
  \begin{displaymath}
    \exists c_0 : Class; m_0 : MethodID | c_0 \in \ran cs \land m_0 \in \dom c_0.methodEntry @ \\
    \t1 cpi \in methodRefIndices~c_0 \land \\
    \t1 j \in c_0.methodEntry~m_0 \upto c_0.methodEnd~m_0 \land \\
    \t1 \exists c : ClassID @ c_0.constantPool~cpi = MethodRef~(c,m) \land \\
    \t1 \{ x : ClassID | (x,c) \in subclassRel~cs \} = \{c_1, \ldots , c_n\}
  \end{displaymath}
  and provided $n > 1$.
\end{restatable}
The class identifiers used in the choice are determined by first
determining the current class information as for
Rule~[\nameref{refine-invokestatic-rule}] and looking up the constant
pool index $cpi$ to obtain a $MethodRef$ containing a class
identifier, $c$, and method identifier, $m$.
The identifier $m$ determines which method should be invoked, but the
class of the method to be invoked is determined from the class of the
\texttt{this} object popped from the stack.
Since Java bytecode verification ensures that the class will be
assignable to $c$, we need only consider the identifiers of subclasses
of $c$:~$c_1, \cdots , c_n$.
We require that $n$ be greater than $1$, since this rule handles cases
with multiple targets.

After the action handling the method invocation instruction has been
refined to introduce a choice over the different methods, the
individual methods can be resolved.
This is performed in a way similar to the single method case, but we
must operate of each branch of the choice separately.
Thus, we iterate over each branch of the choice in the loop beginning
on line~\ref{algorithm-targets-loop}, using the function
\Call{Targets}{$mc$} to obtain a list of the possible targets of the
method call $mc$.
For each target, we apply
Rule~[\nameref{resolve-special-method-branch-rule}] or
Rule~[\nameref{resolve-normal-method-branch-rule}].
These are similar to Rule~[\nameref{resolve-special-method-rule}] and
Rule~[\nameref{resolve-normal-method-rule}], but operate over only a
single branch of the choice of targets.
We omit these rules due to their similarity with the rules previously
presented.
They can be found in Appendix~\ref{compilation-rules-appendix}.
After each of the targets has been resolved, the $pc$ assignment is
moved outside the choice by an application of
Law~[\nameref{alt-seq-dist-law}] on
line~\ref{algorithm-move-pc-assignments}.

In both the case of a single target and the case of multiple targets,
we attempt to introduce a sequential composition with the instructions
after the method call.
This is done on lines~\ref{algorithm-mci-sequence-introduction-start}
to~\ref{algorithm-mci-sequence-introduction-end} of
Algorithm~\ref{resolve-method-calls-algorithm} in the same way as in
Algorithm~\ref{introduce-loops-and-conditionals-algorithm}.
It may not be possible to introduce the sequential composition at this
point if, for example, a method call occurs at the end of a
conditional branch, since we must wait until the conditional has been
introduced before the sequential composition can be introduced.

As an example of method call resolution, we consider the
\texttt{invokestatic} instruction at $pc = 23$. 
Before method call resolution this appear in the choice in $Running$
as shown below.
\begin{circusaction}
  \t2 {} \cdots {} \\
  \t2 {} \circelse pc = 23 \circthen HandleInvokestatic(46) \\
  \t2 {} \cdots {} \\
\end{circusaction}
The $pc$ value $23$ is between the $methodEntry$ and $methodEnd$
values for $handleAsyncEvent$ in the $Class$ information $TPK$, shown
in Figure~\ref{example-model-figure}.
The constant pool index $46$ is thus looked up in $TPK$'s
$constantPool$, yielding a $MethodRef$ containing the class identifier
$TPKClassID$ and method identifier $f$.
Since the instruction being handled is an \texttt{invokestatic}
instruction, there is only a single target, which is the method
referred to by these identifiers.
That method is the \texttt{f()} method of \texttt{TPK}, whose entry
point is at $pc = 43$.
There is a straight sequence of instructions at this entry point,
ending with an \texttt{areturn} instruction. 
Thus, it has already been sequenced together at the point when method
resolution occurs for the first time, and separated into a method
action $TPK\_f$, which can be seen in
Figure~\ref{method-call-resolution-example-figure}.
This method call can thus be resolved.

The $HandleInvokestatic(46)$ action is refined using
Rule~[\nameref{refine-invokestatic-rule}]. 
We introduce an assumption $\{ pc = 23 \}$ at the start of the branch
to make the rule applicable.
After applying the rule, the sequence of actions starting at $pc = 23$
has the following form (with the $pc$ assumption left in).
\begin{circusaction}
  \t2 {} \cdots {} \\
  \t2 {} \circelse pc = 23 \circthen \{ pc = 23 \} \circseq \circvar poppedArgs : \seq Word \circspot \\
  \t3 \lschexpract \exists argsToPop? == methodArguments~m @ \\
  \t4 InterpreterStackFrameInvoke \rschexpract \circseq \\
  \t3 Invoke(TPKClassID, f, poppedArgs, \true) \\
  \t2 {} \cdots {}
\end{circusaction}

After refining the action with
Rule~[\nameref{refine-invokestatic-rule}], we resolve the method call
using Rule~[\nameref{resolve-normal-method-rule}], since \texttt{f()}
is not a special method.
The first proviso of this rule ensures that it is applied with
$k = 43$, since $TPK$ matches the class identifier $TPKClassID$ and
contains information for the method identifier $f$.
The second proviso is met, since $TPK\_f$ ends with
$HandleAreturnEPC$, which pops the last frame from the $frameStack$
and sets $pc$ to the stored value.
After the application of Rule~[\nameref{resolve-normal-method-rule}],
the sequence of actions has the form below, with the method invocation
action sequenced with the $TPK\_f$ action and an assignment
$pc := 24$.
\begin{circusaction}
  \t2 {} \cdots {} \\
  \t2 {} \circelse pc = 23 \circthen \{ pc = 23 \} \circseq \circvar poppedArgs : \seq Word \circspot \\
  \t3 \lschexpract \exists argsToPop? == methodArguments~m @ \\
  \t4 InterpreterStackFrameInvoke \rschexpract \circseq \\
  \t3 InvokeOther(TPKClassID, f, poppedArgs, \true) \circseq \\
  \t3 Poll \circseq TPK\_f \circseq pc := 24
  \t2 {} \cdots {}
\end{circusaction}
The assumption on the value of $pc$ can then be removed and a
sequential composition can be introduced with the instructions at
$pc = 24$, to yield the code in
Figure~\ref{method-call-resolution-example-figure}.

As mentioned previously, the resolution of methods calls and
introduction of loops and conditionals is performed in a loop until all
the methods have been separated into their own action.
After that, the remaining use of the program counter in the main
actions of $Thr$ is eliminated as described in the next section.
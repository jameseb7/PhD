When a method is complete, calls to that method can then be resolved.
This step begins with the copying of the method into a separate
action, so that it can be referenced elsewhere.
This is performed as described by
Algorithm~\ref{separate-complete-methods-algorithm}.
\begin{algorithm}
  \begin{algorithmic}[1]
    \For{$m \gets methods$} \label{algorithm-method-separation-loop}
    \If{\Call{MethodIsComplete}{$m$}} \label{algorithm-check-method-completeness}
    \State \ApplyFor{Law~[\nameref{action-intro-law}]}{$m$} \label{algorithm-introduce-method-action}
    \State \ApplyFor{Law~[\nameref{copy-rule-law}]}{$m$} \label{algorithm-copy-method-action}
    \EndIf
    \EndFor
  \end{algorithmic}
  \caption{SeparateCompleteMethods}
  \label{separate-complete-methods-algorithm}
\end{algorithm}

Algorithm~\ref{separate-complete-methods-algorithm} looks at each
method separately, as specified by the loop on
line~\ref{algorithm-method-separation-loop}, and determines if it is
complete, on line~\ref{algorithm-check-method-completeness}.
This involves a simple syntactic check that each conditional branch
ends in a return instruction or a recursion.

For methods that are complete, the sequence of actions for the method
are placed in a separate action, which is introduced using
Law~[\nameref{action-intro-law}] on
line~\ref{algorithm-introduce-method-action}.
The name used for the action does not have an effect upon the
correctness of the strategy, provided it is unique.
We adopt the icecap convention and form the name of this action from
the name of the class to which the method belongs and the name of the
method, concatenated together with an underscore.
Once the method action has been introduced, the sequence of actions at
the method's entry point in the $Running$ action is replaced with a
reference to the newly introduced action by applying
Law~[\nameref{copy-rule-law}] on
line~\ref{algorithm-copy-method-action}.

In our example, the method \texttt{f()} of the \texttt{TPK} class,
which starts at $pc = 43$, is complete on the first iteration of the
loop on line~\ref{algorithm-method-loop} of
Algorithm~\ref{epc-algorithm}.
This can be seen in
Figure~\ref{forward-sequence-introduction-example-figure}.
This method is complete because it consists of a straight sequence of
instructions ending with $HandleAreturnEPC$, which represents the
\texttt{areturn} instruction.
The sequence of instructions at $pc = 43$ is copied into the action
$TPK\_f$, which can be seen in
Figure~\ref{method-call-resolution-example-figure}.
The $pc = 43$ branch is replaced with a call to $TPK\_f$.

After all the complete methods have been copied into separate actions,
calls to those methods are resolved.
This is performed as described by
Algorithm~\ref{resolve-method-calls-algorithm}.
In this algorithm, while we indicate the parameters supplied to a rule
with the word \textbf{for}, as in previous algorithms, we use the word
\textbf{to} to indicate which part of the $Running$ action the rule is
applied to.
In all previous algorithms, the laws are applied to the whole action,
and so we omit the \textbf{to} clause.
\begin{algorithm}[th]
  \begin{algorithmic}[1]
    \For{$m \gets methods$}
    \label{algorithm-mci-method-loop} 
    \For{$mc \gets$ \Call{UnresolvedMethodsCalls}{$m$}}
    \label{algorithm-mci-method-call-loop}
    \If{\Call{IsResolvable}{$mc$}}
    \label{algorithm-is-resolvable-check}
    \If{\Call{HasSingleTarget}{$mc$}}
    \label{algorithm-multiple-targets-check}
    \Try
    \label{algorithm-try-block-begin}
    \State \ApplyTo{Rule~[\nameref{refine-invokespecial-rule}]}{$mc$}
    \State \ApplyTo{Rule~[\nameref{refine-invokestatic-rule}]}{$mc$}
    \State \ApplyTo{Rule~[\nameref{refine-invokevirtual-single-rule}]}{$mc$}
    \EndTry
    \Try
    \label{algorithm-try-block2-start}
    \State \ApplyTo{Rule~[\nameref{resolve-special-method-rule}]}{$mc$}
    \State \ApplyTo{Rule~[\nameref{resolve-special-method-virtual-rule}]}{$mc$}
    \State \ApplyFor{Rule~[\nameref{resolve-normal-method-rule}]}{$mc$}
    \State \ApplyFor{Rule~[\nameref{resolve-normal-method-virtual-rule}]}{$mc$}
    \EndTry
    \Else
    \State \ApplyTo{Rule~[\nameref{refine-invokevirtual-multi-rule}]}{$mc$}
    \label{algorithm-refine-invokevirtual-multi}
    \For{$target \gets $\Call{Targets}{$mc$}}
    \label{algorithm-targets-loop}
    \Try
    \State \ApplyToFor{Rule~[\nameref{resolve-special-method-branch-rule}]}{$mc$}{$target$}
    \State \ApplyFor{Rule~[\nameref{resolve-normal-method-branch-rule}]}{$mc$, $target$}
    \EndTry
    \EndFor
    \State \ApplyFor{Law~[\nameref{alt-seq-dist-law}]}{$mc$}
    \label{algorithm-move-pc-assignments}
    \EndIf
    \If{\Call{HasSimpleSequence}{$node$}}
    \label{algorithm-mci-sequence-introduction-start}
    \State \ApplyFor{Rule~[\nameref{sequence-introduction-rule}]}{$node$}
    \EndIf
    \label{algorithm-mci-sequence-introduction-end}
    \EndIf
    \EndFor
    \EndFor
  \end{algorithmic}
  \caption{ResolveMethodCalls}
  \label{resolve-method-calls-algorithm}
\end{algorithm}

The algorithm begins by checking each unresolved method call in each
method, as specified by the loops on
lines~\ref{algorithm-mci-method-loop}
and~\ref{algorithm-mci-method-call-loop}.
The list of unresolved method calls for a given method, $m$, is
computed by \Call{UnresolvedMethodsCalls}{$m$}, which finds the $pc$
values for which the sequence of instructions ends with a method
invocation instruction with no $pc$ assignment following it.
An example of an unresolved method call can be seen in the $pc = 14$
branch of Figure~\ref{forward-sequence-introduction-example-figure},
reproduced in part below.
\begin{circusaction}
  \t2 {} \cdots {} \\
  \t2 {} \circelse pc = 14 \circthen \cdots \circseq pc := 16 \circseq Poll \circseq \{ pc = 16 \} \circseq HandleInvokevirtualEPC(36) \\
  \t2 {} \cdots {}
\end{circusaction}
This ends with the action $HandleInvokeVirtualEPC(36)$, which handles
the \texttt{invokevirtual} instruction for the constant pool index
$36$.
It is unresolved because it does not have any $pc$ assignment or other
actions following it.

For each method call that needs resolving, we check if it can be
resolved at this point in the compilation strategy.
This is performed on line~\ref{algorithm-is-resolvable-check}, where
the boolean value \Call{IsResolvable}{$mc$} is checked.
\Call{IsResolvable}{$mc$} is true if all the targets of the method
call $mc$ are either special methods or non-special methods that are
already complete and have been separated into their own actions (as
described in Algorithm~\ref{separate-complete-methods-algorithm}).

If the method call is resolvable, then we check whether there is a
single target for the method call or multiple targets.
Calls to a single target can be transformed to a simple reference to
the corresponding method action.
Calls with multiple targets are transformed into a choice over the
behaviours for each of the possible targets.
The check of the number of targets is performed on
line~\ref{algorithm-multiple-targets-check} of
Algorithm~\ref{resolve-method-calls-algorithm}.
This uses the condition \Call{HasSingleTarget}{$mc$}, which is true if
the instruction to be handled is \texttt{invokespecial} or
\texttt{invokestatic}, or an \texttt{invokevirtual} instruction
referencing a class with no subclasses (other than itself).
It is false otherwise, that is, if the instruction is
\texttt{invokevirtual} and there are multiple subclasses of the class
referenced by the instruction.

For method calls with a single target, we replace the action that
handles the method invocation instruction with an action that pops the
arguments for the method from the stack and handles invocation of the
specific method referenced by the instruction.
This is handled slightly differently for each of the method invocation
instructions in our bytecode subset, so we have three rules for
performing this transformation, one for each
instruction:~Rule~[\nameref{refine-invokestatic-rule}],
Rule~[\nameref{refine-invokespecial-rule}] and
Rule~[\nameref{refine-invokevirtual-single-rule}].
They produce slightly different sequences of actions due to the
differences in the semantics of the method invocation instructions,
described in Section~\ref{cee-interpreter-subsection}.
% TODO: move this to the loops and conditionals section if used
% previously
These rules are applied in a try block, beginning on
line~\ref{algorithm-try-block-begin}, which tries to apply each rule in
turn, stopping when one succeeds.

In Figure~\ref{refine-invokestatic-rule-figure} we show
Rule~[\nameref{refine-invokestatic-rule}], which handles
\texttt{invokestatic} instructions.
This rule, as with other rules in this section, is applied to an
action beginning with an assumption on the value of $pc$.
This assumption is present before all actions that handle method
invocation instructions since it is introduced during bytecode
expansion (Section~\ref{expand-bytecode-subsection}).
% This allows it to be applied at the start of a branch of the choice in
% $Running$, after introducing the assumption using
% Law~[\nameref{alt-assump-intro-law}], or after a sequential
% composition, after introducing the assumption using
% Law~[\nameref{assign-assump-intro-law}] and distributing it over
% $Poll$ using Lemma~\ref{Poll-assumption-distribution-lemma}.
% After the application of the rule, the assumption can be eliminated
% using Law~[\nameref{assump-elim-law}] and
% Law~[\nameref{seq-unitl-law}].
% For brevity, we omit the application of these laws from the algorithm,
% and we understand that assumptions are introduced at the points
% required for the rules to be applied.
\begin{figure}[thp]
\begin{restatable}[refine-invokestatic]{crule}{RefineInvokestaticRule}
  \label{refine-invokestatic-rule}
  \setlength{\zedindent}{0.25cm}
  \begin{circus}
    \begin{array}{l}
      \{ pc = i \} \circseq \\
      HandleInvokestaticEPC(cpi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ pc = i \} \circseq \circvar poppedArgs : \seq Word \circspot \\
      \t1 \lschexpract \exists argsToPop? == methodArguments~m @ \\
      \t2 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t1 Invoke(c, m, poppedArgs, \true)
    \end{array}
  \end{circus}
  where $m : MethodID$ and $c : ClassID$ are such that
  \begin{displaymath}
    \exists c_0 : Class | c_0 \in \ran cs @ \\
    \t1 (\exists m_0 : MethodID | m_0 \in \dom c_0.methodEntry @ \\
    \t2 i \in c_0.methodEntry~m_0 \upto c_0.methodEnd~m_0) \\
    \t1 cpi \in methodRefIndices~c_0 \land c_0.constantPool~cpi = MethodRef~(c,m).
  \end{displaymath}
\end{restatable}
\caption{Rule~[\nameref{refine-invokestatic-rule}]}
\label{refine-invokestatic-rule-figure}
\end{figure}
Rule~[\nameref{refine-invokestatic-rule}] refines the
$HandleInvokeStaticEPC(cpi)$ to an action that pops the method's
arguments from the stack using the $InterpreterStackFrameInvoke$
operation and then behaves as the $Invoke$ action described in
Section~\ref{cee-interpreter-section}.

The method handled by $Invoke$ is identified by a class identifier,
$c$, and a method identifier, $m$.
These identifiers are determined from the $cpi$ parameter passed to
$HandleInvokeStaticEPC$, which is an index into the $constantPool$ of
the current class information.
To determine the identifiers, we first determine the current class
information, $c_0$, which is the class in $cs$ that contains a method,
$m_0$, whose bytecode spans over the current $pc$ value, $i$.
Within $c_0$, the $constantPool$ entry at $cpi$ must be a $MethodRef$.
The $c$ and $m$ values of the method to be invoked are those contained
in the $MethodRef$.
These are passed to $Invoke$, along with the arguments popped from the
stack, $poppedArgs$, and a boolean value indicating whether the method
call is static, which is $\true$ in the case of \texttt{invokestatic}.

Rule~[\nameref{refine-invokespecial-rule}] and
Rule~[\nameref{refine-invokevirtual-single-rule}] are similar to
Rule~[\nameref{refine-invokestatic-rule}].
They provide for popping an additional \texttt{this} argument from the
stack and pass a $\false$ boolean value to $Invoke$.
Rule~[\nameref{refine-invokevirtual-single-rule}] also leaves a
communication on the $getClassIDOf$ channel in place, since refinement
of a single process cannot eliminate channel communications from the
trace.
% TODO: is this the right reason for leaving the communication in?
The communication is eliminated later in the strategy, during the
\emph{Data Refinement of Objects} stage, described in
Section~\ref{data-refinement-of-objects-section}.

After one of the above rules is applied, the method invocation is
resolved by transforming the $Invoke$ action to the behaviour of the
method being invoked.
A $pc$ assignment is also introduced after the method's behaviour so
that it can be sequentially composed with the instructions after the
method call.
There are four rules for this, applied in another try block on
line~\ref{algorithm-try-block2-start}:~Rule~[\nameref{resolve-special-method-rule}]
and Rule~[\nameref{resolve-special-method-virtual-rule}], which
handles resolution of special methods, and
Rule~[\nameref{resolve-normal-method-rule}] and
Rule~[\nameref{resolve-normal-method-virtual-rule}], which handle
resolution of non-special methods.

Rule~[\nameref{resolve-special-method-rule}], shown in
Figure~\ref{resolve-special-method-rule-figure}, operates by simply
replacing the call to the $Invoke$ action with actions that specify
the behaviour for the special method, and introducing a $pc$
assignment after those actions.
This collapses the choice in the definition of the $Invoke$ action.
The assumption on the value of $pc$ is also eliminated, since it is no
longer needed.
This is also the case for the other method resolution rules applied in
the try block on line~\ref{algorithm-try-block2-start}.
The actions that define the behaviour of the special method are
identified by the syntactic function $specialMethodAction$, which is
defined by Table~\ref{special-method-action-table}.
It determines which behaviour should be used based on the class and
method identifiers passed to $Invoke$ and the boolean value indicating
whether the method is static.
\begin{figure}[thp]
\begin{restatable}[resolve-special-method]{crule}{ResolveSpecialMethodRule}
  \label{resolve-special-method-rule}
  If $c$, $m$ and $static$ match one of the rows of
  Table~\ref{special-method-action-table}, then
  \setlength{\zedindent}{0.25cm} \setlength{\zedtab}{0.5cm}
  \begin{circus}
    \begin{array}{l}
      \{ pc = i \} \circseq \circvar poppedArgs : \seq Word \circspot \\
      \lschexpract \exists argsToPop? == e @ \\
      \t1 InterpreterStackFrameInvoke \rschexpract \circseq \\
      Invoke(c, m, poppedArgs, s)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circvar poppedArgs : \seq Word \circspot \\
      \lschexpract \exists argsToPop? == e @ \\
      \t1 InterpreterStackFrameInvoke \rschexpract \circseq \\
      specialMethodAction(c, m, s) \circseq \\
      pc := i + 1
    \end{array}
  \end{circus}
  where $specialMethodAction$ is the syntactic function defined by
  Table~\ref{special-method-action-table}.
\end{restatable}
\caption{Rule~[\nameref{resolve-special-method-rule}]}
\label{resolve-special-method-rule-figure}
\end{figure}
Rule~[\nameref{resolve-special-method-virtual-rule}] is similar to
Rule~[\nameref{resolve-special-method-rule}], but handles the extra
communication on $getClassIDOf$ in the case of an
\texttt{invokevirtual} instruction.

\begin{table}
  \centering
  \small
  \setlength{\abovedisplayskip}{-5pt}
  \setlength{\belowdisplayskip}{-10pt}
  \setlength{\abovedisplayshortskip}{0pt}
  \setlength{\belowdisplayshortskip}{0pt}
  \setlength{\zedindent}{-0.1cm}
  \setlength{\zedleftsep}{0cm}
  \renewcommand{\arraystretch}{1}
  \rowcolors{1}{white}{lightgray}
  \begin{tabular}{p{6.5cm}p{7.7cm}}
    \hline
    Conditions on $c$, $m$ and $s$ & $specialMethodAction(c, m, s)$ \\
    \hline
    \begin{circus}
      (c,resumeThreadClass) \in subclassRel~cs \\
      \land m = resumeThreadID \land s = \true
    \end{circus} &
                   \begin{circus}
                     resumeThread!(WordToThreadID~(methodArgs~1)) \\
                     \t1 {} \then resumeThreadRet \then \Skip
                   \end{circus}\\
    \begin{circus}
      (c,suspendClass) \in subclassRel~cs \\
      \land m = suspendID \land s = \true
    \end{circus} &
                   \begin{circus}
                     suspend \then suspendRet \then \Skip
                   \end{circus}\\
    \begin{circus}
      (c,writeClass) \in subclassRel~cs \\
      \land m = writeID \land s = \true
    \end{circus} &
                   \begin{circus}
                     output!(methodArgs~1) \then \Skip
                   \end{circus}\\
    \begin{circus}
      (c,readClass) \in subclassRel~cs \\
      \land m = readID \land s = \true
    \end{circus} &
                   \begin{circus}
                     input?value \then \lschexpract InterpreterPush \hide (pc,pc') \rschexpract
                   \end{circus}\\
    \begin{circus}
      (c,managedSchedulableClass) \\
      \t1 {} \in subclassRel~cs \\
      \land m = registerID \land s = \false
    \end{circus} &
                   \begin{circus}
                     register!thread!(head~methodArgs) \\
                     \t1 {} \then registerRet \then \Skip
                   \end{circus}\\
    \begin{circus}
      (c,managedMemoryClass) \in subclassRel~cs \\
      \land m = enterPrivateMemoryHelperID \\
      \land s = \true
    \end{circus} &
                   \begin{circus}
                     enterPrivateMemory!thread!(methodArgs~1) \\
                     \t1 {} \then enterPrivateMemoryRet \then \Skip 
                   \end{circus}\\
    \begin{circus}
      (c,managedMemoryClass) \in subclassRel~cs \\
      \land m = executeInAreaOfHelperID \\
      \land s = \true
    \end{circus} &
                   \begin{circus}
                     executeInAreaOf!thread!(methodArgs~1) \\
                     \t1 {} \then executeInAreaOfRet \then \Skip
                   \end{circus}\\
    \begin{circus}
      (c,managedMemoryClass) \in subclassRel~cs \\
      \land m = executeInOuterAreaHelperID \\
      \land s = \true
    \end{circus} &
                   \begin{circus}
                     executeInOuterArea!thread \\
                     \t1 {} \then executeInOuterAreaRet \then \Skip
                   \end{circus}\\
    \begin{circus}
      (c,managedMemoryClass) \in subclassRel~cs \\
      \land m = exitMemoryID \land s = \true
    \end{circus} &
                   \begin{circus}
                     exitMemory!thread \\
                     \t1 {} \then exitMemoryRet \then \Skip
                   \end{circus}\\
    \begin{circus}
      (c,aperiodicEventHandlerClass) \\
      \t1 {} \in subclassRel~cs \\
      \land m = initAPEHID \land s = \false
    \end{circus} &
                   \begin{circus}
                     initAPEH!thread!(seqTo5Tuple~methodArgs) \\
                     \t1 {} \then initAPEHRet \then \Skip
                   \end{circus}\\
    \begin{circus}
      (c,periodicEventHandlerClass) \\
      \t1 {} \in subclassRel~cs \\
      \land m = initPEHID \land s = \false
    \end{circus} &
                   \begin{circus}
                     initPEH!thread!(seqTo7Tuple~methodArgs) \\
                     \t1 {} \then initPEHRet \then \Skip
                   \end{circus}\\
    \begin{circus}
      (c,oneShotEventHandlerClass) \\
      \t1 {} \in subclassRel~cs \\
      \land m = initOSEHAbsID \land s = \false
    \end{circus} &
                   \begin{circus}
                     initOSEHAbs!thread!(seqTo6Tuple~methodArgs) \\
                     \t1 {} \then initOSEHAbsRet \then \Skip
                   \end{circus}\\
    \begin{circus}
      (c,oneShotEventHandlerClass) \\
      \t1 {} \in subclassRel~cs \\
      \land m = initOSEHRelID \land s = \false
    \end{circus} &
                   \begin{circus}
                     initOSEHRel!thread!(seqTo6Tuple~methodArgs) \\
                     \t1 {} \then initOSEHRelRet \then \Skip
                   \end{circus}\\
  \end{tabular}
  \caption{The syntactic function $specialMethodAction(c, m, static)$}
  \label{special-method-action-table}
\end{table}

Rule~[\nameref{resolve-normal-method-rule}], shown in
Figure~\ref{resolve-normal-method-rule-figure}, resolves non-special
methods by unrolling the loop in $Running$ to sequence the method call
with the action defining the method's behaviour.
The entry point of the method is obtained from the class information
for the method, which is determined as described by the data operation
$ResolveMethod$.
The first proviso of the rule requires that the nonemptiness of the
$frameStack$ is not affected by the instructions before the method
invocation, as with previous compilation rules in this stage. 
The second proviso of the rule ensures that the entry point, $k$, is
that given in the class information provided by $ResolveMethod$ for
the class identifier $c$ and method identifier $m$.

The action containing the behaviour of the method is $M$, at the
$pc = k$ branch of the choice in $Running$.
The third proviso requires that the execution of $M$ must result in
the top stack frame being popped and the $pc$ being set to the value
stored in the next stack frame.
This is needed to ensure that the method can be sequenced with the
behaviour after it.
It is true for all complete methods, since the return instructions
establish the required property and any property may be assumed to
hold after an infinite loop.
\begin{figure}[thp]
\begin{restatable}[resolve-normal-method]{crule}{ResolveNormalMethodRule}
  \label{resolve-normal-method-rule}
  Given $i : ProgramAddress$, if
  \setlength{\zedindent}{0.5cm}
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\},
  \end{circus}
  and there exists $classInfo : Class$ in $\ran cs$ such that,
  \begin{circus}
    \{ methodID = m \land classID = c \} \circseq \lschexpract ResolveMethod \rschexpract \\
    {} = {} \\
    \{ methodID = m \land classID = c \} \circseq \lschexpract ResolveMethod \rschexpract \circseq \\
    \t1 \{ class = classInfo \land classInfo.methodEntry~m = k \},
  \end{circus}
  and, for any $x : ProgramAddress$,
  \begin{circus}
    \{ (last~(front~frameStack)).storedPC = x \} \circseq M \\
    {} = {} \\
    \{ (last~(front~frameStack)).storedPC = x \} \circseq M \circseq \{ pc = x \},
  \end{circus}
  and $m$ and $c$ do not match any of the conditions in
  Table~\ref{special-method-action-table} then,
  \setlength{\zedindent}{0.2cm}
  \setlength{\zedtab}{0.45cm}
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \{ pc = j \} \circseq \\
      \t3 \circvar poppedArgs : \seq Word \circspot \\
      \t3 \lschexpract \exists argsToPop? == e @ \\
      \t4 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t3 Invoke(c, m, poppedArgs, s) \\
      \t2 {} \circelse pc = k \circthen M \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 (\circvar poppedArgs : \seq Word \circspot \\
      \t3 \lschexpract \exists argsToPop? == e @ \\
      \t4 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t3 \lschexpract InterpreterNewStackFrame[ \\
      \t4 classInfo/class? \\
      \t4 m/methodID?, \\
      \t4 poppedArgs/methodArgs?] \rschexpract) \circseq \\
      \t3 Poll \circseq M \circseq pc := j + 1 \\
      \t2 {} \circelse pc = k \circthen M \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}
\caption{Rule~[\nameref{resolve-normal-method-rule}]}
\label{resolve-normal-method-rule-figure}
\end{figure}

Rule~[\nameref{resolve-normal-method-rule}] applies only to those
class and method identifiers that are not handled by
Rule~[\nameref{resolve-special-method-rule}].
Because of this, Rule~[\nameref{resolve-normal-method-rule}] collapses
the choice in the $Invoke$ action, replacing it with the data
operation $InterpreterNewStackFrame$, sequenced with the action $Poll$
and the method action, $M$, defining the method's behaviour.
An assignment is placed after $M$ to set $pc$ to the address of the
next instruction.
% , allowing a sequential composition with the
% instructions after the method call to be introduced.
Rule~[\nameref{resolve-normal-method-virtual-rule}] is similar but, as
with Rule~[\nameref{resolve-special-method-virtual-rule}], handles the
$getClassIDOf$ communication.

For method calls with multiple targets, we introduce the choice over
those targets by using
Rule~[\nameref{refine-invokevirtual-multi-rule}]
(Figure~\ref{refine-invokevirtual-multi-rule-figure}), which is
applied on line~\ref{algorithm-refine-invokevirtual-multi}.
This replaces the action $HandleInvokeVirtualEPC$ with an action that
pops the arguments of the function from the stack using the data
operation $InterpreterStackFrameInvoke$, and then makes a choice of
which method to invoke using the class of the \texttt{this} argument
for the method.
The method invocations are left as references to the $Invoke$ actions,
to be resolved later in
Algorithm~\ref{resolve-method-calls-algorithm}.
The assumption on the value of $pc$ is converted to an assumption on
the $storedPC$ value of the current stack frame, and distributed into
each of the branches of the choice, so it can be handled separately
for each branch.

\begin{figure}[thp]
\begin{restatable}[refine-invokevirtual-multi]{crule}{RefineInvokeVirtualMultiRule}
  \label{refine-invokevirtual-multi-rule}
  Given $i : ProgramAddress$,
  \setlength{\zedindent}{0.15cm}
  \setlength{\zedtab}{0.5cm}
  \begin{circus}
    \begin{array}{l}
      \{ pc = j \} \circseq \\
      HandleInvokevirtualEPC(cpi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circvar poppedArgs : \seq Word \circspot \\
      \lschexpract \exists argsToPop? == methodArguments~m @ \\
      \t1 InterpreterStackFrameInvoke \rschexpract \circseq \\
      getClassIDOf!(head~poppedArgs)?cid \then {} \\
      \circif cid = c_1 \circthen \\
      \t1 \{ (last~frameStack).storedPC = j + 1 \} \circseq \\
      \t1 Invoke(c_1, m, poppedArgs, \false) \\
      {} \cdots {} \\
      {} \circelse cid = c_n \circthen \\
      \t1 \{ (last~frameStack).storedPC = j + 1 \} \circseq \\
      \t1 Invoke(c_n, m, poppedArgs, \false) \\
      \circfi
    \end{array}
  \end{circus}
  where $m : MethodID$ and $c_1, \ldots, c_n : ClassID$ are such that
  \begin{displaymath}
    \exists c_0 : Class; m_0 : MethodID | c_0 \in \ran cs \land m_0 \in \dom c_0.methodEntry @ \\
    \t1 cpi \in methodRefIndices~c_0 \land \\
    \t1 j \in c_0.methodEntry~m_0 \upto c_0.methodEnd~m_0 \land \\
    \t1 \exists c : ClassID @ c_0.constantPool~cpi = MethodRef~(c,m) \land \\
    \t1 \{ x : ClassID | (x,c) \in subclassRel~cs \} = \{c_1, \ldots , c_n\}
  \end{displaymath}
  and provided $n > 1$.
\end{restatable}
\caption{Rule~[\nameref{refine-invokevirtual-multi-rule}]}
\label{refine-invokevirtual-multi-rule-figure}
\end{figure}
The class identifiers used in the choice are determined by looking up
the constant pool index, $cpi$, as for
Rule~[\nameref{refine-invokestatic-rule}], to obtain a class
identifier, $c$, and method identifier, $m$.
The identifier $m$ determines which method should be invoked, but the
class of the method to be invoked is determined from the class of the
\texttt{this} object popped from the stack.
% TODO: should we reference the fact that this is mentioned above
Since Java bytecode verification ensures that the class is assignable
to $c$, we need only consider the identifiers of subclasses of
$c$:~$c_1, \cdots , c_n$.
We require that $n$ be greater than $1$, since this rule handles cases
with multiple targets.

After the action handling the method invocation instruction has been
refined to introduce a choice over the different methods, the
individual methods can be resolved.
This is performed in a way similar to the single method case, but we
must operate of each branch of the choice separately.
Thus, we iterate over each branch of the choice in the loop beginning
on line~\ref{algorithm-targets-loop}, using the function
\Call{Targets}{$mc$} to obtain a list of the possible targets of the
method call $mc$.
For each target, we apply
Rule~[\nameref{resolve-special-method-branch-rule}] or
Rule~[\nameref{resolve-normal-method-branch-rule}].
These are similar to Rule~[\nameref{resolve-special-method-rule}] and
Rule~[\nameref{resolve-normal-method-rule}], but operate over only a
single branch of the choice of targets.
We omit these rules due to their similarity with the rules previously
presented.
They can be found in Appendix~\ref{compilation-rules-appendix}.
After each of the targets has been resolved, the $pc$ assignment is
moved outside the choice by an application of
Law~[\nameref{alt-seq-dist-law}] on
line~\ref{algorithm-move-pc-assignments}.

In both the case of a single target and the case of multiple targets,
we attempt to introduce a sequential composition with the instructions
after the method call.
This is done on lines~\ref{algorithm-mci-sequence-introduction-start}
to~\ref{algorithm-mci-sequence-introduction-end} of
Algorithm~\ref{resolve-method-calls-algorithm} in the same way as in
Algorithm~\ref{introduce-loops-and-conditionals-algorithm}.
It may not be possible to introduce the sequential composition at this
point if, for example, a method call occurs at the end of a
conditional branch, since we must wait until the conditional has been
introduced before the sequential composition can be introduced.

As an example of method call resolution, we consider the
\texttt{invokestatic} instruction at $pc = 23$. 
Before method call resolution this appears in the choice in $Running$
as shown below.
\begin{circusaction}
  \t2 {} \cdots {} \\
  \t2 {} \circelse pc = 23 \circthen \{ pc = 23 \} \circseq HandleInvokestatic(46) \\
  \t2 {} \cdots {} \\
\end{circusaction}
The $pc$ value $23$ is between the $methodEntry$ and $methodEnd$
values for $handleAsyncEvent$ in the $Class$ information $TPK$, shown
in Figure~\ref{example-model-figure}.
The constant pool index $46$ is thus looked up in $TPK$'s
$constantPool$, yielding a $MethodRef$ containing the class identifier
$TPKClassID$ and method identifier $f$.
Since the instruction being handled is an \texttt{invokestatic}
instruction, there is only a single target, which is the method
referenced by these identifiers.
That method is the \texttt{f()} method of \texttt{TPK}, whose entry
point is at $pc = 43$.
There is a straight sequence of instructions at this entry point,
ending with an \texttt{areturn} instruction. 
Thus, it has already been sequenced together when method resolution
occurs for the first time, and separated into a method action
$TPK\_f$, which can be seen in
Figure~\ref{method-call-resolution-example-figure}.
This method call can thus be resolved.

The $HandleInvokestatic(46)$ action is refined using
Rule~[\nameref{refine-invokestatic-rule}].
After applying this rule, the sequence of actions starting at
$pc = 23$ has the following form.
\begin{circusaction}
  \t2 {} \cdots {} \\
  \t2 {} \circelse pc = 23 \circthen \{ pc = 23 \} \circseq \circvar poppedArgs : \seq Word \circspot \\
  \t3 \lschexpract \exists argsToPop? == methodArguments~m @ \\
  \t4 InterpreterStackFrameInvoke \rschexpract \circseq \\
  \t3 Invoke(TPKClassID, f, poppedArgs, \true) \\
  \t2 {} \cdots {}
\end{circusaction}

After refining the action with
Rule~[\nameref{refine-invokestatic-rule}], we resolve the method call
using Rule~[\nameref{resolve-normal-method-rule}], since \texttt{f()}
is not a special method.
The first proviso of this rule ensures that it is applied with
$k = 43$, since $TPK$ matches the class identifier $TPKClassID$ and
contains information for the method identifier $f$.
The second proviso is met, since $TPK\_f$ ends with
$HandleAreturnEPC$, which pops the last frame from the $frameStack$
and sets $pc$ to the stored value.
After the application of Rule~[\nameref{resolve-normal-method-rule}],
the sequence of actions has the form below, with the method invocation
sequenced with the $TPK\_f$ action and an assignment $pc := 24$.
\begin{circusaction}
  \t2 {} \cdots {} \\
  \t2 {} \circelse pc = 23 \circthen (\circvar poppedArgs : \seq Word \circspot \\
  \t3 \lschexpract \exists argsToPop? == methodArguments~m @ InterpreterStackFrameInvoke \rschexpract \circseq \\
  \t3 \lschexpract InterpreterNewStackFrame[ \\
  \t4 TPK/class?, f/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq \\
  \t3 Poll \circseq TPK\_f \circseq pc := 24 \\
  \t2 {} \cdots {}
\end{circusaction}
A sequential composition can then be introduced with the instructions
at $pc = 24$, to yield the code in
Figure~\ref{method-call-resolution-example-figure}.

As mentioned previously, the resolution of methods calls and
introduction of loops and conditionals is performed in a loop until
all the methods have been separated into their own actions.
After that, the remaining uses of the program counter in the main
actions of $Thr$ are eliminated as described in the next section.

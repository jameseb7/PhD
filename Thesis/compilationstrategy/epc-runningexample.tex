We explain the strategy in detail with an example, the Java code for
which is shown in Figure~\ref{example-code-figure}.
\begin{figure}[tb!]
  \begin{center}
  \begin{minipage}{14cm}
  \begin{lstlisting}[basicstyle=\ttfamily\footnotesize,keywordstyle=\bf\footnotesize,language=Java,numbers=left,numberstyle=\tiny,stepnumber=1, numbersep=5pt,escapeinside={(*@}{@*)}]
public class TPK extends AperiodicEventHandler {

  public TPK(PriorityParameters priority,
             AperiodicParameters release,
             StorageParameters storage,
             ConfigurationParameters config) {
    super(priority, release, storage, config);
  }
      
  public void handleAsyncEvent() {
    ConsoleConnection console = new ConsoleConnection(null); (*@\label{example-ConsoleConnection-line}@*)
        
    InputStream input = console.openInputStream(); (*@\label{example-InputStream-line}@*)
    OutputStream output = console.openOutputStream(); (*@\label{example-OutputStream-line}@*)
        
    for(int i = 0; i <= 10; i = i + 1) { (*@\label{example-for-loop-line}@*)
      int y = f(input.read());
          
      if (y > 400) {
        output.write(0);
      } else {
        output.write(y);
      }
    }
  }
      
  public static int f(int x){
    return x + x + x + 5;
  }
      
}
\end{lstlisting}
\end{minipage}
\end{center}
  \caption{Our example program}
  \label{example-code-figure}
\end{figure}
Our example is based on the Trabb Pardo-Knuth
algorithm~\cite{knuth1980}, used for comparison of programming
languages, since it includes a variety of programming constructs that
provide a good test of the strategy.
We have simplified the algorithm by removing the reading into an
array, since our bytecode subset does not include array operations.
Adding arrays makes the example much longer, while not giving any
interesting insight into our compilation strategy.
As previously explained, extending the bytecode set considered to deal
with arrays is not difficult.

\begin{figure}[p!]
  \begin{center}
  \setlength{\linewidth}{12cm}
  \begin{tabular}{p{9.5cm}p{4.5cm}}
    \scriptsize
    \setlength{\zedindent}{0cm}
    \setlength{\zedtab}{0.3cm}
    \setlength{\zedleftsep}{0cm}
    \begin{axdef}
      TPK : Class
    \where
      TPK = \lblot \\
      \t1 constantPool == \{ \\
      \t2 1 \mapsto ClassRef~TPKClassID, \\
      \t2 3 \mapsto ClassRef~AperiodicEventHandlerClassID, \\
      \t2 8 \mapsto MethodRef~AperiodicEventHandlerClassID~APEHinit, \\
      \t2 27 \mapsto ClassRef~ConsoleConnectionClassID, \\
      \t2 29 \mapsto  MethodRef~ConsoleConnectionClassID~CCinit, \\
      \t2 32 \mapsto MethodRef~ConsoleConnectionClassID~openInputStream, \\
      \t2 36 \mapsto MethodRef~ConsoleConnectionClassID~openOutputStream, \\
      \t2 40 \mapsto MethodRef~InputStreamClassID~read, \\
      \t2 41 \mapsto ClassRef~InputStreamClassID, \\
      \t2 46 \mapsto MethodRef~TPKClassID~f, \\
      \t2 50 \mapsto MethodRef~OutputStreamClassID~write, \\
      \t2 51 \mapsto ClassRef~OutputStreamClassID \\
      \t1 \}, \\
      \t1 this == 1, \\
      \t1 super == 3, \\
      \t1 interfaces == \{\}, \\
      \t1 methodEntry == \{ \\
      \t2 f \mapsto 43, \\
      \t2 handleAsyncEvent \mapsto 7, \\
      \t2 APEHinit \mapsto 0, \\
      \t1 \}, \\
      \t1 methodEnd == \{ \\
      \t2 f \mapsto 50, \\
      \t2 handleAsyncEvent \mapsto 42, \\
      \t2 APEHinit \mapsto 6 \\
      \t1 \}, \\
      \t1 methodLocals == \{ \\
      \t2 f \mapsto 1, \\
      \t2 handleAsyncEvent \mapsto 6, \\
      \t2 APEHinit \mapsto 5, \\
      \t1 \}, \\
      \t1 methodStackSize == \{ \\
      \t2 f \mapsto 2, \\
      \t2 handleAsyncEvent \mapsto 3, \\
      \t2 APEHinit \mapsto 5, \\
      \t1 \}, \\
      \t1 staticMethods == \{ f \} \\
      \t1 fields == \{\}, \\
      \t1 staticFields == \{\} \\
      \rblot
    \end{axdef}
    \begin{axdef}
      cs : ClassID \pfun Class
      \where
      cs = \{ \\
      \t1 TPKClassID \mapsto TPK, \\
      \t1 AperiodicEventHandlerClassID \mapsto AperiodicEventHandler, \\
      \t1 ManagedEventHandlerClassID \mapsto ManagedEventHandler, \\
      \t1 \cdots \\
      \}
    \end{axdef}
    &
    \scriptsize
    \setlength{\zedindent}{0cm}
    \setlength{\zedtab}{0.3cm}
    \setlength{\zedleftsep}{0cm}
    \begin{axdef}
      bc : ProgramAddress \pfun Bytecode
      \where
      bc = \{ \\
      	\t1 0 \mapsto aload~0, \\
        \t1 1 \mapsto aload~1, \\
        \t1 2 \mapsto aload~2, \\
        \t1 3 \mapsto aload~3, \\
        \t1 4 \mapsto aload~4, \\
        \t1 5 \mapsto invokespecial~8, \\
        \t1 6 \mapsto return, \\
        \t1 7 \mapsto new~27, \\
        \t1 8 \mapsto dup, \\
        \t1 9 \mapsto aconst\_null, \\
        \t1 10 \mapsto invokespecial~29, \\
        \t1 11 \mapsto astore~1, \\
        \t1 12 \mapsto aload~1, \\
        \t1 13 \mapsto invokevirtual~32, \\
        \t1 14 \mapsto astore~2, \\
        \t1 15 \mapsto aload~1, \\
        \t1 16 \mapsto invokevirtual~36, \\
        \t1 17 \mapsto astore~3, \\
        \t1 18 \mapsto iconst~0, \\
        \t1 19 \mapsto astore~4, \\
        \t1 20 \mapsto goto~19, \\
        \t1 21 \mapsto aload~2, \\
        \t1 22 \mapsto invokevirtual~40, \\
        \t1 23 \mapsto invokestatic~46, \\
        \t1 24 \mapsto astore~5, \\
        \t1 25 \mapsto aload~5, \\
        \t1 26 \mapsto iconst~400, \\
        \t1 27 \mapsto if\_icmple~5, \\
        \t1 28 \mapsto aload~3, \\
        \t1 29 \mapsto iconst~0, \\
        \t1 30 \mapsto invokevirtual~50, \\
        \t1 31 \mapsto goto~4, \\
        \t1 32 \mapsto aload~3, \\
        \t1 33 \mapsto aload~5, \\
        \t1 34 \mapsto invokevirtual~50, \\
        \t1 35 \mapsto aload~4, \\
        \t1 36 \mapsto iconst~1, \\
        \t1 37 \mapsto iadd, \\
        \t1 38 \mapsto astore~4, \\
        \t1 39 \mapsto aload~4, \\
        \t1 40 \mapsto iconst~10, \\
        \t1 41 \mapsto if\_icmple~(\negate 20), \\
        \t1 42 \mapsto return, \\
        \t1 43 \mapsto aload~0, \\
        \t1 44 \mapsto aload~0, \\
        \t1 45 \mapsto iadd, \\
        \t1 46 \mapsto aload~0, \\
        \t1 47 \mapsto iadd, \\
        \t1 48 \mapsto iconst~5, \\
        \t1 49 \mapsto iadd, \\
        \t1 50 \mapsto areturn, \\
        \t1 {} \cdots {} \\
        \}
      \end{axdef}
  \end{tabular}
  \end{center}
  \caption{The \Circus{} code corresponding to our example program}
  \label{example-model-figure}
\end{figure}%

We have also written the example as an SCJ program, with the algorithm
as the body of an aperiodic event handler, \texttt{TPK}, one or more
instances of which can be registered as part of a mission and released
during mission execution.
As already mentioned, each release of the handler causes its
\texttt{handleAsyncEvent()} method to be executed.
This method creates an instance of a \texttt{ConsoleConnection}
(line~\ref{example-ConsoleConnection-line}), which is the only
standard input/output connection required by SCJ.
Instances of \texttt{InputStream} and \texttt{OutputStream} are then
obtained from the \texttt{ConsoleConnection}
(lines~\ref{example-InputStream-line}
and~\ref{example-OutputStream-line}).

After the input and output streams have been obtained, we enter a for
loop (line~\ref{example-for-loop-line}) in which an integer is read
from the \texttt{InputStream}, a static method \texttt{f()} is applied
to it, and the result is output if it is less than 400, otherwise, 0
is output.
The method \texttt{f()} takes an integer as input, multiplies it by 3
and adds 5 to it.

\begin{figure}[pt!]
  \begin{center}
    % \setlength{\linewidth}{12cm}
    \begin{minipage}{7.5cm}
      \scriptsize
      \setlength{\abovedisplayskip}{0cm}
      \setlength{\belowdisplayskip}{0cm}
      \setlength{\zedindent}{0cm}
      \setlength{\zedtab}{0.3cm}
      \setlength{\zedleftsep}{0cm}
    \begin{axdef}
      AperiodicEventHandler : Class
    \where
      AperiodicEventHandler = \lblot \\
      \t1 constantPool == \{ \\
      \t2 1 \mapsto ClassRef~AperiodicEventHandlerClassID, \\
      \t2 3 \mapsto ClassRef~ManagedEventHandlerClassID, \\
      % \t2 8 \mapsto MethodRef~ManagedEventHandlerClassID~MEHinit, \\
      \t2 {} \cdots {} \\
      % \t2 11 \mapsto FieldRef~AperiodicEventHandler~priority, \\
      % \t2 15 \mapsto FieldRef~AperiodicEventHandler~backingStoreSpace, \\
      % \t2 18 \mapsto FieldRef~AperiodicEventHandler~allocAreaSpace, \\
      % \t2 21 \mapsto FieldRef~AperiodicEventHandler~stackSize, \\
      % \t2 24 \mapsto MethodRef~AperiodicEventHandler~initAPEH, \\
      % \t2 40 \mapsto MethodRef~AperiodicEventHandler~releaseAperiodic \\
      \t1 \}, \\
      \t1 this == 1, \\
      \t1 super == 3, \\
      \t1 interfaces == \{\}, \\
      \t1 methodEntry == \{ {} \cdots {}
      % \t2 MEHinit \mapsto 0, \\
      % \t2 release \mapsto 16 \\
      \}, \\
      \t1 methodEnd == \{ {} \cdots {}
      % \t2 MEHinit \mapsto 15, \\
      % \t2 release \mapsto 18 \\
      \}, \\
      \t1 methodLocals == \{ {} \cdots {}
      % \t2 MEHinit \mapsto 5, \\
      % \t2 release \mapsto 1 \\
      \}, \\
      \t1 methodStackSize == \{ {} \cdots {} 
      % \t2 MEHinit \mapsto 5, \\
      % \t2 release \mapsto 1 \\
      \}, \\
      \t1 fields == \{\}, \\
      \t1 staticFields == \{\} \\
      \rblot
    \end{axdef}%
  \end{minipage}
  \hfill
  \begin{minipage}{8cm}
    \scriptsize
    \setlength{\zedindent}{0cm}
    \setlength{\zedtab}{0.3cm}
    \setlength{\zedleftsep}{0cm}
    \begin{axdef}
      ManagedEventHandler : Class
    \where
      ManagedEventHandler = \lblot \\
      \t1 constantPool == \{ \\
      \t2 1 \mapsto ClassRef~ManagedEventHandlerClassID, \\
      \t2 3 \mapsto ClassRef~BoundAsyncEventHandlerClassID, \\
      \t2 5 \mapsto ClassRef~ManagedSchedulableClassID, \\
      % \t2 15 \mapsto MethodRef~BoundAsyncEventHandlerClassID~BAEHinit, \\
      \t2 {} \cdots {} \\
      % \t2 18 \mapsto MethodRef~PriorityParameters~getPriority, \\
      % \t2 19 \mapsto ClassRef~PriorityParameters, \\
      % \t2 24 \mapsto FieldRef~ManagedEventHandler~priority, \\
      % \t2 26 \mapsto MethodRef~ScopeParameters~getMaxInitialBackingStore, \\
      % \t2 27 \mapsto ClassRef~ScopeParameters, \\
      % \t2 32 \mapsto FieldRef~ManagedEventHandler~backingStoreSpace, \\
      % \t2 34 \mapsto MethodRef~ScopeParameters~getMaxInitialArea, \\
      % \t2 37 \mapsto FieldRef~ManagedEventHandler~allocAreaSpace, \\
      % \t2 39 \mapsto MethodRef~ConfigurationParameters~getSizes, \\
      % \t2 40 \mapsto ClassRef~ConfigurationParameters, \\
      % \t2 45 \mapsto MethodRef~LongArray~load, \\
      % \t2 46 \mapsto ClassRef~LongArray, \\
      % \t2 51 \mapsto FieldRef~ManagedEventHandler~stackSize, \\
      % \t2 66 \mapsto MethodRef~ManagedEventHandler~register \\
      \t1 \}, \\
      \t1 this == 1, \\
      \t1 super == 3, \\
      \t1 interfaces == \{5\}, \\
      \t1 methodEntry == \{ {} \cdots {}
      % \t2 MEHinit \mapsto 19, \\
      % \t2 getName \mapsto 41, \\
      % \t2 signalTermination \mapsto 46, \\
      % \t2 cleanUp \mapsto 40, \\
      % \t2 register \mapsto 43 \\
      \}, \\
      \t1 methodEnd == \{ {} \cdots {}
      % \t2 MEHinit \mapsto 39, \\
      % \t2 getName \mapsto 42, \\
      % \t2 signalTermination \mapsto 46, \\
      % \t2 cleanUp \mapsto 40, \\
      % \t2 register \mapsto 45 \\
      \}, \\
      \t1 methodLocals == \{ {} \cdots {}
      % \t2 MEHinit \mapsto 4, \\
      % \t2 getName \mapsto 1, \\
      % \t2 signalTermination \mapsto 1, \\
      % \t2 cleanUp \mapsto 1, \\
      % \t2 register \mapsto 1 \\
      \}, \\
      \t1 methodStackSize == \{ {} \cdots {}
      % \t2 MEHinit \mapsto 3, \\
      % \t2 getName \mapsto 1, \\
      % \t2 signalTermination \mapsto 0, \\
      % \t2 cleanUp \mapsto 0, \\
      % \t2 register \mapsto 1 \\
      \}, \\
      \t1 fields == \{ \\
      \t2 threadID, \\
      \t2 backingStoreSpace, \\
      \t2 allocAreaSpace, \\
      \t2 stackSize \\
      \t1 \}, \\
      \t1 staticFields == \{\} \\
      \rblot
    \end{axdef}
  \end{minipage}
  \end{center}
  \caption{The $Class$ structures for \texttt{AperiodicEventHandler}
    and \texttt{ManagedEventHandler}}
  \label{example-superclasses-model-figure}
\end{figure}%

\begin{figure}[tp!]
  \setlength{\zedindent}{0cm}
  \setlength{\zedtab}{0.3cm}
  \setlength{\zedleftsep}{0.1cm}
  \setlength{\abovedisplayskip}{0cm}
  \setlength{\belowdisplayskip}{0cm}
  \scriptsize
  \begin{minipage}{0.5\textwidth}
  \addchange{Expanded Figure\protect~\protect\ref{bytecode-expansion-example-figure}
    to include all bytecode instructions and split it into two columns
    to fit the page}
  \changed{
  \begin{circus}
    Running \circdef \\
    \t1 \circif frameStack = \emptyset \circthen \Skip \\
    \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
    \t2 \circif pc = 0 \circthen HandleAloadEPC(0) \circseq pc := 1 \\
    \t2 {} \circelse pc = 1 \circthen HandleAloadEPC(1) \circseq pc := 2 \\
    \t2 {} \circelse pc = 2 \circthen HandleAloadEPC(2) \circseq pc := 3 \\
    \t2 {} \circelse pc = 3 \circthen HandleAloadEPC(3) \circseq pc := 4 \\
    \t2 {} \circelse pc = 4 \circthen HandleAloadEPC(4) \circseq pc := 5 \\
    \t2 {} \circelse pc = 5 \circthen \{ pc = 5 \} \circseq HandleInvokespecialEPC(8) \\
    \t2 {} \circelse pc = 6 \circthen HandleReturnEPC \\
    \t2 {} \circelse pc = 7 \circthen HandleNewEPC(27) \circseq pc := 8 \\
    \t2 {} \circelse pc = 8 \circthen HandleDupEPC \circseq pc := 9 \\
    \t2 {} \circelse pc = 9 \circthen HandleAconst\_nullEPC \circseq pc := 10 \\
    \t2 {} \circelse pc = 10 \circthen \{ pc = 10 \} \circseq \\
    \t3 HandleInvokespecialEPC(29) \\
    \t2 {} \circelse pc = 11 \circthen HandleAstoreEPC(1) \circseq pc := 12 \\
    \t2 {} \circelse pc = 12 \circthen HandleAloadEPC(1) \circseq pc := 13 \\
    \t2 {} \circelse pc = 13 \circthen \{ pc = 13 \} \circseq \\
    \t3 HandleInvokevirtualEPC(32) \\
    \t2 {} \circelse pc = 14 \circthen HandleAstoreEPC(2) \circseq pc := 15 \\
    \t2 {} \circelse pc = 15 \circthen HandleAloadEPC(1) \circseq pc := 16 \\
    \t2 {} \circelse pc = 16 \circthen \{ pc = 16 \} \circseq \\
    \t3 HandleInvokevirtualEPC(36) \\
    \t2 {} \circelse pc = 17 \circthen HandleAstoreEPC(3) \circseq pc := 18 \\
    \t2 {} \circelse pc = 18 \circthen HandleIconstEPC(0) \circseq pc := 19 \\
    \t2 {} \circelse pc = 19 \circthen HandleAstoreEPC(4) \circseq pc := 20 \\
    \t2 {} \circelse pc = 20 \circthen pc := 39 \\
    \t2 {} \circelse pc = 21 \circthen HandleAloadEPC(2) \circseq pc := 22 \\
    \t2 {} \circelse pc = 22 \circthen \{ pc = 22 \} \circseq \\
    \t3 HandleInvokevirtualEPC(40) \\
    \t2 {} \circelse pc = 23 \circthen \{ pc = 23 \} \circseq \\
    \t3 HandleInvokestaticEPC(46) \\
    \t2 {} \circelse pc = 24 \circthen HandleAstoreEPC(5) \circseq pc := 25 \\
    \t2 {} \circelse pc = 25 \circthen HandleAloadEPC(5) \circseq pc := 26 \\
  \end{circus}
  }
  \end{minipage}
  \begin{minipage}{0.5\textwidth}
  \changed{
  \begin{circus}
    \t2 {} \circelse pc = 26 \circthen HandleIconstEPC(400) \circseq pc := 27 \\
    \t2 {} \circelse pc = 27 \circthen \circvar value1, value2 : Word \circspot \\
    \t3 InterpreterPop2 \circseq \\
    \t3 pc := \IF value1 \leq value2 \THEN 32 \ELSE 28 \\
    \t2 {} \circelse pc = 28 \circthen HandleAloadEPC(3) \circseq pc := 29 \\
    \t2 {} \circelse pc = 29 \circthen HandleIconstEPC(0) \circseq pc := 30 \\
    \t2 {} \circelse pc = 30 \circthen \{ pc = 30 \} \circseq \\
    \t3 HandleInvokevirtualEPC(50) \\
    \t2 {} \circelse pc = 31 \circthen pc := 35 \\
    \t2 {} \circelse pc = 32 \circthen HandleAloadEPC(3) \circseq pc := 33 \\
    \t2 {} \circelse pc = 33 \circthen HandleAloadEPC(5) \circseq pc := 34 \\
    \t2 {} \circelse pc = 34 \circthen \{ pc = 34 \} \circseq \\
    \t3 HandleInvokevirtualEPC(50) \\
    \t2 {} \circelse pc = 35 \circthen HandleAloadEPC(4) \circseq pc := 36 \\
    \t2 {} \circelse pc = 36 \circthen HandleIconstEPC(1) \circseq pc := 37 \\
    \t2 {} \circelse pc = 37 \circthen HandleIaddEPC \circseq pc := 38 \\
    \t2 {} \circelse pc = 38 \circthen HandleAstoreEPC(4) \circseq pc := 39 \\
    \t2 {} \circelse pc = 39 \circthen HandleAloadEPC(4) \circseq pc := 40 \\
    \t2 {} \circelse pc = 40 \circthen HandleIconstEPC(10) \circseq pc := 41 \\
    \t2 {} \circelse pc = 41 \circthen \circvar value1, value2 : Word \circspot \\
    \t3 InterpreterPop2 \circseq \\
    \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    \t2 {} \circelse pc = 42 \circthen HandleReturnEPC \\
    \t2 {} \circelse pc = 43 \circthen HandleAloadEPC(0) \circseq pc := 44 \\
    \t2 {} \circelse pc = 44 \circthen HandleAloadEPC(0) \circseq pc := 45 \\
    \t2 {} \circelse pc = 45 \circthen HandleIaddEPC \circseq pc := 46 \\
    \t2 {} \circelse pc = 46 \circthen HandleAloadEPC(0) \circseq pc := 47 \\
    \t2 {} \circelse pc = 47 \circthen HandleIaddEPC \circseq pc := 48 \\
    \t2 {} \circelse pc = 48 \circthen HandleIconstEPC(5) \circseq pc := 49 \\
    \t2 {} \circelse pc = 49 \circthen HandleIaddEPC \circseq pc := 50 \\
    \t2 {} \circelse pc = 50 \circthen HandleAreturnEPC \\
    \t2 {} \cdots {} \\
    \t2 \circfi \circseq Poll \circseq Running \\
    \t1 \circfi
  \end{circus}
  }
  \end{minipage}
  \normalsize
  \caption{The $Running$ action after bytecode expansion}
  \label{bytecode-expansion-example-figure}
\end{figure}

The \texttt{TPK} class is part of a larger program that includes other
classes, including a \texttt{Safelet}, a \texttt{MissionSequencer}, a
\texttt{Mission}, and the classes that make up the SCJ API.
% Considering these classes in our example would make the example much
% larger and more complex, while not introducing any more interesting
% aspects for the strategy to consider.
We omit a presentation of these classes, though it should be noted
that they are part of the complete example.
For compilation, they need to go through a similar refinement to that
we illustrate for the $TPK$ class.
This adds little complexity to the strategy since the bytecode array
is acted upon consistently for all classes, and the current class of a
given bytecode instruction can always be determined from its address
in the array.

The Java code must be run through a Java compiler to generate the
corresponding bytecode, which then defines the $bc$ and $cs$ constants
of our model.
Their values for our example are shown in
Figure~\ref{example-model-figure}, along with $TPK$ class information.
While most of the compilation of the methods of \texttt{TPK} depends
only on the data in the $TPK$ class information, the object data for
instances of \texttt{TPK} includes fields from its superclasses.
In particular, the fields for \texttt{TPK} are contributed by the
\texttt{AperiodicEventHandler} and \texttt{ManagedEventHandler}
classes (the superclasses of \texttt{ManagedEventHandler} do not
contribute any fields), whose $Class$ data structures are presented in
Figure~\ref{example-superclasses-model-figure}.
The generation of object structures from this field information is
discussed in more detail in
Section~\ref{data-refinement-of-objects-section}.

\begin{figure}[t!]
  \setlength{\zedindent}{0cm}
  \setlength{\zedtab}{0.3cm}
  \setlength{\zedleftsep}{0.1cm}
  \setlength{\abovedisplayskip}{0cm}
  \setlength{\belowdisplayskip}{0cm}
  \scriptsize
  \addchange{Changed
    Figure\protect~\protect\ref{forward-sequence-introduction-example-figure} to
    include all nodes reachable from the start of a method}
  \changed{
  \begin{circus}
    Running \circdef \\
    \t1 \circif frameStack = \emptyset \circthen \Skip \\
    \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
    \t2 \circif pc = 0 \circthen HandleAloadEPC(0) \circseq pc := 1 \circseq Poll \circseq HandleAloadEPC(1) \circseq  pc := 2 \circseq Poll \circseq \\
    \t3 HandleAloadEPC(2) \circseq pc := 3 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 5 \circseq Poll \circseq \\
    \t3 \{ pc = 5 \} \circseq HandleInvokespecialEPC(8) \\
    \t2 {} \cdots {} \\
    % \t2 {} \circelse pc = 1 \circthen HandleAloadEPC(1) \circseq pc := 2 \\
    % \t2 {} \circelse pc = 2 \circthen HandleAloadEPC(2) \circseq pc := 3 \\
    % \t2 {} \circelse pc = 3 \circthen HandleAloadEPC(3) \circseq pc := 4 \\
    % \t2 {} \circelse pc = 4 \circthen HandleAloadEPC(4) \circseq pc := 5 \\
    % \t2 {} \circelse pc = 5 \circthen HandleInvokespecialEPC(8) \\
    \t2 {} \circelse pc = 6 \circthen HandleReturnEPC \\
    \t2 {} \circelse pc = 7 \circthen HandleNewEPC(27) \circseq pc := 8 \circseq Poll \circseq HandleDupEPC \circseq pc := 9 \circseq Poll \circseq \\
    \t3 HandleAconst\_nullEPC \circseq pc := 10 \circseq Poll \circseq \{ pc = 10 \} \circseq HandleInvokespecialEPC(29) \\
    \t2 {} \cdots {} \\
    % \t2 {} \circelse pc = 8 \circthen HandleDupEPC \circseq pc := 9 \\
    % \t2 {} \circelse pc = 9 \circthen HandleAconst\_nullEPC \circseq pc := 10 \\
    % \t2 {} \circelse pc = 10 \circthen HandleInvokespecialEPC(29) \\
    \t2 {} \circelse pc = 11 \circthen HandleAstoreEPC(1) \circseq pc := 12 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 13 \circseq Poll \circseq \\
    \t3 \{pc = 13\} \circseq HandleInvokevirtualEPC(32) \\
    \t2 {} \cdots {} \\
    % \t2 {} \circelse pc = 12 \circthen HandleAloadEPC(1) \circseq pc := 13 \\
    % \t2 {} \circelse pc = 13 \circthen HandleInvokevirtualEPC(32) \\
    \t2 {} \circelse pc = 14 \circthen HandleAstoreEPC(2) \circseq pc := 15 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 16 \circseq Poll \circseq \\
    \t3 \{ pc = 16 \} \circseq HandleInvokevirtualEPC(36) \\
    \t2 {} \cdots {} \\
    % \t2 {} \circelse pc = 15 \circthen HandleAloadEPC(1) \circseq pc := 16 \\
    % \t2 {} \circelse pc = 16 \circthen HandleInvokevirtualEPC(36) \\
    \t2 {} \circelse pc = 17 \circthen HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq pc := 19 \circseq Poll \circseq \\
    \t3 HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \\
    \t2 {} \cdots {} \\
    % \t2 {} \circelse pc = 18 \circthen HandleIconstEPC(0) \circseq pc := 19 \\
    % \t2 {} \circelse pc = 19 \circthen HandleAstoreEPC(4) \circseq pc := 20 \\
    % \t2 {} \circelse pc = 20 \circthen pc := 39 \\
    \t2 {} \circelse pc = 21 \circthen HandleAloadEPC(2) \circseq pc := 22 \circseq Poll \circseq \{pc = 22\} \circseq HandleInvokevirtualEPC(40) \\
    % \t2 {} \circelse pc = 22 \circthen HandleInvokevirtualEPC(40) \\
    \t2 {} \cdots {} \\
    \t2 {} \circelse pc = 23 \circthen HandleInvokestaticEPC(46) \\
    \t2 {} \circelse pc = 24 \circthen HandleAstoreEPC(5) \circseq pc := 25 \circseq Poll \circseq HandleAloadEPC(5) \circseq pc := 26 \circseq Poll \circseq \\
    \t3 HandleIconstEPC(400) \circseq pc := 27 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    \t3 pc := \IF value1 \leq value2 \THEN 32 \ELSE 28 \\
    % \t2 {} \circelse pc = 25 \circthen HandleAloadEPC(5) \circseq pc := 26 \\
    % \t2 {} \circelse pc = 26 \circthen HandleIconstEPC(400) \circseq pc := 27 \\
    % \t2 {} \circelse pc = 27 \circthen \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 32 \ELSE 28 \\
    \t2 {} \circelse pc = 28 \circthen HandleAloadEPC(3) \circseq pc := 29 \circseq Poll \circseq HandleIconstEPC(0) \circseq pc := 30 \circseq Poll \circseq \\
    \t3 \{ pc = 30 \} \circseq HandleInvokevirtualEPC(50) \\
    % \t2 {} \circelse pc = 29 \circthen HandleIconstEPC(0) \circseq pc := 30 \\
    % \t2 {} \circelse pc = 30 \circthen HandleInvokevirtualEPC(50) \\
    \t2 {} \cdots {} \\ 
    \t2 {} \circelse pc = 31 \circthen pc := 35 \\
    \t2 {} \circelse pc = 32 \circthen HandleAloadEPC(3) \circseq pc := 33 \circseq Poll \circseq HandleAloadEPC(5) \circseq \\
    \t3 pc := 34 \circseq Poll \circseq \{pc = 34\} \circseq HandleInvokevirtualEPC(50) \\
    \t2 {} \cdots {} \\
    % \t2 {} \circelse pc = 33 \circthen HandleAloadEPC(5) \circseq pc := 34 \\
    % \t2 {} \circelse pc = 34 \circthen HandleInvokevirtualEPC(50) \\
    \t2 {} \circelse pc = 35 \circthen HandleAloadEPC(4) \circseq pc := 36 \circseq Poll \circseq HandleIconstEPC(1) \circseq pc := 37 \circseq Poll \circseq \\
    \t3 HandleIaddEPC \circseq pc := 38 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 39 \\
    \t2 {} \cdots {} \\
    % \t2 {} \circelse pc = 36 \circthen HandleIconstEPC(1) \circseq pc := 37 \\
    % \t2 {} \circelse pc = 37 \circthen HandleIaddEPC \circseq pc := 38 \\
    % \t2 {} \circelse pc = 38 \circthen HandleAstoreEPC(4) \circseq pc := 39 \\
    \t2 {} \circelse pc = 39 \circthen HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq  pc := 41 \circseq Poll \circseq \\
    \t3 \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    \t2 {} \cdots {} \\
    % \t2 {} \circelse pc = 40 \circthen HandleIconstEPC(10) \circseq pc := 41 \\
    % \t2 {} \circelse pc = 41 \circthen \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    \t2 {} \circelse pc = 42 \circthen HandleReturnEPC \\
    \t2 {} \circelse pc = 43 \circthen HandleAloadEPC(0) \circseq pc := 44 \circseq Poll \circseq HandleAloadEPC(0) \circseq pc := 45 \circseq Poll \circseq \\
    \t3 HandleIaddEPC \circseq pc := 46 \circseq Poll \circseq HandleAloadEPC(0) \circseq pc := 47 \circseq Poll \circseq  HandleIaddEPC \circseq \\
    \t3 pc := 48 \circseq Poll \circseq HandleIaddEPC \circseq pc := 50 \circseq Poll \circseq HandleAreturnEPC \\
    \t2 {} \cdots {} \\
    % \t2 {} \circelse pc = 44 \circthen HandleAloadEPC(0) \circseq pc := 45 \\
    % \t2 {} \circelse pc = 45 \circthen HandleIaddEPC \circseq pc := 46 \\
    % \t2 {} \circelse pc = 46 \circthen HandleAloadEPC(0) \circseq pc := 47 \\
    % \t2 {} \circelse pc = 47 \circthen HandleIaddEPC \circseq pc := 48 \\
    % \t2 {} \circelse pc = 48 \circthen HandleIconstEPC(5) \circseq pc := 49 \\
    % \t2 {} \circelse pc = 49 \circthen HandleIaddEPC \circseq pc := 50 \\
    % \t2 {} \circelse pc = 50 \circthen HandleAreturnEPC \\
    \t2 \circfi \circseq Poll \circseq Running \\
    \t1 \circfi
  \end{circus}
  }
  \caption{The $Running$ action after forward sequence introduction}
  \label{forward-sequence-introduction-example-figure}
\end{figure}

Applying the bytecode expansion on
line~\ref{algorithm-expand-bytecode} of Algorithm~\ref{epc-algorithm}
yields the $Running$ action shown in
Figure~\ref{bytecode-expansion-example-figure}.
This step copies $HandleInstruction$ into $Running$, and converts it
to a choice of actions based on the value of the program counter,
$pc$, mirroring the contents of the $bc$ map for each value.

The actions that make up $HandleInstruction$ are also replaced with
actions that incorporate instruction parameters from the $bc$ map, and
have $pc$ updates separated from stack updates.
This can be seen in Figure~\ref{bytecode-expansion-example-figure},
where, for instance, in the $pc = 0$ case, $aload~0$ has been
converted to $HandleAloadEPC(0) \circseq pc := 1$, with the parameter,
$0$, to the bytecode instruction becoming a parameter of the new
instruction handling action $HandleAloadEPC$, and the update to $pc$
placed after the data operation.

The reason for making parameters of the bytecode instructions into
parameters of the handling actions is to remove the need to reference
the bytecode instructions in the $bc$ map, as that involves use of the
$pc$ value, which we seek to remove in this stage.
This also has the benefit of fully incorporating $bc$ into the $Thr$
process, ensuring all the information required to introduce C code
constructs is available directly in \Circus{}.
This makes stating compilation laws simpler, and is described in more
detail in Section~\ref{expand-bytecode-subsection}, where we define
the \Call{ExpandBytecode}{} procedure.

On line~\ref{algorithm-introduce-forward-sequence} of the
Algorithm~\ref{epc-algorithm}, sequential composition is introduced
for instructions that do not affect the sequential flow of the
program.
Such instructions are identified by considering the control flow graph
of the program and locating nodes with a single outgoing edge going to
a target node with exactly one incoming edge.
The introduction of sequential composition is performed by unrolling
the loop in $Running$ to introduce the control flow following each of
these instructions.
This causes the instruction to be sequentially composed with the next
instruction, with $Poll$ inbetween to allow for thread switches
between instructions.
This is performed exhaustively to get the code in the form shown in
Figure~\ref{forward-sequence-introduction-example-figure}, where the
choice over $pc$ has sequences of instructions collected together at
the point where they start, up to the point at which a more complex
control flow (such as a method call, conditional or a loop) occurs.
\addchange{Clarified why some branches in figures are not shown}
\added{
In this figure, and the other figures in this chapter, we omit the
branches of the choice in $Running$ that cannot be reached from the
start of a method, since the instructions in those branches are
collected into other branches.
}
The introduction of sequential composition is described in more detail
in Section~\ref{introduce-forward-sequence-subsection}, where we
define the \Call{IntroduceSequentialComposition}{} procedure.

Handling the remaining constructs requires consideration of
dependencies between methods to ensure method calls can be resolved
correctly.
We say a method call is \emph{resolved} when the method invocation
bytecode has been placed in sequential composition with a call to a
\Circus{} action containing the body of the method being invoked,
which is then followed by the sequence of instructions that occurs
after the invocation bytecode in the calling method.
After a method call has been resolved, it no longer breaks up the
sequence of instructions it occurs in.
%TODO: clarify this

Since we have the bytecode instructions of all the methods needed, we
can always resolve the call of a complete method, provided that method
has already been split into its own \Circus{} action.
To obtain a complete method, we first perform loop and conditional
introduction upon the method.
Since introducing loops and conditionals requires unbroken sequences
of instructions that form the bodies of the loops and the branches of
conditionals, introduction of loops and conditionals can only be
performed on methods that have no unresolved method calls.

\begin{figure}[tp!]
  \setlength{\zedindent}{0cm}
  \setlength{\zedtab}{0.3cm}
  \setlength{\zedleftsep}{0cm}
  \setlength{\abovedisplayskip}{0cm}
  \setlength{\belowdisplayskip}{0cm}
  \addchange{Changed
    Figure\protect~\protect\ref{loop-and-conditional-introduction-example-figure} to
    include all the instructions in each block}
  \changed{
  \scriptsize
  \begin{circus}
    Running \circdef \\
    \t1 \circif frameStack = \emptyset \circthen \Skip \\
    \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
    \t2 {} \circif pc = 0 \circthen HandleAloadEPC(0) \circseq pc := 1 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 2 \circseq Poll \circseq \\
    \t3 HandleAloadEPC(2) \circseq pc := 3 \circseq Poll \circseq HandleAloadEPC(3) \circseq pc := 4 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 5 \circseq \\
    \t3 Poll \circseq (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop?  == 6 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    \t3 \lschexpract InterpreterNewStackFrame[AperiodicEventHandler/class?, APEHinit/methodID?, poppedArgs/methodArgs?] \rschexpract \circseq \\
    \t3 Poll \circseq AperiodicEventHandler\_APEHinit) \circseq pc := 6 \circseq Poll \circseq HandleReturnEPC \\
    \t2 {} \cdots {} \\
    \t2 {} \circelse pc = 7 \circthen HandleNewEPC(27) \circseq pc := 8 \circseq Poll \circseq HandleDupEPC \circseq pc := 9 \circseq  Poll \circseq HandleAconst\_nullEPC \circseq \\
    \t3 pc := 10 \circseq Poll \circseq (\circvar poppedArgs : Word \circspot  \lschexpract \exists argsToPop? == 2 @ InterpreterStackFrameInvokeEPC \rschexpract \circseq \\
    \t3 \lschexpract InterpreterNewStackFrame[ConsoleConnection/class?, CCinit/methodID?] \rschexpract \circseq Poll \circseq \\
    \t3 ConsoleConnection\_CCinit) \circseq pc := 11 \circseq Poll \circseq HandleAstoreEPC(1) \circseq pc := 12 \circseq Poll \circseq \\
    \t3 HandleAloadEPC(1) \circseq pc := 13 \circseq Poll \circseq (\circvar poppedArgs : Word \circspot \\
    \t3 \lschexpract \exists argsToPop? == 1 @ InterpreterStackFrameInvokeEPC \rschexpract \circseq getClassIDOf!head~poppedArgs?cid \then {} \\
    \t3 \circif cid = ConsoleConnectionID \circthen {} \\
    \t4 \lschexpract InterpreterNewStackFrame[ConsoleConnection/class?, openInputStream/methodID?] \rschexpract \circseq \\
    \t4 Poll \circseq ConsoleConnection\_openInputStream \\
    \t3 \circfi) \circseq pc := 14 \circseq Poll \circseq HandleAstoreEPC(2) \circseq pc := 15 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 16 \circseq Poll \circseq \\
    \t3 (\circvar poppedArgs : Word \circspot \lschexpract \exists argsToPop? == 1 @ InterpreterStackFrameInvokeEPC \rschexpract \circseq \\
    \t3 getClassIDOf!head~poppedArgs?cid \then \circif cid = ConsoleConnectionID \circthen {} \\
    \t4 \lschexpract InterpreterNewStackFrame[ConsoleConnection/class?, openOutputStream/methodID?] \rschexpract \circseq Poll \circseq \\
    \t4 ConsoleConnection\_openOutputStream \\
    \t3 \circfi) \circseq pc := 17 \circseq Poll \circseq HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq pc := 19 \circseq Poll \circseq \\
    \t3 HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq (\circmu Y \circspot \\
    \t4 HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq  pc := 41 \circseq Poll \circseq \\
    \t4 (\circvar value1, value2 : Word \circspot InterpreterPop2EPC \\
    \t4 \circif value1 \leq value2 \circthen pc := 21 \circseq Poll \circseq HandleAloadEPC(2) \circseq pc := 22 \circseq Poll \circseq \\
    \t5 (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop?  == 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    \t5 getClassIDOf!(head~poppedArgs)?cid \then \circif cid = ConsoleInputClassID \circthen {} \\
    \t6 \lschexpract InterpreterNewStackFrame[ ConsoleInput/class?, read/methodID?, poppedArgs/methodArgs?] \rschexpract \circseq \\
    \t6 Poll \circseq ConsoleInput\_read \\
    \t5 \circfi) \circseq pc := 23 \circseq Poll \circseq (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop? == 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    \t5 \lschexpract InterpreterNewStackFrame[TPK/class?, f/methodID?, poppedArgs/methodArgs?] \rschexpract \circseq Poll \circseq TPK\_f) \circseq \\
    \t5 pc := 24 \circseq Poll \circseq HandleAstoreEPC(5) \circseq pc := 25 \circseq Poll \circseq HandleAloadEPC(5) \circseq pc := 26 \circseq \\
    \t5 HandleIconstEPC(400) \circseq pc := 27 \circseq Poll \circseq (\circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    \t5 \circif value1 \leq value2 \circthen pc := 32 \circseq HandleAloadEPC(3) \circseq pc := 33 \circseq Poll \circseq HandleAloadEPC(5) \circseq pc := 34 \circseq \\
    \t6 Poll \circseq (\circvar poppedArgs : Word \circspot \lschexpract \exists argsToPop? == 2 @ InterpreterStackFrameInvokeEPC \rschexpract \circseq \\
    \t6 getClassIDOf!head~poppedArgs?cid \then \circif cid = ConsoleOutputID \circthen {} \\
    \t7 \lschexpract InterpreterNewStackFrame[ConsoleOutput/class?, write/methodID?] \rschexpract \circseq  Poll \circseq ConsoleOutput\_write \\
    \t6 \circfi) \\
    \t5 {} \circelse value1 > value2 \circthen pc := 28 \circseq HandleAloadEPC(3) \circseq pc := 29 \circseq Poll \circseq HandleIconstEPC(0) \circseq pc := 30 \circseq \\
    \t6 Poll \circseq (\circvar poppedArgs : Word \circspot \lschexpract \exists argsToPop? == 2 @ InterpreterStackFrameInvokeEPC \rschexpract \circseq \\
    \t6 getClassIDOf!head~poppedArgs?cid \then \circif cid = ConsoleOutputID \circthen {} \\
    \t7 \lschexpract InterpreterNewStackFrame[ConsoleOutput/class?, write/methodID?] \rschexpract \circseq  Poll \circseq ConsoleOutput\_write \\
    \t6 \circfi) \circseq pc := 31 \circseq Poll \\
    \t5 \circfi) \circseq pc := 35 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 36 \circseq Poll \circseq HandleIconstEPC(1) \circseq pc := 37 \circseq Poll \circseq \\
    \t5 HandleIaddEPC \circseq pc := 38 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 39 \circseq Poll \circseq Y \\
    \t4 {} \circelse value1 > value2 \circthen \Skip \\
    \t4 \circfi)) \circseq pc := 42 \circseq Poll \circseq HandleReturnEPC \\
    \t2 {} \cdots {} \\
    \t2 {} \circelse pc = 43 \circthen TPK\_f \\
    \t2 {} \cdots {} \\
    \t2 \circfi) \circseq Poll \circseq Running \\
    \t1 \circfi
  \end{circus}
  }
  \caption{The $Running$ action after loop and conditional introduction}
  \label{loop-and-conditional-introduction-example-figure}
\end{figure}

In our example, \texttt{handleAsyncEvent()} is the only method that
needs loops and conditionals introducing but, since it also contains
method calls that break up the body of a loop, we must wait until its
method calls have been resolved before introducing loops and
conditionals.
For this reason, we perform method call resolution, and loop and
conditional introduction repeatedly until all method calls are
resolved and the resulting complete methods have all been separated
out.
This is expressed in Algorithm~\ref{epc-algorithm} by the while loop
on line~\ref{algorithm-method-loop}.

Introduction of loops and conditionals to the body of a method with no
unresolved method calls occurs on
line~\ref{algorithm-introduce-loops-and-conditionals} of the
algorithm.
To introduce loops and conditionals we consider the control flow graph
of the method again, though it is now much simpler than the control
flow graph used for sequence introduction, since straight sequences of
instructions have already been combined together.
Patterns representing conditionals and loops are then identified using
the control flow graph and the corresponding constructs are
introduced.
As loops and conditionals are introduced, nodes in the control flow
graph are merged until the graph consists of a single node, which is
the starting point of the method, containing the complete method body.

The result of introducing loops and conditionals in
\texttt{handleAsyncEvent()} after method call resolution is shown in
Figure~\ref{loop-and-conditional-introduction-example-figure}.
The process of introducing loops and conditionals is described in more
detail in Section~\ref{introduce-loops-and-conditionals-subsection},
where we define the \Call{IntroduceLoopsAndConditionals}{} procedure.

After loops and conditionals have been introduced, methods that are
then complete can be copied into separate actions.
This occurs in line~\ref{algorithm-separate-complete-methods} of this
algorithm.
It is done with a simple application of the copy rule, replacing the
actions at the entry points of the split methods with references to
newly created method actions.
This can be seen in Figure~\ref{TPK_f-separation-example-figure},
where the $TPK\_f$ action has been created by copying the sequence of
actions for the \texttt{f()} method of \texttt{TPK} from the $pc = 43$
case of Figure~\ref{forward-sequence-introduction-example-figure}.
\addchange{Added mention of reference to $TPK\protect\_f$ shown earlier in
  Figure\protect~\protect\ref{loop-and-conditional-introduction-example-figure}}
\added{The $pc = 43$ branch itself is replaced with a reference to this
$TPK\_f$ action, as can be seen in
Figure~\ref{loop-and-conditional-introduction-example-figure}.}
As this step is relatively simple, we do not explain it in a separate
section.
\begin{figure}[tp!]
  \setlength{\zedindent}{0cm}
  \setlength{\zedtab}{0.3cm}
  \setlength{\zedleftsep}{0cm}
  \setlength{\abovedisplayskip}{0cm}
  \setlength{\belowdisplayskip}{0cm}
  \addchange{Moved $TPK\protect\_f$ action to its own figure}
  \moved{
  \begin{circus}
    TPK\_f \circdef HandleAloadEPC(0) \circseq pc := 44 \circseq Poll \circseq HandleAloadEPC(0) \circseq pc := 45 \circseq Poll \circseq \\
    \t1 HandleIaddEPC \circseq pc := 46 \circseq Poll \circseq HandleAloadEPC(0) \circseq pc := 47 \circseq Poll \circseq \\
    \t1 HandleIaddEPC \circseq pc := 48 \circseq Poll \circseq HandleIconstEPC(5) \circseq pc := 49 \circseq Poll \circseq \\
    HandleIaddEPC \circseq pc := 50 \circseq Poll \circseq HandleAreturnEPC
  \end{circus}
  }
  \added{
  \caption{The $TPK\_f$ method action after it has been separated}  
  \label{TPK_f-separation-example-figure}
  }
\end{figure}

\begin{figure}[tp!]
  \setlength{\zedindent}{0cm}
  \setlength{\zedtab}{0.3cm}
  \setlength{\zedleftsep}{0cm}
  \setlength{\abovedisplayskip}{0cm}
  \setlength{\belowdisplayskip}{0cm}
  \addchange{Changed
    Figure\protect~\protect\ref{method-call-resolution-example-figure} to
    include the full content of all nodes reachable from the start of
    a method}
  \changed{
  \scriptsize
  \begin{circus}
    Running \circdef \\
    \t1 \circif frameStack = \emptyset \circthen \Skip \\
    \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
    \t2 {} \circif pc = 0 \circthen HandleAloadEPC(0) \circseq pc := 1 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 2 \circseq Poll \circseq \\
    \t3 HandleAloadEPC(2) \circseq pc := 3 \circseq Poll \circseq HandleAloadEPC(3) \circseq pc := 4 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 5 \circseq \\
    \t3 Poll \circseq (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop?  == 6 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    \t3 \lschexpract InterpreterNewStackFrame[AperiodicEventHandler/class?, APEHinit/methodID?, poppedArgs/methodArgs?] \rschexpract \circseq \\
    \t3 Poll \circseq AperiodicEventHandler\_APEHinit) \circseq pc := 6 \circseq Poll \circseq HandleReturnEPC \\
    \t2 {} \cdots {} \\
    % \t2 {} \circelse pc = 1 \circthen HandleAloadEPC(1) \circseq pc := 2 \circseq Poll \circseq HandleAloadEPC(2) \circseq pc := 3 \circseq \\
    % \t3 Poll \circseq HandleAloadEPC(3) \circseq pc := 4 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 5 \circseq \\
    % \t3 Poll \circseq HandleInvokespecialEPC(8) \circseq Poll \circseq APEHInit \circseq Poll \circseq HandleReturnEPC \\
    % \t2 {} \circelse pc = 2 \circthen HandleAloadEPC(2) \circseq pc := 3 \circseq Poll \circseq HandleAloadEPC(3) \circseq pc := 4 \circseq \\
    % \t3 Poll \circseq HandleAloadEPC(4) \circseq pc := 5 \circseq Poll \circseq HandleInvokespecialEPC(8) \circseq \\
    % \t3 Poll \circseq APEHInit \circseq Poll \circseq HandleReturnEPC \\
    % \t2 {} \circelse pc = 3 \circthen HandleAloadEPC(3) \circseq pc := 4 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 5 \circseq \\
    % \t3 Poll \circseq HandleInvokespecialEPC(8) \circseq Poll \circseq APEHInit \circseq Poll \circseq HandleReturnEPC \\
    % \t2 {} \circelse pc = 4 \circthen HandleAloadEPC(4) \circseq pc := 5 \circseq Poll \circseq HandleInvokespecialEPC(8) \circseq \\
    % \t3 Poll \circseq APEHInit \circseq Poll \circseq HandleReturnEPC \\
    % \t2 {} \circelse pc = 5 \circthen HandleInvokespecialEPC(8) \circseq Poll \circseq APEHInit \circseq Poll \circseq HandleReturnEPC \\
    % \t2 {} \circelse pc = 6 \circthen HandleReturnEPC \\
    \t2 {} \circelse pc = 7 \circthen HandleNewEPC(27) \circseq pc := 8 \circseq Poll \circseq HandleDupEPC \circseq pc := 9 \circseq  Poll \circseq HandleAconst\_nullEPC \circseq \\
    \t3 pc := 10 \circseq Poll \circseq (\circvar poppedArgs : Word \circspot  \lschexpract \exists argsToPop? == 2 @ InterpreterStackFrameInvokeEPC \rschexpract \circseq \\
    \t3 \lschexpract InterpreterNewStackFrame[ConsoleConnection/class?, CCinit/methodID?] \rschexpract \circseq Poll \circseq \\
    \t3 ConsoleConnection\_CCinit) \circseq pc := 11 \circseq Poll \circseq HandleAstoreEPC(1) \circseq pc := 12 \circseq Poll \circseq \\
    \t3 HandleAloadEPC(1) \circseq pc := 13 \circseq Poll \circseq (\circvar poppedArgs : Word \circspot \\
    \t3 \lschexpract \exists argsToPop? == 1 @ InterpreterStackFrameInvokeEPC \rschexpract \circseq getClassIDOf!head~poppedArgs?cid \then {} \\
    \t3 \circif cid = ConsoleConnectionID \circthen {} \\
    \t4 \lschexpract InterpreterNewStackFrame[ConsoleConnection/class?, openInputStream/methodID?] \rschexpract \circseq \\
    \t4 Poll \circseq ConsoleConnection\_openInputStream \\
    \t3 \circfi) \circseq pc := 14 \circseq Poll \circseq HandleAstoreEPC(2) \circseq pc := 15 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 16 \circseq Poll \circseq \\
    \t3 (\circvar poppedArgs : Word \circspot \lschexpract \exists argsToPop? == 1 @ InterpreterStackFrameInvokeEPC \rschexpract \circseq \\
    \t3 getClassIDOf!head~poppedArgs?cid \then \circif cid = ConsoleConnectionID \circthen {} \\
    \t4 \lschexpract InterpreterNewStackFrame[ConsoleConnection/class?, openOutputStream/methodID?] \rschexpract \circseq Poll \circseq \\
    \t4 ConsoleConnection\_openOutputStream \\
    \t3 \circfi) \circseq pc := 17 \circseq Poll \circseq HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq pc := 19 \circseq Poll \circseq \\
    \t3 HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \\
    % \t2 {} \cdots {} \\
    % \t2 {} \circelse pc = 8 \circthen HandleDupEPC \circseq pc := 9 \circseq Poll \circseq HandleAconst\_nullEPC \circseq pc := 10 \circseq \\
    % \t3 Poll \circseq HandleInvokespecialEPC(29) \circseq Poll \circseq CCInit \circseq Poll \circseq HandleAstoreEPC(1) \circseq \\
    % \t3 pc := 12 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 13 \circseq Poll \circseq \\
    % \t3 HandleInvokevirtualEPC(32) \circseq Poll \circseq OpenInputStream \circseq Poll \circseq HandleAstoreEPC(2) \circseq \\
    % \t3 pc := 15 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 16 \circseq Poll \circseq HandleInvokevirtualEPC(36) \circseq Poll \circseq OpenOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq \\
    % \t3 pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq \\
    % \t3 HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq \\
    % \t3 Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 9 \circthen HandleAconst\_nullEPC \circseq pc := 10 \circseq Poll \circseq HandleInvokespecialEPC(29) \circseq Poll \circseq CCInit \circseq Poll \circseq HandleAstoreEPC(1) \circseq pc := 12 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 13 \circseq Poll \circseq HandleInvokevirtualEPC(32) \circseq Poll \circseq OpenInputStream \circseq Poll \circseq HandleAstoreEPC(2) \circseq pc := 15 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 16 \circseq Poll \circseq HandleInvokevirtualEPC(36) \circseq Poll \circseq OpenOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq \\
    % \t3 pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq \\
    % \t3 HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq \\
    % \t3 Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 10 \circthen HandleInvokespecialEPC(29) \circseq Poll \circseq CCInit \circseq Poll \circseq HandleAstoreEPC(1) \circseq pc := 12 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 13 \circseq Poll \circseq HandleInvokevirtualEPC(32) \circseq Poll \circseq OpenInputStream \circseq Poll \circseq HandleAstoreEPC(2) \circseq pc := 15 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 16 \circseq Poll \circseq HandleInvokevirtualEPC(36) \circseq Poll \circseq OpenOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq \\
    % \t3 pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq \\
    % \t3 HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq \\
    % \t3 Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 11 \circthen HandleAstoreEPC(1) \circseq pc := 12 \circseq Poll \circseq HandleAloadEPC(1) \circseq \\
    % \t3 pc := 13 \circseq Poll \circseq HandleInvokevirtualEPC(32) \circseq Poll \circseq OpenInputStream \circseq Poll \circseq HandleAstoreEPC(2) \circseq pc := 15 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 16 \circseq Poll \circseq HandleInvokevirtualEPC(36) \circseq Poll \circseq OpenOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq \\
    % \t3 pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq \\
    % \t3 HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq \\
    % \t3 Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 12 \circthen HandleAloadEPC(1) \circseq pc := 13 \circseq Poll \circseq HandleInvokevirtualEPC(32) \circseq Poll \circseq OpenInputStream \circseq Poll \circseq HandleAstoreEPC(2) \circseq pc := 15 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 16 \circseq Poll \circseq HandleInvokevirtualEPC(36) \circseq Poll \circseq OpenOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq \\
    % \t3 pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq \\
    % \t3 HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq \\
    % \t3 Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 13 \circthen HandleInvokevirtualEPC(32) \circseq Poll \circseq OpenInputStream \circseq Poll \circseq HandleAstoreEPC(2) \circseq pc := 15 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 16 \circseq Poll \circseq HandleInvokevirtualEPC(36) \circseq Poll \circseq OpenOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq \\
    % \t3 pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq \\
    % \t3 HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq \\
    % \t3 Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 14 \circthen HandleAstoreEPC(2) \circseq pc := 15 \circseq Poll \circseq HandleAloadEPC(1) \circseq \\
    % \t3 pc := 16 \circseq Poll \circseq HandleInvokevirtualEPC(36) \circseq Poll \circseq OpenOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq \\
    % \t3 pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq \\
    % \t3 HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq \\
    % \t3 Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 15 \circthen HandleAloadEPC(1) \circseq pc := 16 \circseq Poll \circseq HandleInvokevirtualEPC(36) \circseq Poll \circseq OpenOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq \\
    % \t3 pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq \\
    % \t3 HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq \\
    % \t3 Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 16 \circthen HandleInvokevirtualEPC(36) \circseq Poll \circseq OpenOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq \\
    % \t3 pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq \\
    % \t3 HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq \\
    % \t3 Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 17 \circthen HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq \\
    % \t3 pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq \\
    % \t3 HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq \\
    % \t3 Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 18 \circthen HandleIconstEPC(0) \circseq pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 19 \circthen HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 20 \circthen pc := 39 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    \t2 {} \circelse pc = 21 \circthen HandleAloadEPC(2) \circseq pc := 22 \circseq Poll \circseq (\circvar poppedArgs : \seq Word \circspot \\
    \t3 \lschexpract \exists argsToPop?  == 1 @ InterpreterStackFrameInvoke \rschexpract \circseq getClassIDOf!(head~poppedArgs)?cid \then {} \\
    \t3 \circif cid = ConsoleInputClassID \circthen {} \\
    \t4 \lschexpract InterpreterNewStackFrame[ ConsoleInput/class?, read/methodID?, poppedArgs/methodArgs?] \rschexpract \circseq \\
    \t4 Poll \circseq ConsoleInput\_read \\
    \t3 \circfi) \circseq pc := 23 \circseq Poll \circseq (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop? == 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    \t3 \lschexpract InterpreterNewStackFrame[TPK/class?, f/methodID?, poppedArgs/methodArgs?] \rschexpract \circseq Poll \circseq TPK\_f) \circseq pc := 24 \circseq \\
    \t3 Poll \circseq HandleAstoreEPC(5) \circseq pc := 25 \circseq Poll \circseq HandleAloadEPC(5) \circseq pc := 26 \circseq HandleIconstEPC(400) \circseq \\
    \t3 pc := 27 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2EPC \circseq pc := \IF value1 \leq value2 \THEN 32 \ELSE 28 \\
    % \t2 {} \cdots {} \\
    % \t2 {} \circelse pc = 22 \circthen HandleInvokevirtualEPC(40) \circseq Poll \circseq Read \circseq Poll \circseq HandleInvokestaticEPC(46) \circseq Poll \circseq F \circseq Poll \circseq HandleAstoreEPC(5) \circseq pc := 25 \circseq Poll \circseq HandleAloadEPC(5) \circseq pc := 26 \circseq HandleIconstEPC(400) \circseq pc := 27 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq pc := \IF value1 \leq value2 \THEN 32 \ELSE 28 \\
    % \t2 {} \circelse pc = 23 \circthen HandleInvokestaticEPC(46) \circseq Poll \circseq F \circseq Poll \circseq HandleAstoreEPC(5) \circseq pc := 25 \circseq Poll \circseq HandleAloadEPC(5) \circseq pc := 26 \circseq HandleIconstEPC(400) \circseq pc := 27 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq pc := \IF value1 \leq value2 \THEN 32 \ELSE 28 \\
    % \t2 {} \circelse pc = 24 \circthen HandleAstoreEPC(5) \circseq pc := 25 \circseq Poll \circseq HandleAloadEPC(5) \circseq pc := 26 \circseq HandleIconstEPC(400) \circseq pc := 27 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq pc := \IF value1 \leq value2 \THEN 32 \ELSE 28 \\
    % \t2 {} \circelse pc = 25 \circthen HandleAloadEPC(5) \circseq pc := 26 \circseq Poll \circseq HandleIconstEPC(400) \circseq pc := 27 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq pc := \IF value1 \leq value2 \THEN 32 \ELSE 28 \\
    % \t2 {} \circelse pc = 26 \circthen HandleIconstEPC(400) \circseq pc := 27 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq pc := \IF value1 \leq value2 \THEN 32 \ELSE 28 \\
    % \t2 {} \circelse pc = 27 \circthen \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 32 \ELSE 28 \\
    \t2 {} \circelse pc = 28 \circthen HandleAloadEPC(3) \circseq pc := 29 \circseq Poll \circseq HandleIconstEPC(0) \circseq pc := 30 \circseq Poll \circseq \\
    \t3 (\circvar poppedArgs : Word \circspot \lschexpract \exists argsToPop? == 2 @ InterpreterStackFrameInvokeEPC \rschexpract \circseq \\
    \t3 getClassIDOf!head~poppedArgs?cid \then \circif cid = ConsoleOutputID \circthen {} \\
    \t4 \lschexpract InterpreterNewStackFrame[ConsoleOutput/class?, write/methodID?] \rschexpract \circseq  Poll \circseq ConsoleOutput\_write \\
    \t3 \circfi) \circseq pc := 31 \circseq Poll \circseq pc := 35 \\
    % \t2 {} \circelse pc = 29 \circthen HandleIconstEPC(0) \circseq pc := 30 \circseq Poll \circseq HandleInvokevirtualEPC(50) \circseq Poll \circseq Write \circseq Poll \circseq pc := 38 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 39 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 30 \circthen HandleInvokevirtualEPC(50) \circseq Poll \circseq Write \circseq Poll \circseq pc := 38 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 39 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 31 \circthen pc := 38 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 39 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    \t2 {} \circelse pc = 32 \circthen HandleAloadEPC(3) \circseq pc := 33 \circseq Poll \circseq HandleAloadEPC(5) \circseq pc := 34 \circseq Poll \circseq \\
    \t3 (\circvar poppedArgs : Word \circspot \lschexpract \exists argsToPop? == 2 @ InterpreterStackFrameInvokeEPC \rschexpract \circseq \\
    \t3 getClassIDOf!head~poppedArgs?cid \then \circif cid = ConsoleOutputID \circthen {} \\
    \t4 \lschexpract InterpreterNewStackFrame[ConsoleOutput/class?, write/methodID?] \rschexpract \circseq  Poll \circseq ConsoleOutput\_write \\
    \t3 \circfi) \circseq pc := 35 \\
    % \t2 {} \circelse pc = 33 \circthen HandleAloadEPC(5) \circseq pc := 34 \\
    % \t2 {} \circelse pc = 34 \circthen HandleInvokevirtualEPC(50) \\
    \t2 {} \circelse pc = 35 \circthen HandleAloadEPC(4) \circseq pc := 36 \circseq Poll \circseq HandleIconstEPC(1) \circseq pc := 37 \circseq Poll \circseq \\
    \t3 HandleIaddEPC \circseq pc := 38 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 39 \\
    % \t2 {} \circelse pc = 36 \circthen HandleIconstEPC(1) \circseq pc := 37 \\
    % \t2 {} \circelse pc = 37 \circthen HandleIaddEPC \circseq pc := 38 \\
    % \t2 {} \circelse pc = 38 \circthen HandleAstoreEPC(4) \circseq pc := 39 \\
    \t2 {} \circelse pc = 39 \circthen HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq  pc := 41 \circseq Poll \circseq \\
    \t3 \circvar value1, value2 : Word \circspot InterpreterPop2EPC \circseq pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 \t2 {} \circelse pc = 40 \circthen HandleIconstEPC(10) \circseq pc := 41 \\
    % \t2 {} \circelse pc = 41 \circthen \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    \t2 {} \circelse pc = 42 \circthen HandleReturnEPC \\
    \t2 {} \cdots {} \\
    \t2 {} \circelse pc = 43 \circthen TPK\_f \\
    \t2 {} \cdots {} \\
    % \t2 {} \circelse pc = 44 \circthen HandleAloadEPC(0) \circseq pc := 45 \\
    % \t2 {} \circelse pc = 45 \circthen HandleIaddEPC \circseq pc := 46 \\
    % \t2 {} \circelse pc = 46 \circthen HandleAloadEPC(0) \circseq pc := 47 \\
    % \t2 {} \circelse pc = 47 \circthen HandleIaddEPC \circseq pc := 48 \\
    % \t2 {} \circelse pc = 48 \circthen HandleIconstEPC(5) \circseq pc := 49 \\
    % \t2 {} \circelse pc = 49 \circthen HandleIaddEPC \circseq pc := 50 \\
    % \t2 {} \circelse pc = 50 \circthen HandleAreturnEPC \\
    \t2 \circfi \circseq Poll \circseq Running \\
    \t1 \circfi
  \end{circus}
  }
  \caption{The $Running$ action after method call resolution}
  \label{method-call-resolution-example-figure}
\end{figure}

Calls to methods with separate actions can then be resolved,
sequencing the method invocation instruction with a call to the
\Circus{} action representing its body and the instructions following
the method call. 
This occurs on line~\ref{algorithm-resolve-method-calls} of the
algorithm, and can be seen in
Figure~\ref{method-call-resolution-example-figure}, which shows our
example after method call resolution has been applied.

The target of each method call can be determined from the parameter to
the method invocation instruction.
This parameter is an index into the constant pool of the current class
that points to a reference to the method being called.
The correct current class for each bytecode instruction is always
known, since the information on the method entries and ends is
contained in the class information, and there is a one-to-one mapping
between classes and blocks of bytecode instructions that form methods.
After the target of the method call has been determined, the
invocation instruction can be sequenced with a call to the
corresponding \Circus{} action.

An example of a resolved method call is the call to $TPK\_f$ at
$pc = 23$, in the sequence of actions beginning at $pc = 21$ in
Figure~\ref{method-call-resolution-example-figure}. 
This comes from resolving the method invocation instruction
$invokestatic~46$.
As can be seen from Figure~\ref{example-model-figure}, the constant
pool index $46$ corresponds to the method identifier for the method
\texttt{f()} of \texttt{TPK}.
The sequence of instructions corresponding to this method is in an
action $TPK\_f$, created in the previous step, on
line~\ref{algorithm-separate-complete-methods} of
Algorithm~\ref{epc-algorithm}.

The semantics for the invocation instruction is expanded to
instantiate the data operations it contains.
These are then sequenced with the method action $TPK\_f$, with the
$Poll$ action inbetween (to allow thread switches before the first
instruction of the called method).
The instructions following the method call are sequenced after it,
with another $Poll$ action (to allow thread switches following the
return from the method).
Method call resolution is described in more detail in
Section~\ref{resolve-method-calls-subsection}, where we define the
\Call{SeparateCompleteMethods}{} and \Call{ResolveMethodCalls}{}
procedures.

% \begin{figure}[tp!]
%   \setlength{\zedindent}{0cm}
%   \setlength{\zedtab}{0.3cm}
%   \setlength{\zedleftsep}{0cm}
%   \setlength{\abovedisplayskip}{0cm}
%   \setlength{\belowdisplayskip}{0cm}
%   \addchange{Inserted full definition of $TPK\protect\_handleAsyncEvent$ and
%     separated it into its own figure}
%   \changed{
%   \scriptsize
%   \begin{circus}
%     TPK\_APEHinit \circdef \\
%     \t1 HandleAloadEPC(0) \circseq pc := 1 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 2 \circseq Poll \circseq HandleAloadEPC(2) \circseq pc := 3 \circseq \\
%     \t1 Poll \circseq HandleAloadEPC(3) \circseq pc := 4 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 5 \circseq Poll \circseq (\circvar poppedArgs : \seq Word \circspot \\
%     \t1 \lschexpract \exists argsToPop? == 6 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
%     \t1 \lschexpract InterpreterNewStackFrame[AperiodicEventHandler/class?, APEHinit/methodID?, poppedArgs/methodArgs?] \rschexpract \circseq \\
%     \t1 Poll \circseq AperiodicEventHandler\_APEHinit) \circseq pc := 6 \circseq Poll \circseq HandleReturnEPC
%   \end{circus}
%   \vspace{0.5cm}
%   \begin{circus}
%     TPK\_handleAsyncEvent \circdef \\
%     \t1 HandleNewEPC(27) \circseq pc := 8 \circseq Poll \circseq HandleDupEPC \circseq pc := 9 \circseq  Poll \circseq HandleAconst\_nullEPC \circseq \\
%     \t1 pc := 10 \circseq Poll \circseq (\circvar poppedArgs : Word \circspot  \lschexpract \exists argsToPop? == 2 @ InterpreterStackFrameInvokeEPC \rschexpract \circseq \\
%     \t1 \lschexpract InterpreterNewStackFrame[ConsoleConnection/class?, CCinit/methodID?] \rschexpract \circseq Poll \circseq \\
%     \t1 ConsoleConnection\_CCinit) \circseq pc := 11 \circseq Poll \circseq HandleAstoreEPC(1) \circseq pc := 12 \circseq Poll \circseq \\
%     \t1 HandleAloadEPC(1) \circseq pc := 13 \circseq Poll \circseq (\circvar poppedArgs : Word \circspot \\
%     \t1 \lschexpract \exists argsToPop? == 1 @ InterpreterStackFrameInvokeEPC \rschexpract \circseq getClassIDOf!head~poppedArgs?cid \then {} \\
%     \t1 \circif cid = ConsoleConnectionID \circthen {} \\
%     \t2 \lschexpract InterpreterNewStackFrame[ConsoleConnection/class?, openInputStream/methodID?] \rschexpract \circseq \\
%     \t2 Poll \circseq ConsoleConnection\_openInputStream \\
%     \t1 \circfi) \circseq pc := 14 \circseq Poll \circseq HandleAstoreEPC(2) \circseq pc := 15 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 16 \circseq Poll \circseq \\
%     \t1 (\circvar poppedArgs : Word \circspot \lschexpract \exists argsToPop? == 1 @ InterpreterStackFrameInvokeEPC \rschexpract \circseq \\
%     \t1 getClassIDOf!head~poppedArgs?cid \then \circif cid = ConsoleConnectionID \circthen {} \\
%     \t2 \lschexpract InterpreterNewStackFrame[ConsoleConnection/class?, openOutputStream/methodID?] \rschexpract \circseq Poll \circseq \\
%     \t2 ConsoleConnection\_openOutputStream \\
%     \t1 \circfi) \circseq pc := 17 \circseq Poll \circseq HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq pc := 19 \circseq Poll \circseq \\
%     \t1 HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq (\circmu Y \circspot \\
%     \t2 HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq  pc := 41 \circseq Poll \circseq \\
%     \t2 (\circvar value1, value2 : Word \circspot InterpreterPop2EPC \\
%     \t2 \circif value1 \leq value2 \circthen pc := 21 \circseq Poll \circseq HandleAloadEPC(2) \circseq pc := 22 \circseq Poll \circseq \\
%     \t3 (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop?  == 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
%     \t3 getClassIDOf!(head~poppedArgs)?cid \then \circif cid = ConsoleInputClassID \circthen {} \\
%     \t4 \lschexpract InterpreterNewStackFrame[ ConsoleInput/class?, read/methodID?, poppedArgs/methodArgs?] \rschexpract \circseq \\
%     \t4 Poll \circseq ConsoleInput\_read \\
%     \t3 \circfi) \circseq pc := 23 \circseq Poll \circseq (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop? == 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
%     \t3 \lschexpract InterpreterNewStackFrame[TPK/class?, f/methodID?, poppedArgs/methodArgs?] \rschexpract \circseq Poll \circseq TPK\_f) \circseq \\
%     \t3 pc := 24 \circseq Poll \circseq HandleAstoreEPC(5) \circseq pc := 25 \circseq Poll \circseq HandleAloadEPC(5) \circseq pc := 26 \circseq \\
%     \t3 HandleIconstEPC(400) \circseq pc := 27 \circseq Poll \circseq (\circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
%     \t3 \circif value1 \leq value2 \circthen pc := 32 \circseq HandleAloadEPC(3) \circseq pc := 33 \circseq Poll \circseq HandleAloadEPC(5) \circseq pc := 34 \circseq \\
%     \t4 Poll \circseq (\circvar poppedArgs : Word \circspot \lschexpract \exists argsToPop? == 2 @ InterpreterStackFrameInvokeEPC \rschexpract \circseq \\
%     \t4 getClassIDOf!head~poppedArgs?cid \then \circif cid = ConsoleOutputID \circthen {} \\
%     \t5 \lschexpract InterpreterNewStackFrame[ConsoleOutput/class?, write/methodID?] \rschexpract \circseq  Poll \circseq ConsoleOutput\_write \\
%     \t4 \circfi) \\
%     \t3 {} \circelse value1 > value2 \circthen pc := 28 \circseq HandleAloadEPC(3) \circseq pc := 29 \circseq Poll \circseq HandleIconstEPC(0) \circseq pc := 30 \circseq \\
%     \t4 Poll \circseq (\circvar poppedArgs : Word \circspot \lschexpract \exists argsToPop? == 2 @ InterpreterStackFrameInvokeEPC \rschexpract \circseq \\
%     \t4 getClassIDOf!head~poppedArgs?cid \then \circif cid = ConsoleOutputID \circthen {} \\
%     \t5 \lschexpract InterpreterNewStackFrame[ConsoleOutput/class?, write/methodID?] \rschexpract \circseq  Poll \circseq ConsoleOutput\_write \\
%     \t4 \circfi) \circseq pc := 31 \circseq Poll \\
%     \t3 \circfi) \circseq pc := 35 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 36 \circseq Poll \circseq HandleIconstEPC(1) \circseq pc := 37 \circseq Poll \circseq \\
%     \t3 HandleIaddEPC \circseq pc := 38 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 39 \circseq Poll \circseq Y \\
%     \t2 {} \circelse value1 > value2 \circthen \Skip \\
%     \t2 \circfi)) \circseq pc := 42 \circseq Poll \circseq HandleReturnEPC \\
%   \end{circus}
%   }
%   \caption{The separated $TPK\_APEHinit$ and $TPK\_handleAsyncEvent$ actions}
%   \label{method-separation-handleAsyncEvent-example-figure}
% \end{figure}

\begin{figure}[t!]
  \setlength{\zedindent}{0cm}
  \setlength{\zedtab}{0.3cm}
  \setlength{\zedleftsep}{0cm}
  \setlength{\abovedisplayskip}{0cm}
  \setlength{\belowdisplayskip}{0cm}
  \small
  \begin{circus}
    Running \circdef \\
    \t1 \circif frameStack = \emptyset \circthen \Skip \\
    \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
    \t2 {} \circif pc = 0 \circthen TPK\_APEHinit \\
    \t2 {} \cdots {} \\
    \t2 {} \circelse pc = 7 \circthen TPK\_handleAsyncEvent \\
    \t2 {} \cdots {} \\
    \t2 {} \circelse pc = 43 \circthen TPK\_f \\
    \t2 {} \cdots {} \\
    \t2 \circfi \circseq Poll \circseq Running \\
    \t1 \circfi
  \end{circus}
  \caption{The $Running$ action after all the methods are separated}
  \label{final-method-separation-example-figure}
\end{figure}

\begin{figure}[t!]
  \setlength{\zedindent}{0cm}
  \setlength{\abovedisplayskip}{0cm}
  \setlength{\belowdisplayskip}{0cm}
  \small
  \begin{circusaction}
    ExecuteMethod \circdef \\
    \t1 \circval classID : ClassID; \circval methodID : MethodID; \circval methodArgs : \seq Word \circspot \\
    \t1 \circif (classID, methodID) = (TPKClassID, APEHinit) \circthen {} \\
    \t2 InterpreterNewStackFrame[TPK/class?] \circseq TPK\_APEHinit \\
    \t1 {} \circelse (classID, methodID) = (TPKClassID, handleAsyncEvent) \circthen {} \\
    \t2 InterpreterNewStackFrame[TPK/class?] \circseq TPK\_handleAsyncEvent \\
    \t1 {} \circelse (classID, methodID) = (TPKClassID, f) \circthen {} \\
    \t2 InterpreterNewStackFrame[TPK/class?] \circseq TPK\_f \\
    \t1 {} \cdots {} \\
    \t1 \circfi
  \end{circusaction}
  \begin{circusaction}
    MainThread \circdef \\
    \t1 setStack?t \prefixcolon (t = thread) ?stack \then frameStackID := Initialised~stack \circseq \circmu X \circspot \\
    \t1 \circblockbegin
    executeMethod? t \prefixcolon (t = thread)?c?m?a \then ExecuteMethod(c,m,a) \circseq Poll \circseq X \\
    {} \extchoice {} \\
    CEEswitchThread?from?to \prefixcolon (from = thread) \then Blocked \circseq X
    \circblockend
  \end{circusaction}
  \begin{circusaction}
    Started \circdef \\
    \t1 \circblockbegin
    executeMethod? t \prefixcolon (t = thread)?c?m?a \then ExecuteMethod(c,m,a) \circseq Poll \circseq \\
    \t1 \circblockbegin
    continue?t \prefixcolon (t = thread) \then Started \\
    {} \extchoice {} \\
    endThread?t \prefixcolon (t = thread) \then \Skip
    \circblockend \\
    {} \extchoice {} \\
    CEEswitchThread?from?to \prefixcolon (from = thread) \then Blocked \circseq Started \\
    {} \extchoice {} \\
    endThread?t \prefixcolon (t = thread) \then \Skip
    \circblockend \circseq \\
    \t1 removeThreadMemory!thread \then CEEremoveThread!thread \\
    \t1 {} \then CEEswitchThread?from?to \prefixcolon (from = thread) \then NotStarted
  \end{circusaction}
  \caption{The $ExecuteMethod$, $MainThread$, and $Started$ actions
    after main action refinement}
  \label{refine-main-actions-example-figure}
\end{figure}

As mentioned previously, these steps are then repeated, in the loop
beginning at line~\ref{algorithm-method-loop} of
Algorithm~\ref{epc-algorithm} to introduce the loops and conditionals
in methods that have unresolved method calls in the middle of loops
and conditionals.
Afterwards, those methods can be separated out and this loop,
conditional and method resolution repeated until every method has been
separated out in this way.
This always terminates, since we do not allow recursion, and so there
are no loops in the dependencies between methods.


The $Running$ action of our example at the end of the loop in
Algorithm~\ref{epc-algorithm}, when all loops and conditionals have
been introduced, all the methods have been separated out, and all
method calls have been resolved, is shown in
Figure~\ref{final-method-separation-example-figure}.
\addchange{Changed explanation of
  Figure\protected~\protected\ref{final-method-separation-example-figure}
  to reflect changes}
\added{
At this point, the actions at $pc = 0$ have been separated into a
$TPK\_APEHinit$ action, and the actions at $pc = 7$ have been
separated into a $TPK\_handleAsyncEvent$ action.
We omit the definitions of these actions, since they are just the
contents of the $pc = 0$ and $pc = 7$ branches in
Figure~\ref{loop-and-conditional-introduction-example-figure}.
}
\deleted{
At this point, the choice over the $pc$ value maps entry points of
methods onto the actions representing those methods, with the other
$pc$ values now redundant.
}


\begin{figure}[t!]
  \setlength{\zedtab}{0.4cm}
  \setlength{\zedindent}{0pt}
  \setlength{\zedleftsep}{0pt}
  \setlength{\abovedisplayskip}{0pt}
  \setlength{\belowdisplayskip}{0pt}
  \setlength{\abovedisplayshortskip}{0pt}
  \setlength{\belowdisplayshortskip}{0pt}
  \addchange{Inserted full defintion of $TPK\protect\_handleAsyncEvent$ in
    Figure\protect~\protect\ref{pc-elimination-HandleAsyncEvent-example-figure}}
  \changed{
  \scriptsize
  \begin{circus}
    TPK\_handleAsyncEvent \circdef \\
    \t1 HandleNewEPC(27) \circseq Poll \circseq HandleDupEPC \circseq Poll \circseq HandleAconst\_nullEPC \circseq \\
    \t1 Poll \circseq (\circvar poppedArgs : Word \circspot  \lschexpract \exists argsToPop? == 2 @ InterpreterStackFrameInvokeEPC \rschexpract \circseq \\
    \t1 \lschexpract InterpreterNewStackFrame[ConsoleConnection/class?, CCinit/methodID?] \rschexpract \circseq Poll \circseq \\
    \t1 ConsoleConnection\_CCinit) \circseq Poll \circseq HandleAstoreEPC(1) \circseq Poll \circseq \\
    \t1 HandleAloadEPC(1) \circseq Poll \circseq (\circvar poppedArgs : Word \circspot \\
    \t1 \lschexpract \exists argsToPop? == 1 @ InterpreterStackFrameInvokeEPC \rschexpract \circseq getClassIDOf!head~poppedArgs?cid \then {} \\
    \t1 \circif cid = ConsoleConnectionID \circthen {} \\
    \t2 \lschexpract InterpreterNewStackFrame[ConsoleConnection/class?, openInputStream/methodID?] \rschexpract \circseq \\
    \t2 Poll \circseq ConsoleConnection\_openInputStream \\
    \t1 \circfi) \circseq Poll \circseq HandleAstoreEPC(2) \circseq Poll \circseq HandleAloadEPC(1) \circseq Poll \circseq \\
    \t1 (\circvar poppedArgs : Word \circspot \lschexpract \exists argsToPop? == 1 @ InterpreterStackFrameInvokeEPC \rschexpract \circseq \\
    \t1 getClassIDOf!head~poppedArgs?cid \then \circif cid = ConsoleConnectionID \circthen {} \\
    \t2 \lschexpract InterpreterNewStackFrame[ConsoleConnection/class?, openOutputStream/methodID?] \rschexpract \circseq Poll \circseq \\
    \t2 ConsoleConnection\_openOutputStream \\
    \t1 \circfi) \circseq Poll \circseq HandleAstoreEPC(3) \circseq Poll \circseq HandleIconstEPC(0) \circseq Poll \circseq \\
    \t1 HandleAstoreEPC(4) \circseq Poll \circseq Poll \circseq (\circmu Y \circspot \\
    \t2 HandleAloadEPC(4) \circseq Poll \circseq HandleIconstEPC(10) \circseq Poll \circseq \\
    \t2 (\circvar value1, value2 : Word \circspot InterpreterPop2EPC \\
    \t2 \circif value1 \leq value2 \circthen Poll \circseq HandleAloadEPC(2) \circseq Poll \circseq \\
    \t3 (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop?  == 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    \t3 getClassIDOf!(head~poppedArgs)?cid \then \circif cid = ConsoleInputClassID \circthen {} \\
    \t4 \lschexpract InterpreterNewStackFrame[ \\
    \t5 ConsoleInput/class?, read/methodID?, poppedArgs/methodArgs?] \rschexpract \circseq \\
    \t4 Poll \circseq ConsoleInput\_read \\
    \t3 \circfi) \circseq Poll \circseq (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop? == 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    \t3 \lschexpract InterpreterNewStackFrame[TPK/class?, f/methodID?, poppedArgs/methodArgs?] \rschexpract \circseq \\
    \t3 Poll \circseq TPK\_f) \circseq Poll \circseq HandleAstoreEPC(5) \circseq Poll \circseq HandleAloadEPC(5) \circseq \\
    \t3 HandleIconstEPC(400) \circseq Poll \circseq (\circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    \t3 \circif value1 \leq value2 \circthen HandleAloadEPC(3) \circseq Poll \circseq HandleAloadEPC(5) \circseq \\
    \t4 Poll \circseq (\circvar poppedArgs : Word \circspot \lschexpract \exists argsToPop? == 2 @ InterpreterStackFrameInvokeEPC \rschexpract \circseq \\
    \t4 getClassIDOf!head~poppedArgs?cid \then \circif cid = ConsoleOutputID \circthen {} \\
    \t5 \lschexpract InterpreterNewStackFrame[ConsoleOutput/class?, write/methodID?] \rschexpract \circseq \\
    \t5 Poll \circseq ConsoleOutput\_write \\
    \t4 \circfi) \\
    \t3 {} \circelse value1 > value2 \circthen HandleAloadEPC(3) \circseq Poll \circseq HandleIconstEPC(0) \circseq \\
    \t4 Poll \circseq (\circvar poppedArgs : Word \circspot \lschexpract \exists argsToPop? == 2 @ InterpreterStackFrameInvokeEPC \rschexpract \circseq \\
    \t4 getClassIDOf!head~poppedArgs?cid \then \circif cid = ConsoleOutputID \circthen {} \\
    \t5 \lschexpract InterpreterNewStackFrame[ConsoleOutput/class?, write/methodID?] \rschexpract \circseq \\
    \t5 Poll \circseq ConsoleOutput\_write \\
    \t4 \circfi) \circseq Poll \\
    \t3 \circfi) \circseq Poll \circseq HandleAloadEPC(4) \circseq Poll \circseq HandleIconstEPC(1) \circseq Poll \circseq \\
    \t3 HandleIaddEPC \circseq Poll \circseq HandleAstoreEPC(4) \circseq Poll \circseq Y \\
    \t2 {} \circelse value1 > value2 \circthen \Skip \\
    \t2 \circfi)) \circseq Poll \circseq HandleReturnEPC
  \end{circus}
  }
  \caption{The $TPK\_handleAsyncEvent$ action after $pc$ has been eliminated from the state}
  \label{pc-elimination-HandleAsyncEvent-example-figure}
\end{figure}

The next step is then to eliminate these redundant paths and remove
the dependency on $pc$ to select the method action.
%TODO: make sure "at line" is used consistently
This occurs at line~\ref{algorithm-refine-main-actions} of
Algorithm~\ref{epc-algorithm}, in which the $Started$ and $MainThread$
actions are refined to replace the $Running$ action with an
$ExecuteMethod$ action that contains a choice of method action based
on the method and class identifiers of the method.
This can be seen in Figure~\ref{refine-main-actions-example-figure},
which shows the $ExecuteMethod$ action corresponding to our example,
and the refined $MainThread$ and $Started$ actions that reference it.
We describe this refinement in more detail in
Section~\ref{refine-main-actions-subsection}, where we define the
\Call{RefineMainActions}{} procedure.

When all of the previous steps are completed, reliance on $pc$ to
determine control flow has been completely removed.
The $pc$ state component can then be removed in a simple data
refinement that also removes all the assignments to $pc$, resulting in
the $TPK\_handleAsyncEvent$ action shown in
Figure~\ref{pc-elimination-HandleAsyncEvent-example-figure}.
The data refinement to remove $pc$ is applied at the end of the
algorithm, on line~\ref{algorithm-remove-pc-from-state}, and is
described in more detail in
Section~\ref{remove-pc-from-state-subsection}, where we define the
\Call{RemovePCFromState}{} procedure.

The remaining instruction handling actions then only affect the stack,
the removal of which is the concern of the next stage of the
compilation strategy.

We now proceed to describe each of the steps of
Algorithm~\ref{epc-algorithm} in more detail.

After the $CheckLauncherReturn$ actions have been handled, the process
no longer has any actions that use the whole $frameStack$.
We can therefore refine each method to only operate on a local stack
frame variable.
This is performed as described in
Algorithm~\ref{localise-stack-frames-algorithm}, which defines the
procedure \Call{LocaliseStackFrames}{}.

\begin{algorithm}
  \begin{algorithmic}[1]
    \arraycolsep=0cm
    \State \ApplyFor{Law~[\nameref{forwards-data-refinement-law}]}{$InterpreterStateFS$, $FrameStackCI$}
    \label{algorithm-remove-currentClass-data-refinement}
    \State $iterationOrder \gets$ \Call{MethodDependencyOrder}{}
    \label{algorithm-method-dependency-order-call}
    \For{$methodName \gets iterationOrder$}
    \label{algorithm-localise-stack-frames-loop}
    \State $numArgs \gets$ \Call{MethodArguments}{$methodName$}
    \If{$\lnot$ \Call{IsStatic}{$methodName$}}
    \label{algorithm-static-args-check-start}
    \State $numArgs \gets numArgs + 1$
    \EndIf
    \label{algorithm-static-args-check-end}
    \State \ExhaustivelyApplyFor{Rule~[\nameref{arguments-introduction-rule}]}{$methodName$, $numArgs$}
    \label{algorithm-arguments-introduction}
    \State \Call{RedefineMethodToIncludeParameters}{$methodName$}
    \label{algorithm-redefine-method-action-to-include-parameters}
    \State \ApplyToFor{Rule~[\nameref{HandleReturnEPC-stackFrame-introduction-rule}]}{\Call{ActionBody}{$methodName$}}{$numArgs$}
    \label{algorithm-HandleReturnEPC-stackFrame-introduction-rule}
    \EndFor
  \end{algorithmic}
  \caption{LocaliseStackFrames}
  \label{localise-stack-frames-algorithm}
\end{algorithm}
 
Since we must be able to operate directly on the $frameStack$ when
introducing stack frame variables, we first apply a data refinement to
remove $currentClass$ from the state.
We defined $currentClass$ in the model as a convenience when accessing
the $frameClass$ of the topmost stack frame, which is no longer
necessary when we have separate variables for each stack frame.
The data refinement is applied on
line~\ref{algorithm-remove-currentClass-data-refinement} of
Algorithm~\ref{localise-stack-frames-algorithm}, and transforms the
state to $InterpreterStateFS$, shown below, which only contains
$frameStack$.
\begin{schema}{InterpreterStateFS}
  frameStack : StackFrameEPC
\end{schema}

The relationship between $InterpreterStateEPC$ and
$InterpreterStateFS$ is described by the coupling invariant
$FrameStackCI$, shown below.
It ensures $frameStack$ is unaffected by the refinement and replaces
occurrences of $currentClass$ with $(last~frameStack).frameClass$.
\begin{schema}{FrameStackCI}
  InterpreterStateEPC \\
  InterpreterStateFS_1
\where
  frameStack = frameStack_1 \\
  currentClass = (last~frameStack_1).frameClass
\end{schema}

$FrameStackCI$ describes a functional data refinement, so the new
actions can be calculated in each case.
The effect of this data refinement is, as mentioned above, that
$currentClass$ is replaced with $(last~frameStack).frameClass$,
wherever it occurs in the old actions.
We can then proceed with introducing stack frame variables.

When introducing the variables to represent stack frames, we must
begin with those methods at the greatest call depth.
This ensures uses of the $frameStack$ within a nested method do not
interfere with replacing uses of the $frameStack$ in an outer method.
To understand this, consider if we were to try to introduce a variable
representing the stack frame for $TPK\_handleAsyncEvent$, shown in
part in
Figure~\ref{efs-eliminate-returns-handleAsyncEvent-example-figure},
without first introducing the stack frame variable for $TPK\_f$.
The $InterpreterNewStackFrame$ operation that appears before the call
to $TPK\_f$ creates a new stack frame on $frameStack$.
This new stack frame is different from the stack frame we are
introducing a variable for it in $TPK\_handleAsyncEvent$, although it
is the last frame on $frameStack$ during the body of $TPK\_f$.
This makes it much more complex to refer to correct stack frame when
introducing the variable to $TPK\_handleAsyncEvent$.
Ensuring the stack frame variable is introduced for $TPK\_f$ first
avoids this issue, since it means the size of $frameStack$ is not
affected within the body of $TPK\_handleAsyncEvent$.

We therefore introduce stack frame variables to the methods in the
order specified by a procedure \Call{MethodDependencyOrder}{}, which
constructs a sequence of method action names indicating the order in
which the method actions should be handled.
This sequence is constructed by first adding to the sequence any
methods that contain no method calls, then adding any methods that
only call methods already in the sequence, and repeating until all
methods are in the sequence.
Since we do not allow recursion, this always terminates.
We construct this sequence, $iterationOrder$, on
line~\ref{algorithm-method-dependency-order-call} of
Algorithm~\ref{localise-stack-frames-algorithm}.

We then loop, introducing a stack frame variable for each method in
the order specified by $iterationOrder$, in the for loop on
line~\ref{algorithm-localise-stack-frames-loop}.
Within the for loop, we first introduce value parameters, representing
the arguments to the method, around the call to the method action.
This ensures that the body of the method is completely independent of
the context in which it is called, enabling us to separate the whole
method body (including stack frame creation and return actions) into
its own action.
Introduction of method arguments is performed using
Rule~[\nameref{arguments-introduction-rule}], shown in
Figure~\ref{arguments-introduction-rule-figure}.
This rule is applied to two parameters:~$methodName$, the name of the
method being considered, and $numArgs$, the number of arguments to the
method.
The number of arguments is determined from the name of the method
(recall that the arguments of a method are encoded in its identifier)
and we add an extra argument for \texttt{this} if the method is not
static, as indicated by if statement on
lines~\ref{algorithm-static-args-check-start}
to~\ref{algorithm-static-args-check-end}.
We apply this rule everywhere it applies on
line~\ref{algorithm-HandleReturnEPC-stackFrame-introduction-rule}.

\begin{figure}[thp]
\begin{restatable}[$Return$-arguments-intro]{crule}{ArgumentsIntroductionRule}
  \label{arguments-introduction-rule}
  %\setlength{\zedtab}{0.4cm}
  %\setlength{\zedindent}{0pt}
  %\setlength{\zedleftsep}{0pt}
  Given an action name $M$ and $n : \nat$,
  \begin{circus}
    \begin{array}{l}
      \lschexpract InterpreterNewStackFrame[ \\
      \t1 c/class?, \\
      \t1 m/methodID?, \\
      \t1 args/methodArgs?] \rschexpract \circseq \\
      M \circseq \lschexpract InterpreterReturn \rschexpract
    \end{array}
    \circrefines_A
    \begin{array}{l}
      (\circval arg1, \ldots, arg{<}n{>} : Word \circspot \\
      \t1 \lschexpract \exists methodArgs? == \langle arg1, \ldots, arg{<}n{>} \rangle @ \\
      \t2 InterpreterNewStackFrame[ \\
      \t3 c/class?, \\
      \t3 m/methodID?] \rschexpract \circseq \\
      \t1 M \circseq \lschexpract InterpreterReturn \rschexpract \\
      )(args~1, \ldots, args~n)
    \end{array}
  \end{circus}
\end{restatable}
\caption{Rule~[\nameref{arguments-introduction-rule}]}
\label{arguments-introduction-rule-figure}
\end{figure}

Rule~[\nameref{arguments-introduction-rule}] introduces value
parameters representing method arguments around a method ending with
an $InterpreterReturn$ operation.
The arguments array passed into the $methodArgs$ input of
$InterpreterNewStackFrame$ is split into its individual elements,
which are passed into the parameters and recombined to be passed into
$InterpreterNewStackFrame$.
This splitting of the array ensures that the individual arguments can
be more easily handled in the next step, where we introduce local
variables.

For example, every call to the method action $TPK\_handleAsyncEvent$
is preceded by an $InterpreterNewStackFrame$ operation and followed by
an $InterpreterReturnEPC$ operation.
The Rule~[\nameref{arguments-introduction-rule}] therefore applies to
it and the number of arguments given as the $n$ parameter to the rule
is $1$, since the SCJ method \texttt{handleAsyncEvent()} takes no
explicit arguments, but is non-static.
Calls to $TPK\_handleAsyncEvent$ (the only one of which occurs in
$ExecuteMethod$, since it is only called by the infrastructure), then
have the form shown below.
\begin{circus}
  (\circval arg1 : Word \circspot \\
      \t1 \lschexpract \exists methodArgs? == \langle arg1 \rangle @ \\
      \t2 InterpreterNewStackFrame[TPK/class?, handleAsyncEvent/methodID?] \rschexpract \circseq \\
      \t2 TPK\_handleAsyncEvent \circseq \lschexpract InterpreterReturn \rschexpract \\
      )(methodArgs~1)
\end{circus}

After the method arguments have been introduced, we redefine the
method action to include the contents of the parametrised block
introduced by Rule~[\nameref{arguments-introduction-rule}].
This is performed in a separate procedure,
\Call{RedefineMethodToIncludeParameters}{}, which is similar to
the \Call{RedefineMethodExcludingReturn}{} procedure used
in the previous section.
It is defined by
Algorithm~\ref{redefine-method-action-to-include-parameters-algorithm}
in Appendix~\ref{localise-stack-frames-appendix-subsection}.

Having completely separated the method into its own, independent,
action, we then introduce the stack frame variable for the method
using Rule~[\nameref{HandleReturnEPC-stackFrame-introduction-rule}],
shown in
Figure~\ref{HandleReturnEPC-stackFrame-introduction-rule-figure}.
This is applied to the body of $methodName$ on
line~\ref{algorithm-HandleReturnEPC-stackFrame-introduction-rule},
with the number of arguments, $numArgs$, passed to it.

\begin{figure}[thp]
\begin{restatable}[$Return$-$stackFrame$-intro]{crule}{HandleReturnEPCStackFrameIntroductionRule}
  \label{HandleReturnEPC-stackFrame-introduction-rule}
  \setlength{\zedtab}{0.4cm}
  \setlength{\zedindent}{0.5cm}
  %\setlength{\zedleftsep}{0pt}
  Given $n : \nat$, if $A$ operates solely on $last~frameStack$ and do
  not change the length of $frameStack$, then
  \begin{circus}
    \begin{array}{l}
      \lschexpract \exists methodArgs? == \langle arg1, \ldots, arg{<}n{>} \rangle @ \\
      \t2 InterpreterNewStackFrame[ \\
      \t3 c/class?, \\
      \t3 m/methodID? \rschexpract \circseq \\
      A \circseq \lschexpract InterpreterReturn \rschexpract
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circvar stackFrame : StackFrameEPC \circspot \\
      \t1 \lschexpract [arg1?, \ldots, arg{<}n{>}? : Word; \\
      \t1 stackFrame' : StackFrameEPC  | \\
      \t2 \langle arg1?, \ldots, arg{<}n{>}? \rangle \\
      \t3 {} \subseteq stackFrame'.localVariables \land \\
      \t2 \# stackFrame'.localVariables = \ell \land \\
      \t2 stackFrame'.operandStack = \langle\rangle \land \\
      \t2 stackFrame'.frameClass = c \land \\
      \t2 stackFrame'.stackSize = s] \rschexpract \circseq \\
      \t1 A[stackFrame/last~frameStack, \\
      \t2 stackFrame'/last~frameStack']
    \end{array}
  \end{circus}
  where $\ell = c.methodLocals~m$ and $s = c.methodStackSize~m$.
\end{restatable}
\caption{Rule~[\nameref{HandleReturnEPC-stackFrame-introduction-rule}]}
\label{HandleReturnEPC-stackFrame-introduction-rule-figure}
\end{figure}

Rule~[\nameref{HandleReturnEPC-stackFrame-introduction-rule}]
introduces a variable $stackFrame$, of type $StackFrameEPC$, over the
body of a method that ends with an $InterpreterReturn$ operation.
The $stackFrame$ variable is initialised in the same way as for the
stack frame created by $InterpreterNewStackFrame$, and each reference
to $last~frameStack$ in the body of the method is replaced with a
reference to $stackFrame$.
Replacing the references to $last~frameStack$ requires that the size
of $frameStack$ does not change during the method.
However, this requirement is met since method calls are the only
operation that changes the size of $frameStack$ and we replace
references to the $frameStack$ in nested methods first, by the
definition of $iterationOrder$.

Note that the operations performed on
lines~\ref{algorithm-arguments-introduction}
and~\ref{algorithm-HandleReturnEPC-stackFrame-introduction-rule}
specifically handle methods that do not return a value.
We omit the handling of methods that do return a value. 
Handling such methods would require rules similar to
Rule~[\nameref{arguments-introduction-rule}] for method bodies
followed by $InterpreterAreturn1$ and $InterpreterAreturn2$, which
would introduce a result parameter for the method in addition to the
value parameters representing the method's arguments.
The new method action would then have to match the different method
parameters.
We would also require a rule similar
Rule~[\nameref{HandleReturnEPC-stackFrame-introduction-rule}] to
handle the slightly different ending of the method action that the
return handling would create.
These rules would be applied in a way similar to the existing rules.

In our example, the body of $TPK\_handleAsyncEvent$ (having the form
of the actions in the parametrised block shown above), begins with an
$InterpreterNewStackFrame$ operation having $TPK$ as its $class?$ and
$handleAsyncEvent$ as its $methodID?$.
The values for $\ell$ and $s$ can thus be obtained from the
$methodLocals$ and $methodStackSize$ components of the $TPK$ class
structure shown in Figure~\ref{example-model-figure}.
This gives values of $6$ for $\ell$ and $3$ for $s$.
Thus, after applying
Rule~[\nameref{HandleReturnEPC-stackFrame-introduction-rule}] the
$TPK\_handleAsyncEvent$ is as shown in
Figure~\ref{efs-localise-stack-frames-example-figure}.

For brevity, we define new actions, which we refer to as $Handle*SF$
actions.
These are not formally introduced as actions in the compilation
strategy as they are an abbreviation used for presenting examples and
stating compilation rules.
They are refined to a different form later in the elimination of frame
stack stage.
The $Handle*SF$ actions are similar to the $Handle*EPC$ actions,
except they have every reference to $last~frameStack$ (or
$last~frameStack'$) replaced with a reference to $stackFrame$ (or
$stackFrame'$), and have undergone the data refinement described
above.
We name them by replacing $EPC$ in the names of the $Handle*EPC$
actions with $SF$.
Similarly, we define an $InvokeSF$ operation that performs the
operation of $InterpreterStackFrameInvoke$ over $stackFrame$ instead
of $last~frameStack$.

% TODO: fix this for algorithm changes
\begin{figure}[tp!]
  \centering
  \setlength{\zedtab}{0.4cm}
  \setlength{\zedindent}{0pt}
  \setlength{\zedleftsep}{0pt}
  \setlength{\abovedisplayskip}{0pt}
  \setlength{\belowdisplayskip}{0pt}
  \setlength{\abovedisplayshortskip}{0pt}
  \setlength{\belowdisplayshortskip}{0pt}
  \begin{circusaction}
    TPK\_f \circdef \\
    \t1 \circval arg1 : Word \circspot \\
    \t1 \circvar stackFrame : StackFrameEPC \circspot \\
    \t1 \lschexpract [arg1? : Word; stackFrame' : StackFrameEPC | \\
    \t2 \langle arg1? \rangle \subseteq stackFrame'.localVariables \land \\
    \t2 \# stackFrame'.localVariables = 6 \land \\
    \t2 stackFrame'.operandStack = \langle\rangle \land \\
    \t2 stackFrame'.frameClass = TPK \land \\
    \t2 stackFrame'.stackSize = 3] \rschexpract \circseq \\
    \t1 Poll \circseq HandleNewSF(27) \circseq Poll \circseq HandleDupSF \circseq Poll \circseq  HandleAconst\_nullSF \circseq Poll \circseq \\
    \t1 (\circvar poppedArgs : \seq Word \circspot \\
    \t2 \lschexpract \exists argsToPop? == 2 @ InvokeSF \rschexpract \circseq \\
    \t2 ConsoleConnection\_CCinit(poppedArgs~1, poppedArgs~2)) \circseq Poll \circseq \\
    \t1 HandleAstoreSF(1) \circseq Poll \circseq HandleAloadSF(1) \circseq \\
    \t1 {} \cdots {} \\
    % \t1 Poll \circseq (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    % \t1 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[ \\
    % \t2 ConsoleConnection/class?, openInputStream/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq \\
    % \t1 Poll \circseq ConsoleConnection\_openInputStream \circseq Poll \circseq  HandleAstoreEPC(2) \circseq Poll \circseq \\
    % \t1 HandleAloadEPC(1) \circseq Poll \circseq (\circvar poppedArgs : \seq Word \circspot \\
    % \t1 \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    % \t1 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[\\
    % \t2 ConsoleConnection/class?, openOutputStream/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq \\
    % \t1 Poll \circseq ConsoleConnection\_openOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq \\
    %\t1 {} \cdots {} \\
    \t1 Poll \circseq HandleIconstSF(0) \circseq Poll \circseq HandleAstoreSF(4) \circseq Poll \circseq Poll \circseq \circmu Y \circspot \\
    \t2 HandleAloadSF(4) \circseq Poll \circseq HandleIconstSF(10) \circseq Poll \circseq \\
    \t2 \circvar value1, value2 : Word \circspot \\
    \t3 \lschexpract InterpreterPop2[stackFrame/last~frameStack,stackFrame'/last~frameStack'] \rschexpract \circseq \\
    \t2 \circif value1 \leq value2 \circthen {} \\
    \t3 {} \cdots {}  \\
    % Poll \circseq HandleAloadEPC(2) \circseq Poll \circseq \\
    % \t3 (\circvar poppedArgs : \seq Word \circspot \\
    % \t4 \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    % \t4 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[ \\
    % \t5 ConsoleInput/class?, read/methodID?, poppedArgs/methodArgs?] \rschexpract) \circseq \\
    % \t3 Poll \circseq ConsoleInput\_read \circseq Poll \circseq \\
    % \t3 (\circvar poppedArgs : \seq Word \circspot \\
    % \t4 \lschexpract \exists argsToPop? == 1 @ InvokeSF \rschexpract \circseq \\
    % \t4 TPK\_f()) \circseq \lschexpract InterpreterAreturn1 \rschexpract \circseq Poll \circseq \\
    % \t3 HandleAstoreEPC(5) \circseq Poll \circseq HandleAloadEPC(5) \circseq \\
    % \t3 {} \cdots {} \\
    % \t3 Poll \circseq HandleIconstEPC(400) \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 \circif value1 \leq value2 \circthen HandleAloadEPC(3) \circseq Poll \circseq HandleAloadEPC(5) \circseq Poll \circseq \\
    % \t4 (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    % \t4 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[ \\
    % \t5 ConsoleOutput/class?, write/methodID?, poppedArgs/methodArgs?] \rschexpract)) \circseq \\
    % \t4 Poll \circseq ConsoleOutput\_write \\
    % \t3 {} \circelse value1 > value2 \circthen HandleAloadEPC(3) \circseq Poll \circseq HandleIconstEPC(0) \circseq Poll \circseq \\
    % \t4 (\circvar poppedArgs : \seq Word \circspot \lschexpract \exists argsToPop? == m + 1 @ InterpreterStackFrameInvoke \rschexpract \circseq \\
    % \t4 getClassIDOf!(head~poppedArgs)?cid \then \lschexpract InterpreterNewStackFrame[ \\
    % \t5 ConsoleOutput/class?, write/methodID?, poppedArgs/methodArgs?] \rschexpract)) \circseq \\
    % \t4 Poll \circseq ConsoleOutput\_write \\
    % \t3 \circfi \circseq Poll \circseq HandleAloadEPC(4) \circseq Poll \circseq HandleIconstEPC(1) \circseq Poll \circseq HandleIaddEPC \circseq \\
    \t3 Poll \circseq HandleAstoreSF(4) \circseq Poll \circseq Y \\
    \t2 {} \circelse value1 > value2 \circthen \Skip \\
    \t2 \circfi \circseq Poll
  \end{circusaction}
  \caption{$TPK\_handleAsyncEvent$ after its $stackFrame$ variable is
    introduced}
  \label{efs-localise-stack-frames-example-figure}
\end{figure}
\documentclass[a4paper,11pt]{report}

\usepackage[table]{xcolor}
\usepackage{array}
\usepackage[in]{fullpage}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{parskip}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage[backend=bibtex,style=numeric-comp,sorting=nyt,sortcites=true,maxnames=4]{biblatex}
\usepackage{placeins}
\usepackage[color,cntglobally]{circus}
\usepackage{mathdots}
\usepackage{multicol}
\usepackage{listings}
\usepackage{vwcol}
\usepackage{fixltx2e}
\usepackage{comment}
\usepackage{subcaption}
%\usepackage{cleveref}
\usepackage{thmtools}
\usepackage{thm-restate}
\usepackage{supertabular}
\usepackage{afterpage}

\usetikzlibrary{calc}
\usetikzlibrary{arrows}
\usetikzlibrary{graphs}

\setcounter{secnumdepth}{4}

\title{An Approach to Verification of Ahead-of-time Compilation for
  Safety-Critical Java}
\author{James Baxter}
\date{}

\bibliography{literature} 

\CountDefsfalse

\newif\ifFullModel

%TC:macro \IfFullModel [ignore]
%TC:macro \IfNotFullModel [text]
\FullModelfalse

\newcommand{\IfFullModel}[1]{\ifFullModel #1 \fi}
\newcommand{\IfNotFullModel}[1]{\ifFullModel \else #1 \fi}

\newcommand{\directsubclass}{\prec_{\mathrm{d}}}
\newcommand{\directsubclassid}[1]{\prec_{\mathrm{D},#1}}
\newcommand{\subclassid}[1]{\preceq_{#1}}

\makeatletter
\def\@endtheorem{\endtrivlist}
\def\thm@space@setup{%
  \thm@preskip=\parskip \thm@postskip=0pt
}
\makeatother

% \theoremstyle{plain}
% \newtheorem{thm}{Theorem}[section]
% \newtheorem{lem}[thm]{Lemma}
% \newtheorem{rule}{Rule}
\declaretheorem[
name=Theorem,
numberwithin=section,
refname={Theorem, Theorems},
Refname={Theorem, Theorems}
]{thm}
\declaretheorem[
name=Lemma,
numberlike=thm,
refname={Lemma, Lemmas},
Refname={Lemma, Lemmas}
]{lem}

\declaretheoremstyle[
style=plain,
notebraces={[}{]}
]{rule}

\declaretheorem[
name=Rule,
style=rule,
numbered=no,
refname={Rule,Rules},
Refname={Rule,Rules}
]{crule}

\declaretheorem[
name=Law,
style=rule,
numbered=no,
refname={Law,Laws},
Refname={Law,Laws}
]{law}

\makeatletter
\declaretheoremstyle[
style=definition,
bodyfont={
  \addtolength{\@totalleftmargin}{0.5cm}
  \addtolength{\linewidth}{-0.5cm}
  \parshape 1 0.5cm \linewidth
}
]{idefinition}
\makeatother

\declaretheorem[
name=Definition,
refname={definition,definitions},
Refname={Definition,Definitions}, numberlike=thm, style=idefinition
]{defn}

\declaretheoremstyle[
style=definition,
notebraces={[}{]}
]{proof}

\declaretheorem[
name=Proof,
style=proof,
numbered=no,
prefoothook={\qedsymbol\relax}
]{crproof}

\renewcommand{\circblockbegin}{\left(\begin{array}{l}}
\renewcommand{\circblockend}{\end{array}\right)}

\newcommand{\Apply}[1]{{\bf apply} {#1}}
\newcommand{\ApplyFor}[2]{{\bf apply} {#1} {\bf for} {#2}}
\newcommand{\ApplyTo}[2]{{\bf apply} {#1} {\bf to} {#2}}
\newcommand{\ApplyToFor}[3]{{\bf apply} {#1} {\bf to} {#2} {\bf for} {#3}}
\newcommand{\ApplyReverse}[1]{{\bf apply} {#1} {\bf in reverse}}
\newcommand{\ApplyReverseFor}[2]{{\bf apply} {#1} {\bf in reverse for} #2}
\newcommand{\ApplyReverseTo}[2]{{\bf apply} {#1} {\bf in reverse to} {#2}}
\newcommand{\ApplyReverseToFor}[3]{{\bf apply} {#1} {\bf in reverse to} {#2} {\bf for} {#3}}
\newcommand{\ExhaustivelyApply}[1]{{\bf exhaustively apply} #1}
\newcommand{\ExhaustivelyApplyFor}[2]{{\bf exhaustively apply} #1 {\bf for} #2}
\newcommand{\ExhaustivelyApplyTo}[2]{{\bf exhaustively apply} #1 {\bf to} #2}
\newcommand{\ExhaustivelyApplyToFor}[3]{{\bf exhaustively apply} #1 {\bf to} #2 {\bf for} #3}
\newcommand{\ExhaustivelyApplyReverse}[1]{{\bf exhaustively apply} #1 {\bf in reverse}}
\newcommand{\ExhaustivelyApplyReverseFor}[2]{{\bf exhaustively apply} #1 {\bf in reverse for} #2}
\newcommand{\ExhaustivelyApplyReverseTo}[2]{{\bf exhaustively apply} #1 {\bf in reverse to} #2}
\newcommand{\ExhaustivelyApplyReverseToFor}[3]{{\bf exhaustively apply} #1 {\bf in reverse to} #2 {\bf for} #3}
\newcommand{\Match}[2]{{\bf match} #1 {\bf with} #2}
\newcommand{\MatchIn}[2]{{\bf match} #1 {\bf in} #2}
\newcommand{\Matches}[2]{#1 {\bf matches} #2}
\algblockx[Try]{Try}{EndTry}
  {{\bf try}}
  {{\bf end try}}

%TC:group zed 0 displaymath
%TC:group axdef 0 displaymath
%TC:group schema 1 displaymath
%TC:group circus 0 displaymath
%TC:group circusaction 0 displaymath
%TC:macroword \Circus 1
%TC:group theorem 1 displaymath
%TC:group zproof 0 displaymath 
%TC:group algorithm 0 float
%TC:group argue 0 displaymath


  
\begin{document}
\maketitle


\begin{abstract}
  In recent years Java has been increasingly considered as a language
  for safety-critical embedded systems.
  However, some features of Java are unsuitable for such systems.
  This has resulted in the creation of Safety-Critical Java (SCJ),
  which facilitates the development of certifiable real-time and
  embedded Java programs.
  SCJ uses different scheduling and memory management models to
  standard Java, so it requires a specialised virtual machine (SCJVM).
  A common approach is to compile Java bytecode program to a native
  language, usually C, ahead-of-time for greater performance on
  low-resource embedded systems.
  
  Given the safety-critical nature of the applications, it must be
  ensured that the virtual machine is correct.
  However, so far formal verification has not been applied to any
  SCJVM.
  This thesis contributes to the formal verification of SCJVMs that
  utilise ahead-of-time compilation by presenting a verification of
  compilation from Java bytecode to C.
  The approach we adopt is an adaptation of the algebraic approach
  developed by Sampaio and Hoare.
  We start with a formal specification of an SCJVM executing the
  bytecodes of a program, and transform it, through the application
  of proven compilation rules, to a representation of the target C
  code.
  Thus, our contributions are a formal specification of an SCJVM, a
  set of compilation rules with proofs, and a strategy for applying
  those compilation rules.
  
  Our compilation strategy can be used as the basis for an
  implementation of an ahead-of-time compiling SCJVM, or verification
  of an existing implementation.
  Additionally, our formal model of an SCJVM may be used as a
  specification for creating an interpreting SCJVM.
  To ensure the applicability of our results, we base our work on
  icecap, the only SCJVM that is open source and up-to-date with the
  SCJ standard.
\end{abstract}

\tableofcontents

\input{introduction.tex}

\input{field-survey.tex}

\input{scjvm-services.tex}

\input{cee.tex}

\input{compilationstrategy.tex}

\input{evaluation.tex}

\input{conclusion.tex}

{\raggedright \printbibliography}

\appendix

\chapter{Full SCJVM Services Model}
\label{full-scjvm-services-model}

%TC:macro \IfFullModel [text]
%TC:macro \IfNotFullModel [ignore]
\FullModeltrue

\section{Memory Manager}
\input{../../SCJ-VM/James/memorymanager.zed}

\section{Scheduler}
\input{../../SCJ-VM/James/scheduler.zed}

\section{Real-Time Clock}
\input{../../SCJ-VM/James/realtimeclock.zed}

\section{Complete SCJVM Services Model}
\input{../../SCJ-VM/James/scjvmservices.zed}

\chapter{Full Core Execution Environment Model}
\label{full-cee-model}

\section{Classes}
\input{../../SCJ-VM/James/classes.zed}

\section{Channels declarations}
\label{cee-model-channels}

\input{../../SCJ-VM/James/LIchans.zed}

\input{../../SCJ-VM/James/memory_chans.zed}

\section{Object Manager}
\label{object-manager-appendix}
\input{../../SCJ-VM/James/memory.zed}

\section{Stack Frames}
\input{../../SCJ-VM/James/stack_frames.zed}

\section{Interpreter}
\label{interpreter-appendix}

\input{../../SCJ-VM/James/interpreter_thread.zed}

\input{../../SCJ-VM/James/interpreter.zed}

\section{Launcher}
\label{launcher-appendix}
\input{../../SCJ-VM/James/launcher.zed}

\section{Complete Core Execution Environment}
\input{../../SCJ-VM/James/complete_cee.zed}

\section{Post-compilation Struct Manager}
\label{struct-manager-appendix}
\input{../../SCJ-VM/James/struct_manager.zed}

\chapter{Compilation Rules}
\label{compilation-rules-appendix}

\input{compilationrules.tex}

\chapter{Algebraic Laws}
\input{algebraiclaws.tex}

%TC:ignore

\chapter{Z/Eves Theorems and Proofs}
\label{zeves-proofs}

\section{Additional Toolkit Lemmas}
\label{additional-lemmas}
\normalsize

\input{../../SCJ-VM/James/additional_lemmas.zed} 

\section{Proofs of Additional Toolkit Lemmas}
\label{additional-lemmas-proofs}
\scriptsize

\input{../../SCJ-VM/James/additional_lemmas_sets_proofs.zed}
\input{../../SCJ-VM/James/additional_lemmas_relations_proofs.zed}
\input{../../SCJ-VM/James/additional_lemmas_numbers_proofs.zed}

\section{Memory Manager Theorems}
\label{memory-manager-theorems}
\normalsize

\input{../../SCJ-VM/James/memorymanager_theorems.zed}

\section{Proofs of Memory Manager Theorems}
\label{memory-manager-proofs}
\scriptsize

\input{../../SCJ-VM/James/memorymanager_proofs.zed}

%TC:endignore

\normalsize
\chapter{Compilation Rules Proofs}
\label{compilation-rules-proofs-appendix}
\input{compilationrules_proofs.tex}

\end{document}

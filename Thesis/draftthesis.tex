\documentclass[a4paper,10pt]{report}

\usepackage[in]{fullpage}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{parskip}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage[backend=bibtex,style=numeric-comp,sorting=nyt,sortcites=true,maxnames=4]{biblatex}
\usepackage[section]{placeins}
\usepackage[color,cntglobally]{circus}
\usepackage{mathdots}
\usepackage{multicol}
\usepackage{listings}
\usepackage{vwcol}
\usepackage{fixltx2e}
\usepackage{comment}
\usepackage{subcaption}
%\usepackage{cleveref}
\usepackage{thmtools}
\usepackage{thm-restate}

\usetikzlibrary{calc}
\usetikzlibrary{arrows}
\usetikzlibrary{graphs}

\setcounter{secnumdepth}{4}

\title{An Approach to Verification of Safety-Critical Java Virtual
  Machines with Ahead-of-time Compilation}
\author{James Baxter}
\date{}

\bibliography{literature} 

\CountDefsfalse

\newif\ifFullModel
\FullModelfalse
\newcommand{\ifnFullModel}{\ifFullModel\else}

\newcommand{\directsubclass}{\prec_{\mathrm{d}}}
\newcommand{\directsubclassid}[1]{\prec_{\mathrm{D},#1}}
\newcommand{\subclassid}[1]{\preceq_{#1}}

\makeatletter
\def\@endtheorem{\endtrivlist}
\def\thm@space@setup{%
  \thm@preskip=\parskip \thm@postskip=0pt
}
\makeatother

% \theoremstyle{plain}
% \newtheorem{thm}{Theorem}[section]
% \newtheorem{lem}[thm]{Lemma}
% \newtheorem{rule}{Rule}
\declaretheorem[
name=Theorem,
numberwithin=section,
refname={theorem, theorems},
Refname={Theorem, Theorems}
]{thm}
\declaretheorem[
name=Lemma,
numberlike=thm,
refname={lemma, lemmas},
Refname={Lemma, Lemmas}
]{lem}
\declaretheorem[
name=Rule,
refname={rule,rules},
Refname={Rule,Rules}
]{crule}

\makeatletter
\declaretheoremstyle[
style=definition,
bodyfont={
  \addtolength{\@totalleftmargin}{0.5cm}
  \addtolength{\linewidth}{-0.5cm}
  \parshape 1 0.5cm \linewidth
}
]{idefinition}
\makeatother

\declaretheorem[
name=Definition,
refname={definition,definitions},
Refname={Definition,Definitions}, numberlike=thm, style=idefinition
]{defn}

\renewcommand{\circblockbegin}{\left(\begin{array}{l}}
\renewcommand{\circblockend}{\end{array}\right)}

%TC:group zed 0 displaymath
%TC:group axdef 0 displaymath
%TC:group schema 1 displaymath
%TC:group circus 0 displaymath
%TC:group circusaction 0 displaymath
%TC:macroword \Circus 1
%TC:group theorem 1 displaymath
%TC:group zproof 0 displaymath 
%TC:group algorithm 0 float

\begin{document}
\maketitle

\begin{abstract}
  In recent years Java has been increasingly considered as a language
  for safety-critical embedded systems.
  However, some features of Java are unsuitable for such systems and
  this has resulted in the creation of Safety-Critical Java (SCJ).
  The different scheduling and memory management model of SCJ means
  that a specialised virtual machine is required to run SCJ programs.
  Given the safety-critical nature of the applications, it must be
  ensured that the virtual machine is correct, but so far no SCJ
  virtual machine has been formally verified.
  In this dissertation, we propose a framework for verification of SCJ
  virtual machines.
  We consider the differences between SCJ and standard Java, and
  discuss some of the existing virtual machines for SCJ.
  Seeing that many SCJ virtual machines precompile to native code, we
  then survey some of the literature on compiler correctness.
  Finally, we present some preliminary results identifying the
  requirements of the services of an SCJ virtual machine and
  constructing a formal model of those requirements.
\end{abstract}

\tableofcontents

\include{introduction}

\include{field-survey}

\include{scjvm-services}

\include{cee}

\include{compilationstrategy}

\include{conclusion}

{\raggedright \printbibliography}

\appendix

\chapter{Full SCJVM Services Model}
\label{full-scjvm-services-model}
\FullModeltrue

\section{Memory Manager}
\input{../../SCJ-VM/James/memorymanager.zed}

\section{Scheduler}
\input{../../SCJ-VM/James/scheduler.zed}

\section{Real-Time Clock}
\input{../../SCJ-VM/James/realtimeclock.zed}

\section{Complete SCJVM Services Model}
\input{../../SCJ-VM/James/scjvmservices.zed}

\chapter{Full Core Execution Environment Model}
\label{full-cee-model}

\section{Classes}
\input{../../SCJ-VM/James/classes.zed}

\section{Channels declarations}
\label{cee-model-channels}

\input{../../SCJ-VM/James/LIchans.zed}

\input{../../SCJ-VM/James/memory_chans.zed}

\section{Object Manager}
\label{object-manager-appendix}
\input{../../SCJ-VM/James/memory.zed}

\section{Stack Frames}
\input{../../SCJ-VM/James/stack_frames.zed}

\section{Interpreter}

\input{../../SCJ-VM/James/interpreter_thread.zed}

\input{../../SCJ-VM/James/interpreter.zed}

\section{Launcher}
\label{launcher-appendix}
\input{../../SCJ-VM/James/launcher.zed}

\section{Complete Core Execution Environment}
\input{../../SCJ-VM/James/complete_cee.zed}

\chapter{Compilation Rules}
\input{compilationrules.tex}

\chapter{Z/Eves Theorems and Proofs}
\label{zeves-proofs}

\section{Additional Toolkit Lemmas}
\label{additional-lemmas}
\normalsize

%TC:ignore
\input{../../SCJ-VM/James/additional_lemmas.zed} 
%TC:endignore

\section{Proofs of Additional Toolkit Lemmas}
\label{additional-lemmas-proofs}
\scriptsize

%TC:ignore
\input{../../SCJ-VM/James/additional_lemmas_sets_proofs.zed}
\input{../../SCJ-VM/James/additional_lemmas_relations_proofs.zed}
\input{../../SCJ-VM/James/additional_lemmas_numbers_proofs.zed}
%TC:endignore

\section{Memory Manager Theorems}
\label{memory-manager-theorems}
\normalsize

%TC:ignore
\input{../../SCJ-VM/James/memorymanager_theorems.zed}
%TC:endignore

\section{Proofs of Memory Manager Theorems}
\label{memory-manager-proofs}
\scriptsize

%TC:ignore
\input{../../SCJ-VM/James/memorymanager_proofs.zed}
%TC:endignore

\end{document}

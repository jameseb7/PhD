\documentclass[a4paper,11pt]{report}

\usepackage[table]{xcolor}
\usepackage{array}
\usepackage[in]{fullpage}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{parskip}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage[backend=bibtex,style=numeric-comp,sorting=nyt,sortcites=true,maxnames=4]{biblatex}
\usepackage{placeins}
\usepackage[color,cntglobally]{circus}
\usepackage{mathdots}
\usepackage{multicol}
\usepackage{listings}
\usepackage{vwcol}
\usepackage{fixltx2e}
\usepackage{comment}
\usepackage{subcaption}
%\usepackage{cleveref}
\usepackage{thmtools}
\usepackage{thm-restate}

\usetikzlibrary{calc}
\usetikzlibrary{arrows}
\usetikzlibrary{graphs}

\setcounter{secnumdepth}{4}

\title{An Approach to Verification of Ahead-of-time Compilation for
  Safety-Critical Java}
\author{James Baxter}
\date{}

\bibliography{literature} 

\CountDefsfalse

\newif\ifFullModel
\FullModelfalse
\newcommand{\ifnFullModel}{\ifFullModel\else}

\newcommand{\directsubclass}{\prec_{\mathrm{d}}}
\newcommand{\directsubclassid}[1]{\prec_{\mathrm{D},#1}}
\newcommand{\subclassid}[1]{\preceq_{#1}}

\makeatletter
\def\@endtheorem{\endtrivlist}
\def\thm@space@setup{%
  \thm@preskip=\parskip \thm@postskip=0pt
}
\makeatother

% \theoremstyle{plain}
% \newtheorem{thm}{Theorem}[section]
% \newtheorem{lem}[thm]{Lemma}
% \newtheorem{rule}{Rule}
\declaretheorem[
name=Theorem,
numberwithin=section,
refname={Theorem, Theorems},
Refname={Theorem, Theorems}
]{thm}
\declaretheorem[
name=Lemma,
numberlike=thm,
refname={Lemma, Lemmas},
Refname={Lemma, Lemmas}
]{lem}

\declaretheoremstyle[
style=plain,
notebraces={[}{]}
]{rule}

\declaretheorem[
name=Rule,
style=rule,
numbered=no,
refname={Rule,Rules},
Refname={Rule,Rules}
]{crule}

\declaretheorem[
name=Law,
style=rule,
numbered=no,
refname={Law,Laws},
Refname={Law,Laws}
]{law}

\makeatletter
\declaretheoremstyle[
style=definition,
bodyfont={
  \addtolength{\@totalleftmargin}{0.5cm}
  \addtolength{\linewidth}{-0.5cm}
  \parshape 1 0.5cm \linewidth
}
]{idefinition}
\makeatother

\declaretheorem[
name=Definition,
refname={definition,definitions},
Refname={Definition,Definitions}, numberlike=thm, style=idefinition
]{defn}

\declaretheoremstyle[
style=definition,
notebraces={[}{]}
]{proof}

\declaretheorem[
name=Proof,
style=proof,
numbered=no,
prefoothook={\qedsymbol\relax}
]{crproof}

\renewcommand{\circblockbegin}{\left(\begin{array}{l}}
\renewcommand{\circblockend}{\end{array}\right)}

\newcommand{\Apply}[1]{{\bf apply} #1}
\newcommand{\ApplyFor}[2]{{\bf apply} #1 {\bf for} #2}
\newcommand{\ApplyTo}[2]{{\bf apply} #1 {\bf to} #2}
\newcommand{\ApplyToFor}[3]{{\bf apply} #1 {\bf to} #2 {\bf for} #3}
\algblockx[Try]{Try}{EndTry}
  {{\bf try}}
  {{\bf end try}}

%TC:group zed 0 displaymath
%TC:group axdef 0 displaymath
%TC:group schema 1 displaymath
%TC:group circus 0 displaymath
%TC:group circusaction 0 displaymath
%TC:macroword \Circus 1
%TC:group theorem 1 displaymath
%TC:group zproof 0 displaymath 
%TC:group algorithm 0 float

\begin{document}
\maketitle


\begin{abstract}
  In recent years Java has been increasingly considered as a language
  for safety-critical embedded systems.
  However, some features of Java are unsuitable for such systems.
  This has resulted in the creation of Safety-Critical Java (SCJ),
  which facilitates the creation of certifiable real-time and embedded
  Java programs.
  SCJ uses different scheduling and memory management models to
  standard Java, so it requires a specialised virtual machine (SCJVM).
  Several such virtual machines have been developed.
  A common approach of these virtual machines is to compile Java
  bytecode program to a native language, usually C, ahead-of-time for
  greater performance on low-resource embedded systems.
  
  Given the safety-critical nature of the applications, it must be
  ensured that the virtual machine is correct.
  However, so far formal verification has not been applied to any
  SCJVM.
  This thesis contributes to the formal verification of SCJVMs that
  utilise ahead-of-time compilation by presenting a verification of
  compilation from Java bytecode to C.
  The approach we adopt to verifying compilation is an adaptation of
  the algebraic approach developed by Augusto Sampaio.
  Our approach involves beginning with a formal specification of an
  SCJVM executing the bytecodes of a program and transforming it,
  through the application of proven compilation rules, to a
  representation of the target C code.
  Thus, our contributions are a formal specification of an SCJVM, a
  set of compilation rules with proofs, and a strategy for applying
  those compilation rules.
  
  Our compilation strategy can be used as the basis for an
  implementation of an ahead-of-time compiling SCJVM, or verification
  of an existing implementation.
  Additionally, our formal model of an SCJVM may be used as a
  specification for creating an interpreting SCJVM.
  To ensure the applicability of our results, we base our work on
  icecap, the only SCJVM that is open source and up-to-date with the
  SCJ standard.
\end{abstract}

\tableofcontents

\input{introduction.tex}

\input{field-survey.tex}

\input{scjvm-services.tex}

\input{cee.tex}

\input{compilationstrategy.tex}

\input{evaluation.tex}

\input{conclusion.tex}

{\raggedright \printbibliography}

\appendix

%TC:ignore
\chapter{Full SCJVM Services Model}
\label{full-scjvm-services-model}
\FullModeltrue

\section{Memory Manager}
\input{../../SCJ-VM/James/memorymanager.zed}

\section{Scheduler}
\input{../../SCJ-VM/James/scheduler.zed}

\section{Real-Time Clock}
\input{../../SCJ-VM/James/realtimeclock.zed}

\section{Complete SCJVM Services Model}
\input{../../SCJ-VM/James/scjvmservices.zed}

\chapter{Full Core Execution Environment Model}
\label{full-cee-model}

\section{Classes}
\input{../../SCJ-VM/James/classes.zed}

\section{Channels declarations}
\label{cee-model-channels}

\input{../../SCJ-VM/James/LIchans.zed}

\input{../../SCJ-VM/James/memory_chans.zed}

\section{Object Manager}
\label{object-manager-appendix}
\input{../../SCJ-VM/James/memory.zed}

\section{Stack Frames}
\input{../../SCJ-VM/James/stack_frames.zed}

\section{Interpreter}
\label{interpreter-appendix}

\input{../../SCJ-VM/James/interpreter_thread.zed}

\input{../../SCJ-VM/James/interpreter.zed}

\section{Launcher}
\label{launcher-appendix}
\input{../../SCJ-VM/James/launcher.zed}

\section{Complete Core Execution Environment}
\input{../../SCJ-VM/James/complete_cee.zed}

\section{Post-compilation Struct Manager}
\label{struct-manager-appendix}
\input{../../SCJ-VM/James/struct_manager.zed}

\chapter{Compilation Rules}
\label{compilation-rules-appendix}

\input{compilationrules.tex}

\chapter{Algebraic Laws}
\input{algebraiclaws.tex}

\chapter{Z/Eves Theorems and Proofs}
\label{zeves-proofs}

\section{Additional Toolkit Lemmas}
\label{additional-lemmas}
\normalsize

\input{../../SCJ-VM/James/additional_lemmas.zed} 

\section{Proofs of Additional Toolkit Lemmas}
\label{additional-lemmas-proofs}
\scriptsize

\input{../../SCJ-VM/James/additional_lemmas_sets_proofs.zed}
\input{../../SCJ-VM/James/additional_lemmas_relations_proofs.zed}
\input{../../SCJ-VM/James/additional_lemmas_numbers_proofs.zed}

\section{Memory Manager Theorems}
\label{memory-manager-theorems}
\normalsize

\input{../../SCJ-VM/James/memorymanager_theorems.zed}

\section{Proofs of Memory Manager Theorems}
\label{memory-manager-proofs}
\scriptsize

\input{../../SCJ-VM/James/memorymanager_proofs.zed}

\chapter{Compilation Rules Proofs}
\label{compilation-rules-proofs-appendix}
\input{compilationrules_proofs.tex}

%TC:endignore

\end{document}

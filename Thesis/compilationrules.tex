\section{Elimination of Program Counter}

\subsection{Expand Bytecode}

\PCExpansionRule*

\HandleInstructionRefinementRule*

\subsection{Introduce Sequential Composition}

\SequenceIntroductionRule*

\subsection{Introduce Loops and Conditionals}

\IfConditionalIntroductionRule*

\begin{restatable}[\texttt{if}-\texttt{else}-conditional-intro]{crule}{IfElseConditionalIntroductionRule}
  \label{if-else-introduction-rule}
  \setlength{\zedindent}{0.25cm}
  % \setlength{\abovedisplayskip}{0.1cm}
  % \setlength{\belowdisplayskip}{0.1cm}
  Given $i : ProgramAddress$, if $i \neq j$, $i \neq k$, and 
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 pc := \IF b \THEN j \ELSE k \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = j \circthen B \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen C \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 \circif b \circthen pc := j \circseq Poll \circseq B \\
      \t3 {} \circelse \lnot b \circthen pc := k \circseq Poll \circseq C \\
      \t3 \circfi \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = j \circthen B \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen C \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[conditional-intro]{crule}{ConditionalIntroductionRule}
  \label{conditional-introduction-rule}
  \setlength{\zedindent}{0.25cm}
  % \setlength{\abovedisplayskip}{0.1cm}
  % \setlength{\belowdisplayskip}{0.1cm}
  Given $i : ProgramAddress$, if $i \neq j$, $i \neq k$, and
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 pc := \IF b \THEN j \ELSE k \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = j \circthen B \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen C \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 \circif b \circthen pc := j \circseq Poll \circseq B \\
      \t3 {} \circelse \lnot b \circthen pc := k \circseq Poll \circseq C \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = j \circthen B \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen C \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}

\WhileLoopIntroductionRuleA*

\begin{crule}[\texttt{while}-loop-intro2]
  \label{while-introduction-rule2}
  \setlength{\zedindent}{0.2cm}
  \setlength{\zedtab}{0.9\zedtab}
  Given $i : ProgramAddress$, if $i \neq j$,
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 pc := \IF b \THEN j \ELSE k \\
      \t2 \cdots \\
      \t2 {} \circelse pc = j \circthen B \circseq pc := i \\
      \t2 \cdots \\
      \t2 {} \circelse pc = k \circthen C \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen (\circmu Y \circspot A \circseq \\
      \t3 \circif b \circthen \\
      \t4 pc := j \circseq Poll \circseq B \circseq pc := i \circseq Poll \circseq Y \\
      \t3 {} \circelse \lnot b \circthen C \\
      \t3 \circfi) \circseq pc := k \\
      \t2 \cdots \\
      \t2 {} \circelse pc = j \circthen B \circseq pc := i \\
      \t2 \cdots \\
      \t2 {} \circelse pc = k \circthen C \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{crule}

\begin{restatable}[\texttt{do}-\texttt{while}-loop-intro]{crule}{DoWhileLoopIntroductionRule}
  \label{do-while-introduction-rule}
  \def\zedindent{0.25cm}
  Given $i : ProgramAddress$, if $i \neq j$,
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 pc := \IF b \THEN i \ELSE j \\
      \t2 \cdots \\
      \t2 {} \circelse pc = j \circthen B \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen (\circmu Y \circspot A \\
      \t3 \circif b \circthen pc := i \circseq Poll \circseq Y \\
      \t3 {} \circelse \lnot b \circthen \Skip \\
      \t3 \circfi) \circseq pc := j \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[infinite-loop-intro]{crule}{InfiniteLoopIntroductionRule}
  \label{infinite-loop-introduction-rule}
  Given $i : ProgramAddress$, if
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \def\zedindent{0.25cm}
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen {} \\
      \t3 A \circseq pc := i \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen {} \\
      \t3 \circmu Y \circspot A \circseq pc := i \circseq Poll \circseq Y \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
  \end{circus}
\end{restatable}

\subsection{Resolve Method Calls}

\begin{restatable}[refine-invokespecial]{crule}{RefineInvokespecialRule}
  \label{refine-invokespecial-rule}
  \setlength{\zedindent}{0.25cm}
  \begin{circus}
    \begin{array}{l}
      \{ pc = i \} \circseq \\
      HandleInvokespecialEPC(cpi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ pc = i \} \circseq \circvar poppedArgs : \seq Word \circspot \\
      \t1 \lschexpract \exists argsToPop? == methodArguments~m + 1 @ \\
      \t2 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t1 Invoke(c, m, poppedArgs, \false)
    \end{array}
  \end{circus}
  where $m : MethodID$ and $c : ClassID$ are such that
  \begin{displaymath}
    \exists c_0 : Class; m_0 : MethodID | c_0 \in \ran cs \land m_0 \in \dom c_0.methodEntry @ \\
    \t1 cpi \in methodRefIndices~c_0 \land \\
    \t1 (\exists c_1 : ClassID | c_0.constantPool~cpi = MethodRef~(c_1,m) @ \\
    \t2 (((thisClassID~c_0,c_1) \in subclassRel~cs \land c_1 \neq thisClassID~c_0) \\
    \t3 {} \implies c = superClassID~c_0) \land \\
    \t2 (((thisClassID~c_0,c_1) \notin subclassRel~cs \lor c_1 = thisClassID~c_0) \\
    \t3 {} \implies c = c_1)) \land \\
    \t1 i \in c_0.methodEntry~m_0 \upto c_0.methodEnd~m_0.
  \end{displaymath}
\end{restatable}

\RefineInvokestaticRule*

\begin{restatable}[refine-invokevirtual-single]{crule}{RefineInvokeVirtualSingleRule}
  \label{refine-invokevirtual-single-rule}
  \setlength{\zedindent}{0.25cm}
  \begin{circus}
    \begin{array}{l}
      \{ pc = i \} \circseq \\
      HandleInvokevirtualEPC(cpi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ pc = i \} \circseq \circvar poppedArgs : \seq Word \circspot \\
      \t1 \lschexpract \exists argsToPop? == methodArguments~m @ \\
      \t2 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t1 getClassIDOf!(head~poppedArgs)?cid \\
      \t1 {} \then Invoke(c, m, poppedArgs, \false)
    \end{array}
  \end{circus}
  where $m : MethodID$ and $c : ClassID$ are such that
  \begin{displaymath}
    \exists c_0 : Class; m_0 : MethodID | c_0 \in \ran cs \land m_0 \in \dom c_0.methodEntry @ \\
    \t1 cpi \in methodRefIndices~c_0 \land \\
    \t1 c_0.constantPool~cpi = MethodRef~(c,m) \land \\
    \t1 i \in c_0.methodEntry~m_0 \upto c_0.methodEnd~m_0,
  \end{displaymath}
  and provided $\exists_1 c_1 : ClassID @ (c_1,c) \in subclassRel~cs$.
\end{restatable}

\ResolveSpecialMethodRule*

\begin{restatable}[resolve-special-method-virtual]{crule}{ResolveSpecialMethodVirtualRule}
  \label{resolve-special-method-virtual-rule}
  If $c$, $m$ and $static$ match one of the rows of
  Table~\ref{special-method-action-table}, then
  \setlength{\zedindent}{0.25cm} \setlength{\zedtab}{0.5cm}
  \begin{circus}
    \begin{array}{l}
      \{ pc = i \} \circseq \circvar poppedArgs : \seq Word \circspot \\
      \lschexpract \exists argsToPop? == e @ \\
      \t1 InterpreterStackFrameInvoke \rschexpract \circseq \\
      getClassIDOf!(head~poppedArgs)?cid \\
      {} \then Invoke(c, m, poppedArgs, static)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circvar poppedArgs : \seq Word \circspot \\
      \lschexpract \exists argsToPop? == e @ \\
      \t1 InterpreterStackFrameInvoke \rschexpract \circseq \\
      getClassIDOf!(head~poppedArgs)?cid \\
      {} \then specialMethodAction(c, m, static) \circseq \\
      pc := i + 1
    \end{array}
  \end{circus}
  where $specialMethodAction$ is the syntactic function defined by
  Table~\ref{special-method-action-table}.
\end{restatable}

\ResolveNormalMethodRule*

\begin{restatable}[resolve-normal-method-virtual]{crule}{ResolveNormalMethodVirtualRule}
  \label{resolve-normal-method-virtual-rule}
  Given $i : ProgramAddress$, if
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\},
  \end{circus}
  and there exists $classInfo : Class$ in $\ran cs$ such that,
  \begin{circus}
    \{ methodID = m \land classID = c \} \circseq \lschexpract ResolveMethod \rschexpract \\
    {} = {} \\
    \{ methodID = m \land classID = c \} \circseq \lschexpract ResolveMethod \rschexpract \circseq \\
    \t1 \{ class = classInfo \land classInfo.methodEntry~m = k \},
  \end{circus}
  and, for any $x : ProgramAdress$,
  \begin{circus}
    \{ (last~(front~frameStack)).storedPC = x \} \circseq M \\
    {} = {} \\
    \{ (last~(front~frameStack)).storedPC = x \} \circseq M \circseq \{ pc = x \},
  \end{circus}
  and $m$ and $c$ do not match any of the conditions in
  Table~\ref{special-method-action-table} then,
  \setlength{\zedindent}{0cm}
  \setlength{\zedtab}{0.45cm}
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \{ pc = j \} \circseq \\
      \t3 \circvar poppedArgs : \seq Word \circspot \\
      \t3 \lschexpract \exists argsToPop? == e @ \\
      \t4 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t3 getClassIDOf!(head~poppedArgs)?cid \\
      \t3 {} \then Invoke(c, m, poppedArgs, \false) \\
      \t2 {} \circelse pc = k \circthen M \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 (\circvar poppedArgs : \seq Word \circspot \\
      \t3 \lschexpract \exists argsToPop? == e @ \\
      \t4 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t3 getClassIDOf!(head~poppedArgs)?cid \\
      \t3 {} \then \lschexpract InterpreterNewStackFrame[ \\
      \t4 classInfo/class?, \\
      \t4 m/methodID?, \\
      \t4 poppedArgs/methodArgs?] \rschexpract)) \circseq \\
      \t3 Poll \circseq M \circseq pc := j + 1 \\
      \t2 {} \circelse pc = k \circthen M \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}

\RefineInvokeVirtualMultiRule*

\begin{restatable}[resolve-special-method-branch]{crule}{ResolveSpecialMethodBranchRule}
  \label{resolve-special-method-branch-rule}
  Given $c_\ell : ClassID$, if $c = c_\ell$, $m$ and $static = \false$
  match one of the rows of Table~\ref{special-method-action-table},
  then
  \setlength{\zedindent}{0.25cm}
  \setlength{\zedtab}{0.5cm}
  \begin{circus}
    \begin{array}{l}
      \circvar poppedArgs : \seq Word \circspot \\
      \lschexpract \exists argsToPop? == e @ \\
      \t1 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \circif cid = c_1 \circthen A_1 \\
      {} \cdots {} \\
      {} \circelse cid = c_\ell \circthen {} \\
      \t1 \{ (last~frameStack).storedPC = j + 1 \} \circseq \\
      \t1 Invoke(c_\ell, m, poppedArgs, \false) \\
      {} \cdots {} \\
      {} \circelse cid = c_n \circthen A_n \\
      \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ pc = i \} \circseq \circvar poppedArgs : \seq Word \circspot \\
      \lschexpract \exists argsToPop? == e @ \\
      InterpreterStackFrameInvoke \rschexpract \circseq \\
      \circif cid = c_1 \circthen A_1 \\
      {} \cdots {} \\
      {} \circelse cid = c_\ell \circthen {} \\
      \t1 specialMethodAction(c_\ell, m, \false) \circseq pc := i + 1 \\
      {} \cdots {} \\
      {} \circelse cid = c_n \circthen A_n \\
      \circfi
    \end{array} 
  \end{circus}
  where $specialMethodAction$ is the syntactic function defined by
  Table~\ref{special-method-action-table}.
\end{restatable}

\begin{restatable}[resolve-normal-method-branch]{crule}{ResolveNormalMethodBranchRule}
  \label{resolve-normal-method-branch-rule}
  \setlength{\zedtab}{0.4cm}
  Given $i : ProgramAddress$, if
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\},
  \end{circus}
  and there exists $classInfo : Class$ in $\ran cs$ such that,
  \begin{circus}
    \{ methodID = m \land classID = c \} \circseq \lschexpract ResolveMethod \rschexpract \\
    {} = {} \\
    \{ methodID = m \land classID = c \} \circseq \lschexpract ResolveMethod \rschexpract \circseq \\
    \t1 \{ class = classInfo \land classInfo.methodEntry~m = k \},
  \end{circus}
  and, for any $x : ProgramAddress$,
  \begin{circus}
    \{ (last~(front~frameStack)).storedPC = x \} \circseq M \\
    {} = {} \\
    \{ (last~(front~frameStack)).storedPC = x \} \circseq M \circseq \{ pc = x \},
  \end{circus}
  and $m$ and $c$ do not match any of the conditions in
  Table~\ref{special-method-action-table} then,
  \setlength{\zedindent}{0.25cm}
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 \circvar poppedArgs : \seq Word \circspot \\
      \t3 \lschexpract \exists argsToPop? == e @ \\
      \t4 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t3 \circif cid = c_1 \circthen A_1 \\
      \t3 {} \cdots {} \\
      \t3 {} \circelse cid = c_\ell \circthen {} \\
      \t4 \{ (last~frameStack).storedPC = j + 1 \} \circseq \\
      \t4 Invoke(c_\ell, m, poppedArgs, \false) \\
      \t3 {} \cdots {} \\
      \t3 {} \circelse cid = c_n \circthen A_n \\
      \t3 \circfi \\
      \t2 {} \circelse pc = k \circthen M \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \{ pc = j \} \circseq  \\
      \t3 \circvar poppedArgs : \seq Word \circspot \\
      \t3 \lschexpract \exists argsToPop? == e @ \\
      \t4 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t3 \circif cid = c_1 \circthen A_1 \\
      \t3 {} \cdots {} \\
      \t3 {} \circelse cid = c_\ell \circthen {} \\
      \t4 \lschexpract InterpreterNewStackFrame[ \\
      \t5 classInfo/class?,
      \t5 m/methodID?, \\
      \t5 poppedArgs/methodArgs?] \rschexpract) \circseq \\
      \t4 Poll \circseq M \circseq pc := j + 1 \\
      \t3 {} \cdots {} \\
      \t3 {} \circelse cid = c_n \circthen A_n \\
      \t3 \circfi \\
      \t2 {} \circelse pc = k \circthen M \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}

\subsection{Refine Main Actions}

\RunningRefinementRule*

\section{Elimination of Frame Stack}

\subsection{Remove Launcher Returns}
\label{remove-launcher-returns-appendix-subsection}

\begin{algorithm}[htb!]
  \begin{algorithmic}[1]
    \State $methodBody \gets$ \Call{ActionBody}{$methodName$}
    \Match{$methodBody$}{($A \circseq returnAction$)}
    \State \ApplyFor{Law~[\nameref{action-intro-law}]}{$methodName'$, $A$}
    \State \ApplyReverseToFor{Law~[\nameref{copy-rule-law}]}{$methodBody$}{$methodName'$}
    \State \ExhaustivelyApplyFor{Law~[\nameref{copy-rule-law}]}{$methodName$}
    \State \ApplyReverseFor{Law~[\nameref{action-intro-law}]}{$methodName$, $methodBody$}
    \State \ApplyFor{Law~[\nameref{action-rename-law}]}{$methodName$, $methodName'$}
  \end{algorithmic}
  \caption{RedefineMethodActionExcludingReturnAction($methodName$,$returnAction$)}
  \label{redefine-method-action-excluding-return-action-algorithm}
\end{algorithm}

\begin{algorithm}[htb!]
  \begin{algorithmic}[1]
    \State \Apply{Rule~[\nameref{InterpreterInitEPC-frameStack-assump-intro-rule}]} 
    \State {\bf exhaustively apply} \\
    $\t1$ Rule~[\nameref{frameStack-assump-non-return-dist-rule}] \\
    $\t1$ Rule~[\nameref{frameStack-assump-return-dist-rule}] \\
    $\t1$ Rule~[\nameref{frameStack-assump-NewStackFrame-dist-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-alt-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-alt-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-var-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-var-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-output-prefix-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-output-prefix-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-input-prefix-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-input-prefix-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-infinite-loop-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-infinite-loop-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-while-loop-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-while-loop-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-do-while-loop-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-do-while-loop-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-mid-while-loop-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-mid-while-loop-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-extchoice-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-extchoice-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-guard-dist-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-assign-dist-rule}]
  \end{algorithmic}
  \caption{IntroduceFrameStackAssumptions}
  \label{introduce-frameStack-assumptions-algorithm}
\end{algorithm}

\FloatBarrier

\begin{restatable}[$InterpreterInitEPC$-$frameStack$-assump-intro]{crule}{InterpreterInitEPCFrameStackAssumpIntro}
  \label{InterpreterInitEPC-frameStack-assump-intro-rule}
  \begin{circus}
    \begin{array}{l}
      \lschexpract InterpreterInitEPC \rschexpract
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \lschexpract InterpreterInitEPC \rschexpract \circseq
      \{ \# frameStack = 0 \}
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$frameStack$-assump-NewStackFrame-dist]{crule}{FrameStackAssumpNewStackFrameDist}
  \label{frameStack-assump-NewStackFrame-dist-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# frameStack = k\} \circseq \\
      \lschexpract InterpreterNewStackFrame[ \\
      \t1 c/class?,
      \t1 m/methodID?, \\
      \t1 args/methodArgs?]\rschexpract
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \lschexpract InterpreterNewStackFrame[ \\
      \t1 c/class?,
      \t1 m/methodID?, \\
      \t1 args/methodArgs?]\rschexpract \circseq \\
      \{\# frameStack = k + 1 \}
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$frameStack$-assump-non-return-dist]{crule}{FrameStackAssumpNonReturnDist}
  \label{frameStack-assump-non-return-dist-rule}
  If $A$ is one of
  \begin{itemize}
  \item $\Skip$
  \item $Poll$,
  \item $HandleAconst\_nullEPC$,
  \item $HandleDupEPC$,
  \item $HandleAloadEPC(lvi)$,
  \item $HandleAstoreEPC(lvi)$,
  \item $HandleIaddEPC$,
  \item $HandleIconstEPC(n)$,
  \item $HandleInegEPC$,
  \item $\lschexpract InterpreterPopEPC \rschexpract$,
  \item $\lschexpract InterpreterPushEPC \rschexpract$,
  \item $\lschexpract \exists argsToPop? == m @ InterpreterStackFrameInvoke \rschexpract$,
  \item $HandleNewEPC(cpi)$,
  \item $HandleGetfieldEPC(cpi)$,
  \item $HandlePutfieldEPC(cpi)$,
  \item $HandleGetstaticEPC(cpi)$, or
  \item $HandlePutstaticEPC(cpi)$,
  \end{itemize}
  and $B$ does not begin with $\{\# frameStack = k\}$, then
  \begin{circus}
    \begin{array}{l}
      \{\# frameStack = k\} \circseq A \circseq B
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{\# frameStack = k\} \circseq A \circseq \{\# frameStack = k \} \circseq B
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$frameStack$-assump-return-dist-rule]{crule}{FrameStackAssumpReturnDist}
  \label{frameStack-assump-return-dist-rule}
  If $A$ is $HandleAreturn$ or $HandleReturn$, $B$ does not begin with
  $\{\# frameStack = k\}$, and $k > 0$ then
  \begin{circus}
    \begin{array}{l}
      \{\# frameStack = k\} \circseq A \circseq B
    \end{array}
    \circrefines_A
    \begin{array}{l}
      A \circseq \{\# frameStack = k - 1 \} \circseq B
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[restricted-assump-alt-distl]{crule}{RestrictedAssumpAltDistl}
  \label{restricted-assump-alt-distl-rule}
  If no $A_i$ begins with $\{h\}$ then
  \begin{circus}
    \{h\} \circseq \circif {} \circelse_{i} g_i \circthen A_i \circfi
    =
    \{h\} \circseq \circif {} \circelse_{i} g_i \circthen \{h\} \circseq A_i \circfi
  \end{circus}
\end{restatable}

\begin{restatable}[restricted-assump-alt-distr]{crule}{RestrictedAssumpAltDistr}
  \label{restricted-assump-alt-distr-rule}
  If no $A_i$ begins with $\{h\}$ then
  \begin{circus}
    \circif {} \circelse_{i} g_i \circthen A_i \circseq \{h\} \circfi
    =
    \{h\} \circseq \circif {} \circelse_{i} g_i \circthen A_i \circfi \circseq \{h\}
  \end{circus}
\end{restatable}

\begin{restatable}[restricted-assump-var-distl]{crule}{RestrictedAssumpVarDistl}
  \label{restricted-assump-var-distl-rule}
  If $A$ does not begin with $\{h\}$ then
  \begin{circus}
    \{h\} \circseq (\circvar x : T \circspot A)
    =
    \{h\} \circseq (\circvar x : T \circspot \{h\} \circseq A)
  \end{circus}
\end{restatable}

\begin{restatable}[restricted-assump-var-distr]{crule}{RestrictedAssumpVarDistr}
  \label{restricted-assump-var-distr-rule}
  If $B$ does not begin with $\{h\}$ then
  \begin{circus}
    (\circvar x : T \circspot A \circseq \{h\}) \circseq B
    =
    (\circvar x : T \circspot A \circseq \{h\}) \circseq \{h\} \circseq B
  \end{circus}
\end{restatable}

\begin{restatable}[restricted-assump-output-prefix-distl]{crule}{RestrictedAssumpOutputPrefixDistl}
  \label{restricted-assump-output-prefix-distl-rule}
  If $A$ does not begin with $\{g\}$  then
  \begin{circus}
    \{ g \} \circseq c!x \then A = \{ g \} \circseq c!x \then \{ g \} \circseq A
  \end{circus}
\end{restatable}

\begin{restatable}[restricted-assump-output-prefix-distr]{crule}{RestrictedAssumpOutputPrefixDistr}
  \label{restricted-assump-output-prefix-distr-rule}
  If $B$ does not begin with $\{g\}$ then
  \begin{circus}
    (c!x \then A \circseq \{ g \}) \circseq B
    =
    (c!x \then A \circseq \{ g \}) \circseq \{ g \} \circseq B
  \end{circus}
\end{restatable}

\begin{restatable}[restricted-assump-input-prefix-distl]{crule}{RestrictedAssumpInputPrefixDistl}
  \label{restricted-assump-input-prefix-distl-rule}
  If $A$ does not begin with $\{g\}$ and $x$ is not free in $\{g\}$
  then
  \begin{circus}
    \{ g \} \circseq c?x \then A
    =
    \{ g \} \circseq c?x \then \{ g \} \circseq A
  \end{circus}
\end{restatable}

\begin{restatable}[restricted-assump-input-prefix-distr]{crule}{RestrictedAssumpInputPrefixDistr}
  \label{restricted-assump-input-prefix-distr-rule}
  If $B$ does not begin with $\{g\}$ and $x$ is not free in $\{g\}$ then
  \begin{circus}
    (c?x \then A \circseq \{ g \}) \circseq B
    =
    (c?x \then A \circseq \{ g \}) \circseq \{ g \} \circseq B
  \end{circus}
\end{restatable}

\begin{restatable}[restricted-assump-infinite-loop-distl]{crule}{RestrictedAssumpInfiniteLoopDistl}
  \label{restricted-assump-infinite-loop-distl-rule}
  If $A$ does not begin with $\{g\}$ and
  $\{g\} \circseq A \circrefines_A A \circseq \{g\} $ then
  \begin{circus}
    \{g\} \circseq (\circmu X \circspot A \circseq X)
    \circrefines_A
    \{g\} \circseq (\circmu X \circspot \{g\} \circseq A \circseq X)
  \end{circus}
\end{restatable}

\begin{restatable}[restricted-assump-infinite-loop-distr]{crule}{RestrictedAssumpInfiniteLoopDistr}
  \label{restricted-assump-infinite-loop-distr-rule}
  If $B$ does not begin with $\{g\}$ then
  \begin{circus}
    (\circmu X \circspot A \circseq \{g\} \circseq X) \circseq B
    =
    (\circmu X \circspot A \circseq \{g\} \circseq X) \circseq \{g\} \circseq B
  \end{circus}
\end{restatable}

\begin{restatable}[restricted-assump-mid-while-loop-distl]{crule}{RestrictedAssumpMidWhileLoopDistl}
  \label{restricted-assump-mid-while-loop-distl-rule}
  If $A$ does not begin with $\{g\}$,
  $\{g\} \circseq A \circrefines_A A \circseq \{g\}$,
  $\{g\} \circseq B \circrefines_A B \circseq \{g\}$,
  then
  \begin{circus}
    \begin{array}{l}
      \{g\} \circseq (\circmu X \circspot A \circseq \\
      \t1 \circif h \circthen B \circseq X \\
      \t1 {} \circelse \lnot h \circthen \Skip \\
      \t1 \circfi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{g\} \circseq (\circmu X \circspot \{g\} \circseq A \circseq \\
      \t1 \circif h \circthen B \circseq X \\
      \t1 {} \circelse \lnot h \circthen \Skip \\
      \t1 \circfi)
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[restricted-assump-mid-while-loop-distr]{crule}{RestrictedAssumpMidWhileLoopDistr}
  \label{restricted-assump-mid-while-loop-distr-rule}
  If $C$ does not begin with $\{g\}$,
  $\{g\} \circseq A \circrefines_A A \circseq \{g\}$,
  $\{g\} \circseq B \circrefines_A B \circseq \{g\}$,
  then
  \begin{circus}
    \begin{array}{l}
      (\circmu X \circspot A \circseq \\
      \t1 \circif h \circthen B \circseq \{g\} \circseq X \\
      \t1 {} \circelse \lnot h \circthen \Skip \circseq \{g\} \\
      \t1 \circfi) \circseq C
    \end{array}
    \circrefines_A
    \begin{array}{l}
      (\circmu X \circspot A \circseq \\
      \t1 \circif h \circthen B \circseq \{g\} \circseq X \\
      \t1 {} \circelse \lnot h \circthen \Skip \circseq \{g\}  \\
      \t1 \circfi) \circseq \{g\} \circseq C
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[restricted-assump-do-while-loop-distl]{crule}{RestrictedAssumpDoWhileLoopDistl}
  \label{restricted-assump-do-while-loop-distl-rule}
  If $A$ does not begin with $\{g\}$ and
  $\{g\} \circseq A \circrefines_A A \circseq \{g\}$,
  then
  \begin{circus}
    \begin{array}{l}
      \{g\} \circseq (\circmu X \circspot A \circseq \\
      \t1 \circif h \circthen X \\
      \t1 {} \circelse \lnot h \circthen \Skip \\
      \t1 \circfi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{g\} \circseq (\circmu X \circspot \{g\} \circseq A \circseq \\
      \t1 \circif h \circthen X \\
      \t1 {} \circelse \lnot h \circthen \Skip \\
      \t1 \circfi)
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[restricted-assump-do-while-loop-distr]{crule}{RestrictedAssumpDoWhileLoopDistr}
  \label{restricted-assump-do-while-loop-distr-rule}
  If $B$ does not begin with $\{g\}$ and
  $\{g\} \circseq A \circrefines_A A \circseq \{g\}$,
  then
  \begin{circus}
    \begin{array}{l}
      (\circmu X \circspot A \circseq \\
      \t1 \circif h \then \{g\} \circseq X \\
      \t1 {} \circelse \lnot h \circseq \Skip \circseq \{g\} \\
      \t1 \circfi) \circseq B
    \end{array}
    \circrefines_A
    \begin{array}{l}
      (\circmu X \circspot A \circseq \\
      \t1 \circif h \then \{g\} \circseq X \\
      \t1 {} \circelse \lnot h \circseq \Skip \circseq \{g\} \\
      \t1 \circfi) \circseq \{g\} \circseq B
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[restricted-assump-while-loop-distl]{crule}{RestrictedAssumpWhileLoopDistl}
  \label{restricted-assump-while-loop-distl-rule}
  If $A$ does not begin with $\{g\}$ and
  $\{g\} \circseq A \circrefines_A A \circseq \{g\}$,
  then
  \begin{circus}
    \begin{array}{l}
      \{g\} \circseq (\circmu X \circspot \\
      \t1 \circif h \circthen A \circseq X \\
      \t1 {} \circelse \lnot h \circthen \Skip \\
      \t1 \circfi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{g\} \circseq (\circmu X \circspot \{g\} \circseq \\
      \t1 \circif h \circthen A \circseq X \\
      \t1 {} \circelse \lnot h \circthen \Skip \\
      \t1 \circfi)
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[restricted-assump-while-loop-distr]{crule}{RestrictedAssumpWhileLoopDistr}
  \label{restricted-assump-while-loop-distr-rule}
  If $B$ does not begin with $\{g\}$ and
  $\{g\} \circseq A \circrefines_A A \circseq \{g\}$,
  then
  \begin{circus}
    \begin{array}{l}
      (\circmu X \circspot \\
      \t1 \circif h \circthen A \circseq \{g\} \circseq X \\
      \t1 {} \circelse \lnot h \circthen \Skip \circseq \{g\}  \\
      \t1 \circfi) \circseq B
    \end{array}
    \circrefines_A
    \begin{array}{l}
      (\circmu X \circspot \\
      \t1 \circif h \circthen A \circseq \{g\} \circseq X \\
      \t1 {} \circelse \lnot h \circthen \Skip \circseq \{g\} \\
      \t1 \circfi) \circseq \{g\} \circseq B
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[restricted-assump-extchoice-distl]{crule}{RestrictedAssumpExtchoiceDistl}
  \label{restricted-assump-extchoice-distl-rule}
  If $A$ and $B$ do not begin with $\{g\}$ then
  \begin{circus}
    \begin{array}{l}
      \{g\} \circseq (A \extchoice B)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{g\} \circseq ((\{g\} \circseq A) \extchoice (\{g\} \circseq B))
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[restricted-assump-extchoice-distr]{crule}{RestrictedAssumpExtchoiceDistr}
  \label{restricted-assump-extchoice-distr-rule}
  If $C$ does not begin with $\{g\}$ then
  \begin{circus}
    \begin{array}{l}
      ((A \circseq \{g\}) \extchoice (\{g\} \circseq B)) \circseq C
    \end{array}
    \circrefines_A
    \begin{array}{l}
      ((A \circseq \{g\}) \extchoice (\{g\} \circseq B)) \circseq \{g\} \circseq C
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[restricted-assump-guard-dist]{crule}{RestrictedAssumpGuardDist}
  \label{restricted-assump-guard-dist-rule}
  If $A$ does not begin with $\{g\}$ then
  \begin{circus}
    \begin{array}{l}
      \{g\} \circseq \lcircguard h \rcircguard \circguard A
    \end{array}
    =
    \begin{array}{l}
      \{g\} \circseq \lcircguard h \rcircguard \circguard \{g\} \circseq A
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[restricted-assump-assign-dist]{crule}{RestrictedAssumpAssignDist}
  \label{restricted-assump-assign-dist-rule}
  If $B$ does not begin with $\{g\}$ and $x$ is not free in $g$ then
  \begin{circus}
    \begin{array}{l}
      \{g\} \circseq x := e \circseq B
    \end{array}
    =
    \begin{array}{l}
      \{g\} \circseq x := e \circseq \{g\} \circseq B
    \end{array}
  \end{circus}
\end{restatable}


\RefineHandleReturnEPCEmptyFrameStackRule*

\begin{restatable}[refine-$HandleReturnEPC$-nonempty-$frameStack$]{crule}{RefineHandleReturnEPCNonemptyFrameStackRule}
  \label{refine-HandleReturnEPC-nonempty-frameStack-rule}
  If $k > 1$ then
  \begin{circus}
    \begin{array}{l}
      \{\# frameStack = k\} \circseq \\
      HandleReturnEPC
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \lschexpract InterpreterReturnEPC \rschexpract
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[refine-$HandleAreturnEPC$-empty-$frameStack$]{crule}{RefineHandleAreturnEPCEmptyFrameStackRule}
  \label{refine-HandleAreturnEPC-empty-frameStack-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# frameStack = 1\} \circseq \\
      HandleAreturnEPC
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circvar returnValue : Word \circspot \\
      \lschexpract InterpreterAreturn2EPC \rschexpract \circseq \\
      executeMethodRet!thread!returnValue \then \Skip
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[refine-$HandleAreturnEPC$-nonempty-$frameStack$]{crule}{RefineHandleAreturnEPCNonemptyFrameStackRule}
  \label{refine-HandleAreturnEPC-nonempty-frameStack-rule}
  If $k > 1$ then
  \begin{circus}
    \begin{array}{l}
      \{\# frameStack = k\} \circseq \\
      HandleAreturnEPC
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \lschexpract InterpreterAreturn1EPC \rschexpract
    \end{array}
  \end{circus}
\end{restatable}

\subsection{Localise Stack Frames}

\ArgumentsIntroductionRule*

\HandleReturnEPCStackFrameIntroductionRule*

% \begin{restatable}[$InterpreterAreturn$-$stackFrame$-introduction]{crule}{HandleAreturnEPCStackFrameIntroductionRule}
%   \label{HandleAreturnEPC-stackFrame-introduction-rule}
%   %\setlength{\zedtab}{0.4cm}
%   %\setlength{\zedindent}{0pt}
%   %\setlength{\zedleftsep}{0pt}
%   If the actions in $A$ operate solely on $last~frameStack$ and do not
%   change the length of $frameStack$, then
%   \begin{circus}
%     \begin{array}{l}
%       InterpreterNewStackFrame[ \\
%       \t1 c/class?, \\
%       \t1 m/methodID?, \\
%       \t1 args/methodArgs?] \circseq \\
%       A \circseq \lschexpract InterpreterAreturn1 \rschexpract
%     \end{array}
%     \circrefines_A
%     \begin{array}{l}
%       (\circvar retVal : Word \circspot \\
%       \t1 (\circvar stackFrame : StackFrameEPC \circspot \\
%       \t2 \lschexpract [stackFrame' : StackFrameEPC | \\
%       \t3 args \subseteq stackFrame'.localVariables \land \\
%       \t3 \# stackFrame'.localVariables = \ell \land \\
%       \t3 stackFrame'.operandStack = \langle\rangle \land \\
%       \t3 stackFrame'.frameClass = c \land \\
%       \t3 stackFrame'.stackSize = s] \rschexpract \circseq \\
%       \t2 A[stackFrame/last~frameStack, \\
%       \t3 stackFrame'/last~frameStack'] \circseq \\
%       \t2 \lschexpract InterpreterPopEPC[ \\
%       \t3 stackFrame/last~frameStack, \\
%       \t3 stackFrame'/last~frameStack', \\
%       \t3 retVal!/value!] \rschexpract) \\
%       \t1 \lschexpract InterpreterPushEPC[retVal?/value?]  \rschexpract)
%     \end{array}
%   \end{circus}
%   where $\ell = c.methodLocals~m$ and $s = c.methodStackSize~m$.
% \end{restatable}

% TODO: rules for the areturn cases here?

\subsection{Introduce Variables}
\label{introduce-variables-appendix-subsection}

\begin{algorithm}
  \begin{algorithmic}[1]
    \State \ApplyTo{Rule~[\nameref{stackFrame-init-frameClass-assump-intro-rule}]}{$A$}
    \State {\bf exhaustively apply to }{$A$}  \\
    $\t1$ Rule~[\nameref{frameClass-assump-dist-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-alt-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-alt-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-var-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-var-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-output-prefix-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-output-prefix-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-input-prefix-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-input-prefix-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-infinite-loop-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-infinite-loop-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-while-loop-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-while-loop-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-do-while-loop-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-do-while-loop-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-mid-while-loop-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-mid-while-loop-distr-rule}] \\
    % $\t1$ Rule~[\nameref{restricted-assump-extchoice-distl-rule}] \\
    % $\t1$ Rule~[\nameref{restricted-assump-extchoice-distr-rule}] \\
    % $\t1$ Rule~[\nameref{restricted-assump-guard-dist-rule}] \\
    % $\t1$ Rule~[\nameref{restricted-assump-assign-dist-rule}]
  \end{algorithmic}
  \caption{IntroduceFrameClassAssumptions(A)}
  \label{introduce-frameClass-assumptions-algorithm}
\end{algorithm}

\begin{restatable}[$stackFrame$-init-$frameClass$-assump-intro]{crule}{StackFrameInitFrameClassAssumpIntroRule}
  \label{stackFrame-init-frameClass-assump-intro-rule}
  \setlength{\zedindent}{0.5cm}
  \begin{circus}
    \begin{array}{l}
      \lschexpract [arg1?, \ldots, arg{<}n{>}? : Word; \\
      \t1 stackFrame' : StackFrameEPC  | \\
      \t1 \langle arg1?, \ldots, arg{<}n{>}? \rangle \\
      \t2 {} \subseteq stackFrame'.localVariables \land \\
      \t1 \# stackFrame'.localVariables = \ell \land \\
      \t1 stackFrame'.operandStack = \langle\rangle \land \\
      \t1 stackFrame'.frameClass = c \land \\
      \t1 stackFrame'.stackSize = s] \rschexpract
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \lschexpract [arg1?, \ldots, arg{<}n{>}? : Word; \\
      \t1 stackFrame' : StackFrameEPC  | \\
      \t1 \langle arg1?, \ldots, arg{<}n{>}? \rangle \\
      \t2 {} \subseteq stackFrame'.localVariables \land \\
      \t1 \# stackFrame'.localVariables = \ell \land \\
      \t1 stackFrame'.operandStack = \langle\rangle \land \\
      \t1 stackFrame'.frameClass = c \land \\
      \t1 stackFrame'.stackSize = s] \rschexpract \circseq \\
      \{ stackFrame.frameClass = c\}
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$frameClass$-assump-dist]{crule}{FrameClassAssumpDistRule}
  \label{frameClass-assump-dist-rule}
  If $A$ is one of
  \begin{itemize}
  \item $\Skip$,
  \item $Poll$,
  \item $HandleAconst\_nullSF$,
  \item $HandleDupSF$,
  \item $HandleAloadSF(lvi)$,
  \item $HandleAstoreSF(lvi)$,
  \item $HandleIaddSF$,
  \item $HandleIconstSF(n)$,
  \item $HandleInegSF$,
  \item $\lschexpract InterpreterPopSF \rschexpract$,
  \item $\lschexpract InterpreterPushSF \rschexpract$,
  \item $\lschexpract \exists argsToPop? == m @ InvokeSF \rschexpract$
  \end{itemize}
  and $B$ does not begin with $\{ stackFrame.frameClass = c \}$, then
  \begin{circus}
    \begin{array}{l}
      \{ stackFrame.frameClass = c \} \circseq A \circseq B
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ stackFrame.frameClass = c \} \circseq A \circseq \\
      \{ stackFrame.frameClass = c \} \circseq B
    \end{array}
  \end{circus}
\end{restatable}

\RefinePutfieldSFRule*

\begin{restatable}[refine-$GetfieldSF$]{crule}{RefineGetfieldSFRule}
  \label{refine-GetfieldSF-rule}
  \begin{circus}
    \begin{array}{l}
      \{stackFrame.frameClass = c\} \circseq \\
      GetfieldSF(cpi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      (\circvar oid : ObjectID \circspot \\
      \t1 \lschexpract InterpreterPop[ \\
      \t2 oid!/value!, \\
      \t2 stackFrame/last~frameStack, \\
      \t2 stackFrame'/last~frameStack'] \rschexpract \circseq \\
      \t1 getField!oid!cid!fid! \\
      \t1 {} \then getFieldRet?value \\
      \t1 {} \then \lschexpract InterpreterPush[ \\
      \t2 stackFrame/last~frameStack, \\
      \t2 stackFrame'/last~frameStack'] \rschexpract)
    \end{array}
  \end{circus}
  where
  \begin{circus}
    cpi \in fieldRefIndices~c \land \\
    c.constantPool~cpi = FieldRef~(cid, fid)
  \end{circus}
\end{restatable}

\begin{restatable}[refine-$PutstaticSF$]{crule}{RefinePutstaticSFRule}
  \label{refine-PutstaticSF-rule}
  \begin{circus}
    \begin{array}{l}
      \{stackFrame.frameClass = c\} \circseq \\
      PutstaticSF(cpi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      (\circvar value : Word \circspot \\
      \t1 \lschexpract InterpreterPop[ \\
      \t2 stackFrame/last~frameStack, \\
      \t2 stackFrame'/last~frameStack'] \rschexpract \circseq \\
      \t1 putStatic!cid!fid!value \then \Skip)
    \end{array}
  \end{circus}
  where
  \begin{circus}
    cpi \in fieldRefIndices~c \land \\
    c.constantPool~cpi = FieldRef~(cid, fid)
  \end{circus}
\end{restatable}

\begin{restatable}[refine-$GetstaticSF$]{crule}{RefineGetstaticSFRule}
  \label{refine-GetstaticSF-rule}
  \begin{circus}
    \begin{array}{l}
      \{stackFrame.frameClass = c\} \circseq \\
      GetstaticSF(cpi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      getStatic!cid!fid \\
      {} \then getStaticRet?value \\
      {} \then \lschexpract InterpreterPush[ \\
      \t1 stackFrame/last~frameStack, \\
      \t1 stackFrame'/last~frameStack'] \rschexpract)
    \end{array}
  \end{circus}
  where
  \begin{circus}
    cpi \in fieldRefIndices~c \land \\
    c.constantPool~cpi = FieldRef~(cid, fid)
  \end{circus}
\end{restatable}

\begin{restatable}[refine-$NewSF$]{crule}{RefineNewSFRule}
  \label{refine-NewSF-rule}
  \begin{circus}
    \begin{array}{l}
      \{stackFrame.frameClass = c\} \circseq \\
      NewSF(cpi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      newObject!thread!cid \\
      {} \then newObjectRet?oid \\
      {} \then \lschexpract InterpreterPush[ \\
      \t1 oid/value?, \\
      \t1 stackFrame/last~frameStack, \\
      \t1 stackFrame'/last~frameStack'] \rschexpract)
    \end{array}
  \end{circus}
  where
  \begin{circus}
    cpi \in ClassRefIndices~c \land \\
    c.constantPool~cpi = ClassRef~cid
  \end{circus}
\end{restatable}

\begin{algorithm}
  \begin{algorithmic}[1]
    \State \ApplyTo{Rule~[\nameref{stackFrame-init-operandStack-assump-intro-rule}]}{$A$}
    \State {\bf exhaustively apply to }{$A$}  \\
    $\t1$ Rule~[\nameref{operandStack-assump-unchanged-dist-rule}] \\
    $\t1$ Rule~[\nameref{operandStack-assump-increment-dist-rule}] \\
    $\t1$ Rule~[\nameref{operandStack-assump-decrement-dist-rule}] \\
    $\t1$ Rule~[\nameref{operandStack-assump-InvokeSF-dist-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-alt-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-alt-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-var-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-var-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-output-prefix-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-output-prefix-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-input-prefix-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-input-prefix-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-infinite-loop-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-infinite-loop-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-while-loop-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-while-loop-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-do-while-loop-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-do-while-loop-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-mid-while-loop-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-mid-while-loop-distr-rule}] \\
    % $\t1$ Rule~[\nameref{restricted-assump-extchoice-distl-rule}] \\
    % $\t1$ Rule~[\nameref{restricted-assump-extchoice-distr-rule}] \\
    % $\t1$ Rule~[\nameref{restricted-assump-guard-dist-rule}] \\
    % $\t1$ Rule~[\nameref{restricted-assump-assign-dist-rule}]
  \end{algorithmic}
  \caption{IntroduceOperandStackAssumptions(A)}
  \label{introduce-operandStack-assumptions-algorithm}
\end{algorithm}

\begin{restatable}[$operandStack$-init-$frameClass$-assump-intro]{crule}{StackFrameInitOperandStackAssumpIntroRule}
  \label{stackFrame-init-operandStack-assump-intro-rule}
  \setlength{\zedindent}{0.1cm}
  \begin{circus}
    \begin{array}{l}
      \lschexpract [arg1?, \ldots, arg{<}n{>}? : Word; \\
      \t1 stackFrame' : StackFrameEPC  | \\
      \t1 \langle arg1?, \ldots, arg{<}n{>}? \rangle \\
      \t2 {} \subseteq stackFrame'.localVariables \land \\
      \t1 \# stackFrame'.localVariables = \ell \land \\
      \t1 stackFrame'.operandStack = \langle\rangle \land \\
      \t1 stackFrame'.frameClass = c \land \\
      \t1 stackFrame'.stackSize = s] \rschexpract
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \lschexpract [arg1?, \ldots, arg{<}n{>}? : Word; \\
      \t1 stackFrame' : StackFrameEPC  | \\
      \t1 \langle arg1?, \ldots, arg{<}n{>}? \rangle \\
      \t2 {} \subseteq stackFrame'.localVariables \land \\
      \t1 \# stackFrame'.localVariables = \ell \land \\
      \t1 stackFrame'.operandStack = \langle\rangle \land \\
      \t1 stackFrame'.frameClass = c \land \\
      \t1 stackFrame'.stackSize = s] \rschexpract \circseq \\
      \{ \# stackFrame.operandStack = 0 \}
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$operandStack$-assump-unchanged-dist]{crule}{OperandStackAssumpUnchangedDistRule}
  \label{operandStack-assump-unchanged-dist-rule}
  \setlength{\zedindent}{0.1cm}
  If $A$ is one of
  \begin{itemize}
  \item $\Skip$,
  \item $Poll$,
  % \item $HandleAconst\_nullSF$,
  % \item $HandleDupSF$,
  % \item $HandleAloadSF(lvi)$,
  % \item $HandleAstoreSF(lvi)$,
  % \item $HandleIaddSF$,
  % \item $HandleIconstSF(n)$,
  \item $HandleInegSF$,
  % \item $\lschexpract InterpreterPopSF \rschexpract$,
  % \item $\lschexpract InterpreterPushSF \rschexpract$,
  % \item $\lschexpract \exists argsToPop? == m @ InvokeSF \rschexpract$
  \end{itemize}
  and $B$ does not begin with $\{ \# stackFrame.operandStack = k \}$, then
  \begin{circus}
    \begin{array}{l}
      \{ \# stackFrame.operandStack = k \} \circseq A \circseq B
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ \# stackFrame.operandStack = k \} \circseq A \circseq \\ \{ \# stackFrame.operandStack = k \} \circseq B
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$operandStack$-assump-increment-dist]{crule}{OperandStackAssumpIncrementDistRule}
  \label{operandStack-assump-increment-dist-rule}
  \setlength{\zedindent}{0.1cm}
  If $A$ is one of
  \begin{itemize}
  % \item $\Skip$,
  % \item $Poll$,
  \item $HandleAconst\_nullSF$,
  \item $HandleDupSF$,
  \item $HandleAloadSF(lvi)$,
  % \item $HandleAstoreSF(lvi)$,
  % \item $HandleIaddSF$,
  \item $HandleIconstSF(n)$,
  % \item $HandleInegSF$,
  % \item $\lschexpract InterpreterPopSF \rschexpract$,
  \item $\lschexpract InterpreterPushSF \rschexpract$,
  % \item $\lschexpract \exists argsToPop? == m @ InvokeSF \rschexpract$
  \end{itemize}
  and $B$ does not begin with $\{ \# stackFrame.operandStack = k+1 \}$, then
  \begin{circus}
    \begin{array}{l}
      \{ \# stackFrame.operandStack = k \} \circseq A \circseq B
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ \# stackFrame.operandStack = k \} \circseq A \circseq \\
      \{ \# stackFrame.operandStack = k+1 \} \circseq B
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$operandStack$-assump-decrement-dist]{crule}{OperandStackAssumpDecrementDistRule}
  \label{operandStack-assump-decrement-dist-rule}
  \setlength{\zedindent}{0.1cm}
  If $A$ is one of
  \begin{itemize}
  % \item $\Skip$,
  % \item $Poll$,
  % \item $HandleAconst\_nullSF$,
  % \item $HandleDupSF$,
  % \item $HandleAloadSF(lvi)$,
  \item $HandleAstoreSF(lvi)$,
  \item $HandleIaddSF$,
  \item $HandleIconstSF(n)$,
  % \item $HandleInegSF$,
  \item $\lschexpract InterpreterPopSF \rschexpract$,
  % \item $\lschexpract InterpreterPushSF \rschexpract$,
  % \item $\lschexpract \exists argsToPop? == m @ InvokeSF \rschexpract$
  \end{itemize}
  and $B$ does not begin with $\{ \# stackFrame.operandStack = k-1 \}$, then
  \begin{circus}
    \begin{array}{l}
      \{ \# stackFrame.operandStack = k \} \circseq A \circseq B
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ \# stackFrame.operandStack = k \} \circseq A \circseq \\ \{ \# stackFrame.operandStack = k-1 \} \circseq B
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$operandStack$-assump-$InvokeSF$-dist]{crule}{OperandStackAssumpInvokeSFDistRule}
  \label{operandStack-assump-InvokeSF-dist-rule}
  \setlength{\zedindent}{0.1cm}
  If $B$ does not begin with $\{ \# stackFrame.operandStack = k-m \}$, then
  \begin{circus}
    \begin{array}{l}
      \{ \# stackFrame.operandStack = k \} \circseq \\
      \lschexpract \exists argsToPop? == m @ InvokeSF \rschexpract \circseq B
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ \# stackFrame.operandStack = k \} \circseq \\
      \lschexpract \exists argsToPop? == m @ InvokeSF \rschexpract \circseq \\
      \{ \# stackFrame.operandStack = k-m \} \circseq B
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$HandleAconst\_nullSF$-simulation]{crule}{HandleAconstNullSFSimulationRule}
  \label{HandleAconst_nullSF-simulation-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# stackFrame.operandStack = k\} \circseq \\
      HandleAconst\_nullSF
    \end{array}
    \circsimulates
    \begin{array}{l}
      stack{<}k+1{>} := null
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$HandleDupSF$-simulation]{crule}{HandleDupSFSimulationRule}
  \label{HandleDupSF-simulation-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# stackFrame.operandStack = k\} \circseq \\
      HandleDupSF
    \end{array}
    \circsimulates
    \begin{array}{l}
      stack{<}k+1{>} := stack{<}k{>}
    \end{array}
  \end{circus}
\end{restatable}

\HandleAloadSFSimulationRule*

\begin{restatable}[$HandleAstoreSF$-simulation]{crule}{HandleAstoreSFSimulationRule}
  \label{HandleAstoreSF-simulation-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# stackFrame.operandStack = k\} \circseq \\
      HandleAstoreSF(lvi)
    \end{array}
    \circsimulates
    \begin{array}{l}
      var{<}lvi{>} := stack{<}k{>} 
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$HandleIaddSF$-simulation]{crule}{HandleIaddSFSimulationRule}
  \label{HandleIaddSF-simulation-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# stackFrame.operandStack = k\} \circseq \\
      HandleIaddSF
    \end{array}
    \circsimulates
    \begin{array}{l}
      stack{<}k-1{>} := stack{<}k-1{>} + stack{<}k{>} 
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$HandleIconstSF$-simulation]{crule}{HandleIconstSFSimulationRule}
  \label{HandleIconstSF-simulation-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# stackFrame.operandStack = k\} \circseq \\
      HandleIconstSF(n)
    \end{array}
    \circsimulates
    \begin{array}{l}
      stack{<}k+1{>} := n 
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$HandleInegSF$-simulation]{crule}{HandleInegSFSimulationRule}
  \label{HandleInegSF-simulation-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# stackFrame.operandStack = k\} \circseq \\
      HandleInegSF
    \end{array}
    \circsimulates
    \begin{array}{l}
      stack{<}k{>} := \negate stack{<}k{>} 
    \end{array}
  \end{circus}
\end{restatable}

\InterpreterPopEPCSimulationRule*

\begin{restatable}[$InterpreterPushEPC$-simulation]{crule}{InterpreterPushEPCSimulationRule}
  \label{InterpreterPushEPC-simulation-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# stackFrame.operandStack = k\} \circseq \\
      \lschexpract InterpreterPushEPC[ \\
      \t1 stackFrame/last~frameStack, \\
      \t1 stackFrame'/last~frameStack']\rschexpract
    \end{array}
    \circsimulates
    \begin{array}{l}
      stack{<}k+1{>} := value
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$InterpreterPop2EPC$-simulation]{crule}{InterpreterPop2EPCSimulationRule}
  \label{InterpreterPop2EPC-simulation-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# stackFrame.operandStack = k\} \circseq \\
      \lschexpract InterpreterPopEPC[ \\
      \t1 stackFrame/last~frameStack, \\
      \t1 stackFrame'/last~frameStack']\rschexpract
    \end{array}
    \circsimulates
    \begin{array}{l}
      value1 := stack{<}k-1{>} \circseq \\
      value2 := stack{<}k{>}      
    \end{array}
  \end{circus}
\end{restatable}

\InvokeSFSimulationRule*

\StackFrameInitSimulationRule*

\EliminateValueOneValueTwoConditional*

\begin{restatable}[$getField$-$oid$-elim]{crule}{EliminateOidGetField}
  \label{eliminate-oid-getField-rule}
  \begin{circus}
    \begin{array}{l}
      (\circvar oid : ObjectID \circspot \\
      \t1 oid := stack{<}k{>} \circseq \\
      \t1 getfield!oid!cid!fid \\
      \t1 {} \then getFieldRet?value \\
      \t1 {} \then stack{<}k{>} := value)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      getfield!stack{<}k{>}!cid!fid \\
      \t1 {} \then getFieldRet?value \\
      \t1 {} \then stack{<}k{>} := value
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$putField$-$oid$-$value$-elim]{crule}{EliminateOidValuePutField}
  \label{eliminate-oid-value-putField-rule}
  \begin{circus}
    \begin{array}{l}
      (\circvar oid : ObjectID; value : Word \circspot \\
      \t1 value := stack{<}k{>} \circseq \\
      \t1 oid := stack{<}k-1{>} \circseq \\
      \t1 putField!oid!cid!fid!value \\
      \t1 {} \then \Skip)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      putField!stack{<}k-1{>}!cid!fid!stack{<}k{>} \\
      {} \then \Skip
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$putStatic$-$value$-elim]{crule}{EliminateValuePutStatic}
  \label{eliminate-value-putStatic-rule}
  \begin{circus}
    \begin{array}{l}
      (\circvar value : Word \circspot \\
      \t1 value := stack{<}k{>} \circseq \\
      \t1 putStatic!cid!fid!value \then \Skip)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      putStatic!cid!fid!stack{<}k{>} \then \Skip
    \end{array}
  \end{circus}
\end{restatable}

\MethodParameterIntroductionRule*

\begin{restatable}[$getClassIDOf$-$poppedArgs$-elim]{crule}{GetClassIDOfMethodParameterIntroductionRule}
  \label{getClassIDOf-method-parameter-introduction-rule}
  \begin{circus}
    \begin{array}{l}
      (\circvar poppedArgs : \seq Word \circspot \\
      poppedArgs := \langle arg_1, \ldots, arg_n \rangle \circseq \\
      getClassIDOf!(head~poppedArgs)!cid \\
      {} \then M(poppedArgs~1, \ldots, poppedArgs~n))
      % Remember: Poll starts the \cdots
    \end{array}
    \circrefines_A
    \begin{array}{l}
      getClassIDOf!arg_1!cid \\
      {} \then M(arg_1, \ldots, arg_n))
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$getClassIDOf$-multi-$poppedArgs$-elim]{crule}{GetClassIDOfMultiMethodParameterIntroductionRule}
  \label{getClassIDOf-multi-method-parameter-introduction-rule}
  \begin{circus}
    \begin{array}{l}
      (\circvar poppedArgs : \seq Word \circspot \\
      poppedArgs := \langle arg_1, \ldots, arg_n \rangle \circseq \\
      getClassIDOf!(head~poppedArgs)!cid \then {} \\
      \circif cid = c_1 \circthen {} \\
      \t1 M_1(poppedArgs~1, \ldots, poppedArgs~n) \\
      {} \cdots {}
      \circelse cid = c_m \circthen {} \\
      \t1 M_m(poppedArgs~1, \ldots, poppedArgs~n) \\
      \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      getClassIDOf!arg_1!cid \then {} \\
      \circif cid = c_1 \circthen {} \\
      {} \circelse cid = c_m \circthen {} \\
      \t1 (\circval var1, \ldots, var{<}n{>} : Word \circspot \\
      \t1 \circvar var{<}n+1{>}, \ldots, var{<}\ell_m{>}) : Word \circspot \\
      \t1 \circvar stack1, \ldots, stack{<}s_m{>} : Word \circspot \\
      \t2 {} \cdots {})(arg_1, \ldots, arg_n)) \\
      {} \cdots {} \\
      \circfi
    \end{array}
  \end{circus}
\end{restatable}

% \begin{restatable}[toplevel-$poppedArgs$-elimination]{crule}{ToplevelMethodParameterIntroductionRule}
%   \label{toplevel-method-parameter-introduction-rule}
%   \begin{circus}
%     \begin{array}{l}
%       (\circvar var1, \ldots, var{<}\ell{>} : Word \circspot \\
%       \circvar stack1, \ldots, stack{<}s{>} : Word \circspot \\
%       var1 := methodArgs~1 \circseq \\
%       \t1 \vdots \\
%       var{<}n{>} := methodArgs~n \circseq \\
%       \t1 {} \cdots {})) \\
%       % Remember: Poll starts the \cdots
%     \end{array}
%     \circrefines_A
%     \begin{array}{l}
%       (\circval var1, \ldots, var{<}n{>} : Word \circspot \\
%       \circvar var{<}n+1{>}, \ldots, var{<}\ell{>}) : Word \circspot \\
%       \circvar stack1, \ldots, stack{<}s{>} : Word \circspot \\
%       \t1 {} \cdots {})(methodArgs~1, \ldots, methodArgs~n) \\
%     \end{array}
%   \end{circus}
% \end{restatable}

\VarParameterConversionRule*

\ArgumentVariableEliminationRule*
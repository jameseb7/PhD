\section{Elimination of Program Counter}

\subsection{Expand Bytecode}

\PCExpansionRule*

\HandleInstructionRefinementRule*

\subsection{Introduce Sequential Composition}

\SequenceIntroductionRule*

\subsection{Introduce Loops and Conditionals}

\IfConditionalIntroductionRule*

\begin{restatable}[\texttt{if}-\texttt{else}-conditional-intro]{crule}{IfElseConditionalIntroductionRule}
  \label{if-else-introduction-rule}
  \setlength{\zedindent}{0.25cm}
  % \setlength{\abovedisplayskip}{0.1cm}
  % \setlength{\belowdisplayskip}{0.1cm}
  Given $i : ProgramAddress$, if $i \neq j$, $i \neq k$, and 
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 pc := \IF b \THEN j \ELSE k \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = j \circthen B \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen C \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 \circif b \circthen pc := j \circseq Poll \circseq B \\
      \t3 {} \circelse \lnot b \circthen pc := k \circseq Poll \circseq C \\
      \t3 \circfi \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = j \circthen B \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen C \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[conditional-intro]{crule}{ConditionalIntroductionRule}
  \label{conditional-introduction-rule}
  \setlength{\zedindent}{0.25cm}
  % \setlength{\abovedisplayskip}{0.1cm}
  % \setlength{\belowdisplayskip}{0.1cm}
  Given $i : ProgramAddress$, if $i \neq j$, $i \neq k$, and
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 pc := \IF b \THEN j \ELSE k \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = j \circthen B \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen C \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 \circif b \circthen pc := j \circseq Poll \circseq B \\
      \t3 {} \circelse \lnot b \circthen pc := k \circseq Poll \circseq C \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = j \circthen B \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen C \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}

\WhileLoopIntroductionRuleA*

\begin{crule}[\texttt{while}-loop-intro2]
  \label{while-introduction-rule2}
  \setlength{\zedindent}{0.2cm}
  \setlength{\zedtab}{0.9\zedtab}
  Given $i : ProgramAddress$, if $i \neq j$,
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 pc := \IF b \THEN j \ELSE k \\
      \t2 \cdots \\
      \t2 {} \circelse pc = j \circthen B \circseq pc := i \\
      \t2 \cdots \\
      \t2 {} \circelse pc = k \circthen C \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen (\circmu Y \circspot A \circseq \\
      \t3 \circif b \circthen \\
      \t4 pc := j \circseq Poll \circseq B \circseq pc := i \circseq Poll \circseq Y \\
      \t3 {} \circelse \lnot b \circthen C \\
      \t3 \circfi) \circseq pc := k \\
      \t2 \cdots \\
      \t2 {} \circelse pc = j \circthen B \circseq pc := i \\
      \t2 \cdots \\
      \t2 {} \circelse pc = k \circthen C \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{crule}

\begin{restatable}[\texttt{do}-\texttt{while}-loop-intro]{crule}{DoWhileLoopIntroductionRule}
  \label{do-while-introduction-rule}
  \def\zedindent{0.25cm}
  Given $i : ProgramAddress$, if $i \neq j$,
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 pc := \IF b \THEN i \ELSE j \\
      \t2 \cdots \\
      \t2 {} \circelse pc = j \circthen B \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen (\circmu Y \circspot A \\
      \t3 \circif b \circthen pc := i \circseq Poll \circseq Y \\
      \t3 {} \circelse \lnot b \circthen \Skip \\
      \t3 \circfi) \circseq pc := j \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[infinite-loop-intro]{crule}{InfiniteLoopIntroductionRule}
  \label{infinite-loop-introduction-rule}
  Given $i : ProgramAddress$, if
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \def\zedindent{0.25cm}
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen {} \\
      \t3 A \circseq pc := i \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen {} \\
      \t3 \circmu Y \circspot A \circseq pc := i \circseq Poll \circseq Y \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
  \end{circus}
\end{restatable}

\subsection{Resolve Method Calls}

\IntroduceClassInformationRule*

\begin{restatable}[refine-invokespecial]{crule}{RefineInvokespecialRule}
  \label{refine-invokespecial-rule}
  \setlength{\zedindent}{0.25cm}
  \begin{circus}
    \begin{array}{l}
      \{ pc = i \} \circseq HandleInvokespecialEPC(cpi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ pc = i \} \circseq \circvar poppedArgs : \seq Word \circspot \\
      \t1 \lschexpract \exists argsToPop? == methodArguments~m + 1 @ \\
      \t2 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t1 Invoke(c, m, poppedArgs, \false)
    \end{array}
  \end{circus}
  where $m : MethodID$ and $c : ClassID$ are such that
  \begin{displaymath}
    \exists c_0 : Class; m_0 : MethodID | c_0 \in \ran cs \land m_0 \in \dom c_0.methodEntry @ \\
    \t1 cpi \in methodRefIndices~c_0 \land \\
    \t1 c_0.constantPool~cpi = MethodRef~(c,m) \land \\
    \t1 i \in c_0.methodEntry~m_0 \upto c_0.methodEnd~m_0.
  \end{displaymath}
\end{restatable}

\RefineInvokestaticRule*

\begin{restatable}[refine-invokevirtual-single]{crule}{RefineInvokeVirtualSingleRule}
  \label{refine-invokevirtual-single-rule}
  \setlength{\zedindent}{0.25cm}
  \begin{circus}
    \begin{array}{l}
      \{ pc = i \} \circseq HandleInvokevirtualEPC(cpi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ pc = i \} \circseq \circvar poppedArgs : \seq Word \circspot \\
      \t1 \lschexpract \exists argsToPop? == methodArguments~m @ \\
      \t2 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t1 getClassIDOf!(head~poppedArgs)?cid \\
      \t1 {} \then Invoke(c, m, poppedArgs, \false)
    \end{array}
  \end{circus}
  where $m : MethodID$ and $c : ClassID$ are such that
  \begin{displaymath}
    \exists c_0 : Class; m_0 : MethodID | c_0 \in \ran cs \land m_0 \in \dom c_0.methodEntry @ \\
    \t1 cpi \in methodRefIndices~c_0 \land \\
    \t1 c_0.constantPool~cpi = MethodRef~(c,m) \land \\
    \t1 i \in c_0.methodEntry~m_0 \upto c_0.methodEnd~m_0,
  \end{displaymath}
  and provided $\exists_1 c_1 : ClassID @ (c_1,c) \in subclassRel~cs$.
\end{restatable}

\ResolveSpecialMethodRule*

\begin{restatable}[resolve-special-method-virtual]{crule}{ResolveSpecialMethodVirtualRule}
  \label{resolve-special-method-virtual-rule}
  If $c$, $m$ and $static$ match one of the rows of
  Table~\ref{special-method-action-table}, then
  \setlength{\zedindent}{0.25cm} \setlength{\zedtab}{0.5cm}
  \begin{circus}
    \begin{array}{l}
      \{ pc = i \} \circseq \circvar poppedArgs : \seq Word \circspot \\
      \lschexpract \exists argsToPop? == e @ \\
      \t1 InterpreterStackFrameInvoke \rschexpract \circseq \\
      getClassIDOf!(head~poppedArgs)?cid \\
      {} \then Invoke(c, m, poppedArgs, static)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ pc = i \} \circseq \circvar poppedArgs : \seq Word \circspot \\
      \lschexpract \exists argsToPop? == e @ \\
      \t1 InterpreterStackFrameInvoke \rschexpract \circseq \\
      getClassIDOf!(head~poppedArgs)?cid \\
      {} \then specialMethodAction(c, m, static) \circseq \\
      pc := i + 1
    \end{array}
  \end{circus}
  where $specialMethodAction$ is the syntactic function defined by
  Table~\ref{special-method-action-table}.
\end{restatable}

\ResolveNormalMethodRule*

\begin{restatable}[resolve-normal-method-virtual]{crule}{ResolveNormalMethodVirtualRule}
  \label{resolve-normal-method-virtual-rule}
  Given $i : ProgramAddress$, if
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\},
  \end{circus}
  and there exists $classInfo : Class$ in $\ran cs$ such that,
  \begin{circus}
    \{ methodID = m \land classID = c \} \circseq \lschexpract ResolveMethod \rschexpract \\
    {} = {} \\
    \{ methodID = m \land classID = c \} \circseq \lschexpract ResolveMethod \rschexpract \circseq \\
    \t1 \{ class = classInfo \land classInfo.methodEntry~m = k \},
  \end{circus}
  and, for any $x : ProgramAdress$,
  \begin{circus}
    \{ (last~(front~frameStack)).storedPC = x \} \circseq M \\
    {} = {} \\
    \{ (last~(front~frameStack)).storedPC = x \} \circseq M \circseq \{ pc = x \},
  \end{circus}
  and $m$ and $c$ do not match any of the conditions in
  Table~\ref{special-method-action-table} then,
  \setlength{\zedindent}{0cm}
  \setlength{\zedtab}{0.45cm}
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \{ pc = j \} \circseq \\
      \t3 \circvar poppedArgs : \seq Word \circspot \\
      \t3 \lschexpract \exists argsToPop? == e @ \\
      \t4 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t3 getClassIDOf!(head~poppedArgs)?cid \\
      \t3 {} \then Invoke(c, m, poppedArgs, \false) \\
      \t2 {} \circelse pc = k \circthen M \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \{ pc = j \} \circseq \\
      \t3 (\circvar poppedArgs : \seq Word \circspot \\
      \t3 \lschexpract \exists argsToPop? == e @ \\
      \t4 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t3 getClassIDOf!(head~poppedArgs)?cid \\
      \t3 {} \then \lschexpract InterpreterNewStackFrame[ \\
      \t4 classInfo/class?, \\
      \t4 m/methodID?, \\
      \t4 poppedArgs/methodArgs?] \rschexpract)) \circseq \\
      \t3 Poll \circseq M \circseq pc := j + 1 \\
      \t2 {} \circelse pc = k \circthen M \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}

\RefineInvokeVirtualMultiRule*

\begin{restatable}[resolve-special-method-branch]{crule}{ResolveSpecialMethodBranchRule}
  \label{resolve-special-method-branch-rule}
  Given $c_\ell : ClassID$, if $c = c_\ell$, $m$ and $static = \false$
  match one of the rows of Table~\ref{special-method-action-table},
  then
  \setlength{\zedindent}{0.25cm}
  \setlength{\zedtab}{0.5cm}
  \begin{circus}
    \begin{array}{l}
      \{ pc = i \} \circseq \circvar poppedArgs : \seq Word \circspot \\
      \lschexpract \exists argsToPop? == e @ \\
      \t1 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \circif cid = c_1 \circthen A_1 \\
      {} \cdots {} \\
      {} \circelse cid = c_\ell \circthen {} \\
      \t1 Invoke(c_\ell, m, poppedArgs, \false) \\
      {} \cdots {} \\
      {} \circelse cid = c_n \circthen A_n \\
      \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ pc = i \} \circseq \circvar poppedArgs : \seq Word \circspot \\
      \lschexpract \exists argsToPop? == e @ \\
      InterpreterStackFrameInvoke \rschexpract \circseq \\
      \circif cid = c_1 \circthen A_1 \\
      {} \cdots {} \\
      {} \circelse cid = c_\ell \circthen {} \\
      \t1 specialMethodAction(c_\ell, m, \false) \circseq pc := i + 1 \\
      {} \cdots {} \\
      {} \circelse cid = c_n \circthen A_n \\
      \circfi
    \end{array} 
  \end{circus}
  where $specialMethodAction$ is the syntactic function defined by
  Table~\ref{special-method-action-table}.
\end{restatable}

\begin{restatable}[resolve-normal-method-branch]{crule}{ResolveNormalMethodBranchRule}
  \label{resolve-normal-method-branch-rule}
  \setlength{\zedtab}{0.4cm}
  Given $i : ProgramAddress$, if
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\},
  \end{circus}
  and there exists $classInfo : Class$ in $\ran cs$ such that,
  \begin{circus}
    \{ methodID = m \land classID = c \} \circseq \lschexpract ResolveMethod \rschexpract \\
    {} = {} \\
    \{ methodID = m \land classID = c \} \circseq \lschexpract ResolveMethod \rschexpract \circseq \\
    \t1 \{ class = classInfo \land classInfo.methodEntry~m = k \},
  \end{circus}
  and, for any $x : ProgramAddress$,
  \begin{circus}
    \{ (last~(front~frameStack)).storedPC = x \} \circseq M \\
    {} = {} \\
    \{ (last~(front~frameStack)).storedPC = x \} \circseq M \circseq \{ pc = x \},
  \end{circus}
  and $m$ and $c$ do not match any of the conditions in
  Table~\ref{special-method-action-table} then,
  \setlength{\zedindent}{0.25cm}
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \{ pc = j \} \circseq \\
      \t3 \circvar poppedArgs : \seq Word \circspot \\
      \t3 \lschexpract \exists argsToPop? == e @ \\
      \t4 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t3 \circif cid = c_1 \circthen A_1 \\
      \t3 {} \cdots {} \\
      \t3 {} \circelse cid = c_\ell \circthen {} \\
      \t4 Invoke(c_\ell, m, poppedArgs, \false) \\
      \t3 {} \cdots {} \\
      \t3 {} \circelse cid = c_n \circthen A_n \\
      \t3 \circfi \\
      \t2 {} \circelse pc = k \circthen M \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \{ pc = j \} \circseq  \\
      \t3 \circvar poppedArgs : \seq Word \circspot \\
      \t3 \lschexpract \exists argsToPop? == e @ \\
      \t4 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t3 \circif cid = c_1 \circthen A_1 \\
      \t3 {} \cdots {} \\
      \t3 {} \circelse cid = c_\ell \circthen {} \\
      \t4 \lschexpract InterpreterNewStackFrame[ \\
      \t5 classInfo/class?,
      \t5 m/methodID?, \\
      \t5 poppedArgs/methodArgs?] \rschexpract) \circseq \\
      \t4 Poll \circseq M \circseq pc := j + 1 \\
      \t3 {} \cdots {} \\
      \t3 {} \circelse cid = c_n \circthen A_n \\
      \t3 \circfi \\
      \t2 {} \circelse pc = k \circthen M \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}

\subsection{Refine Main Actions}

\RunningRefinementRule*

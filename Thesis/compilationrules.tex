\section{Elimination of Program Counter}

\subsection{Expand Bytecode}

\PCExpansionRule*

\HandleInstructionRefinementRule*

\subsection{Introduce Sequential Composition}

\SequenceIntroductionRule*

\subsection{Introduce Loops and Conditionals}

\IfConditionalIntroductionRule*

\begin{restatable}[\texttt{if}-\texttt{else}-conditional-intro]{crule}{IfElseConditionalIntroductionRule}
  \label{if-else-introduction-rule}
  \setlength{\zedindent}{0.25cm}
  % \setlength{\abovedisplayskip}{0.1cm}
  % \setlength{\belowdisplayskip}{0.1cm}
  Given $i : ProgramAddress$, if $i \neq j$, $i \neq k$, and 
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 pc := \IF b \THEN j \ELSE k \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = j \circthen B \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen C \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 \circif b \circthen pc := j \circseq Poll \circseq B \\
      \t3 {} \circelse \lnot b \circthen pc := k \circseq Poll \circseq C \\
      \t3 \circfi \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = j \circthen B \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen C \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[conditional-intro]{crule}{ConditionalIntroductionRule}
  \label{conditional-introduction-rule}
  \setlength{\zedindent}{0.25cm}
  % \setlength{\abovedisplayskip}{0.1cm}
  % \setlength{\belowdisplayskip}{0.1cm}
  Given $i : ProgramAddress$, if $i \neq j$, $i \neq k$, and
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 pc := \IF b \THEN j \ELSE k \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = j \circthen B \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen C \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 \circif b \circthen pc := j \circseq Poll \circseq B \\
      \t3 {} \circelse \lnot b \circthen pc := k \circseq Poll \circseq C \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = j \circthen B \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen C \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}

\WhileLoopIntroductionRuleA*

\begin{crule}[\texttt{while}-loop-intro2]
  \label{while-introduction-rule2}
  \setlength{\zedindent}{0.2cm}
  \setlength{\zedtab}{0.9\zedtab}
  Given $i : ProgramAddress$, if $i \neq j$,
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 pc := \IF b \THEN j \ELSE k \\
      \t2 \cdots \\
      \t2 {} \circelse pc = j \circthen B \circseq pc := i \\
      \t2 \cdots \\
      \t2 {} \circelse pc = k \circthen C \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen (\circmu Y \circspot A \circseq \\
      \t3 \circif b \circthen \\
      \t4 pc := j \circseq Poll \circseq B \circseq pc := i \circseq Poll \circseq Y \\
      \t3 {} \circelse \lnot b \circthen C \\
      \t3 \circfi) \circseq pc := k \\
      \t2 \cdots \\
      \t2 {} \circelse pc = j \circthen B \circseq pc := i \\
      \t2 \cdots \\
      \t2 {} \circelse pc = k \circthen C \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{crule}

\begin{restatable}[\texttt{do}-\texttt{while}-loop-intro]{crule}{DoWhileLoopIntroductionRule}
  \label{do-while-introduction-rule}
  \def\zedindent{0.25cm}
  Given $i : ProgramAddress$, if $i \neq j$,
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 pc := \IF b \THEN i \ELSE j \\
      \t2 \cdots \\
      \t2 {} \circelse pc = j \circthen B \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen (\circmu Y \circspot A \\
      \t3 \circif b \circthen pc := i \circseq Poll \circseq Y \\
      \t3 {} \circelse \lnot b \circthen \Skip \\
      \t3 \circfi) \circseq pc := j \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[infinite-loop-intro]{crule}{InfiniteLoopIntroductionRule}
  \label{infinite-loop-introduction-rule}
  Given $i : ProgramAddress$, if
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \def\zedindent{0.25cm}
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen {} \\
      \t3 A \circseq pc := i \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen {} \\
      \t3 \circmu Y \circspot A \circseq pc := i \circseq Poll \circseq Y \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
  \end{circus}
\end{restatable}

\subsection{Resolve Method Calls}

\begin{restatable}[refine-invokespecial]{crule}{RefineInvokespecialRule}
  \label{refine-invokespecial-rule}
  \setlength{\zedindent}{0.25cm}
  \begin{circus}
    \begin{array}{l}
      \{ pc = i \} \circseq \\
      HandleInvokespecialEPC(cpi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ pc = i \} \circseq \circvar poppedArgs : \seq Word \circspot \\
      \t1 \lschexpract \exists argsToPop? == methodArguments~m + 1 @ \\
      \t2 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t1 Invoke(c, m, poppedArgs, \false)
    \end{array}
  \end{circus}
  where $m : MethodID$ and $c : ClassID$ are such that
  \begin{displaymath}
    \exists c_0 : Class; m_0 : MethodID | c_0 \in \ran cs \land m_0 \in \dom c_0.methodEntry @ \\
    \t1 cpi \in methodRefIndices~c_0 \land \\
    \t1 (\exists c_1 : ClassID | c_0.constantPool~cpi = MethodRef~(c_1,m) @ \\
    \t2 (((thisClassID~c_0,c_1) \in subclassRel~cs \land c_1 \neq thisClassID~c_0) \\
    \t3 {} \implies c = superClassID~c_0) \land \\
    \t2 (((thisClassID~c_0,c_1) \notin subclassRel~cs \lor c_1 = thisClassID~c_0) \\
    \t3 {} \implies c = c_1)) \land \\
    \t1 i \in c_0.methodEntry~m_0 \upto c_0.methodEnd~m_0.
  \end{displaymath}
\end{restatable}

\RefineInvokestaticRule*

\begin{restatable}[refine-invokevirtual-single]{crule}{RefineInvokeVirtualSingleRule}
  \label{refine-invokevirtual-single-rule}
  \setlength{\zedindent}{0.25cm}
  \begin{circus}
    \begin{array}{l}
      \{ pc = i \} \circseq \\
      HandleInvokevirtualEPC(cpi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ pc = i \} \circseq \circvar poppedArgs : \seq Word \circspot \\
      \t1 \lschexpract \exists argsToPop? == methodArguments~m @ \\
      \t2 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t1 getClassIDOf!(head~poppedArgs)?cid \\
      \t1 {} \then Invoke(c, m, poppedArgs, \false)
    \end{array}
  \end{circus}
  where $m : MethodID$ and $c : ClassID$ are such that
  \begin{displaymath}
    \exists c_0 : Class; m_0 : MethodID | c_0 \in \ran cs \land m_0 \in \dom c_0.methodEntry @ \\
    \t1 cpi \in methodRefIndices~c_0 \land \\
    \t1 c_0.constantPool~cpi = MethodRef~(c,m) \land \\
    \t1 i \in c_0.methodEntry~m_0 \upto c_0.methodEnd~m_0,
  \end{displaymath}
  and provided $\exists_1 c_1 : ClassID @ (c_1,c) \in subclassRel~cs$.
\end{restatable}

\ResolveSpecialMethodRule*

\begin{restatable}[resolve-special-method-virtual]{crule}{ResolveSpecialMethodVirtualRule}
  \label{resolve-special-method-virtual-rule}
  If $c$, $m$ and $static$ match one of the rows of
  Table~\ref{special-method-action-table}, then
  \setlength{\zedindent}{0.25cm} \setlength{\zedtab}{0.5cm}
  \begin{circus}
    \begin{array}{l}
      \{ pc = i \} \circseq \circvar poppedArgs : \seq Word \circspot \\
      \lschexpract \exists argsToPop? == e @ \\
      \t1 InterpreterStackFrameInvoke \rschexpract \circseq \\
      getClassIDOf!(head~poppedArgs)?cid \\
      {} \then Invoke(c, m, poppedArgs, static)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circvar poppedArgs : \seq Word \circspot \\
      \lschexpract \exists argsToPop? == e @ \\
      \t1 InterpreterStackFrameInvoke \rschexpract \circseq \\
      getClassIDOf!(head~poppedArgs)?cid \\
      {} \then specialMethodAction(c, m, static) \circseq \\
      pc := i + 1
    \end{array}
  \end{circus}
  where $specialMethodAction$ is the syntactic function defined by
  Table~\ref{special-method-action-table}.
\end{restatable}

\ResolveNormalMethodRule*

\begin{restatable}[resolve-normal-method-virtual]{crule}{ResolveNormalMethodVirtualRule}
  \label{resolve-normal-method-virtual-rule}
  Given $i : ProgramAddress$, if
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\},
  \end{circus}
  and there exists $classInfo : Class$ in $\ran cs$ such that,
  \begin{circus}
    \{ methodID = m \land classID = c \} \circseq \lschexpract ResolveMethod \rschexpract \\
    {} = {} \\
    \{ methodID = m \land classID = c \} \circseq \lschexpract ResolveMethod \rschexpract \circseq \\
    \t1 \{ class = classInfo \land classInfo.methodEntry~m = k \},
  \end{circus}
  and, for any $x : ProgramAdress$,
  \begin{circus}
    \{ (last~(front~frameStack)).storedPC = x \} \circseq M \\
    {} = {} \\
    \{ (last~(front~frameStack)).storedPC = x \} \circseq M \circseq \{ pc = x \},
  \end{circus}
  and $m$ and $c$ do not match any of the conditions in
  Table~\ref{special-method-action-table} then,
  \setlength{\zedindent}{0cm}
  \setlength{\zedtab}{0.45cm}
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \{ pc = j \} \circseq \\
      \t3 \circvar poppedArgs : \seq Word \circspot \\
      \t3 \lschexpract \exists argsToPop? == e @ \\
      \t4 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t3 getClassIDOf!(head~poppedArgs)?cid \\
      \t3 {} \then Invoke(c, m, poppedArgs, \false) \\
      \t2 {} \circelse pc = k \circthen M \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 (\circvar poppedArgs : \seq Word \circspot \\
      \t3 \lschexpract \exists argsToPop? == e @ \\
      \t4 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t3 getClassIDOf!(head~poppedArgs)?cid \\
      \t3 {} \then \lschexpract InterpreterNewStackFrame[ \\
      \t4 classInfo/class?, \\
      \t4 m/methodID?, \\
      \t4 poppedArgs/methodArgs?] \rschexpract)) \circseq \\
      \t3 Poll \circseq M \circseq pc := j + 1 \\
      \t2 {} \circelse pc = k \circthen M \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}

\RefineInvokeVirtualMultiRule*

\begin{restatable}[resolve-special-method-branch]{crule}{ResolveSpecialMethodBranchRule}
  \label{resolve-special-method-branch-rule}
  Given $c_\ell : ClassID$, if $c = c_\ell$, $m$ and $static = \false$
  match one of the rows of Table~\ref{special-method-action-table},
  then
  \setlength{\zedindent}{0.25cm}
  \setlength{\zedtab}{0.5cm}
  \begin{circus}
    \begin{array}{l}
      \circvar poppedArgs : \seq Word \circspot \\
      \lschexpract \exists argsToPop? == e @ \\
      \t1 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \circif cid = c_1 \circthen A_1 \\
      {} \cdots {} \\
      {} \circelse cid = c_\ell \circthen {} \\
      \t1 \{ (last~frameStack).storedPC = j + 1 \} \circseq \\
      \t1 Invoke(c_\ell, m, poppedArgs, \false) \\
      {} \cdots {} \\
      {} \circelse cid = c_n \circthen A_n \\
      \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ pc = i \} \circseq \circvar poppedArgs : \seq Word \circspot \\
      \lschexpract \exists argsToPop? == e @ \\
      InterpreterStackFrameInvoke \rschexpract \circseq \\
      \circif cid = c_1 \circthen A_1 \\
      {} \cdots {} \\
      {} \circelse cid = c_\ell \circthen {} \\
      \t1 specialMethodAction(c_\ell, m, \false) \circseq pc := i + 1 \\
      {} \cdots {} \\
      {} \circelse cid = c_n \circthen A_n \\
      \circfi
    \end{array} 
  \end{circus}
  where $specialMethodAction$ is the syntactic function defined by
  Table~\ref{special-method-action-table}.
\end{restatable}

\begin{restatable}[resolve-normal-method-branch]{crule}{ResolveNormalMethodBranchRule}
  \label{resolve-normal-method-branch-rule}
  \setlength{\zedtab}{0.4cm}
  Given $i : ProgramAddress$, if
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\},
  \end{circus}
  and there exists $classInfo : Class$ in $\ran cs$ such that,
  \begin{circus}
    \{ methodID = m \land classID = c \} \circseq \lschexpract ResolveMethod \rschexpract \\
    {} = {} \\
    \{ methodID = m \land classID = c \} \circseq \lschexpract ResolveMethod \rschexpract \circseq \\
    \t1 \{ class = classInfo \land classInfo.methodEntry~m = k \},
  \end{circus}
  and, for any $x : ProgramAddress$,
  \begin{circus}
    \{ (last~(front~frameStack)).storedPC = x \} \circseq M \\
    {} = {} \\
    \{ (last~(front~frameStack)).storedPC = x \} \circseq M \circseq \{ pc = x \},
  \end{circus}
  and $m$ and $c$ do not match any of the conditions in
  Table~\ref{special-method-action-table} then,
  \setlength{\zedindent}{0.25cm}
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 \circvar poppedArgs : \seq Word \circspot \\
      \t3 \lschexpract \exists argsToPop? == e @ \\
      \t4 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t3 \circif cid = c_1 \circthen A_1 \\
      \t3 {} \cdots {} \\
      \t3 {} \circelse cid = c_\ell \circthen {} \\
      \t4 \{ (last~frameStack).storedPC = j + 1 \} \circseq \\
      \t4 Invoke(c_\ell, m, poppedArgs, \false) \\
      \t3 {} \cdots {} \\
      \t3 {} \circelse cid = c_n \circthen A_n \\
      \t3 \circfi \\
      \t2 {} \circelse pc = k \circthen M \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \{ pc = j \} \circseq  \\
      \t3 \circvar poppedArgs : \seq Word \circspot \\
      \t3 \lschexpract \exists argsToPop? == e @ \\
      \t4 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t3 \circif cid = c_1 \circthen A_1 \\
      \t3 {} \cdots {} \\
      \t3 {} \circelse cid = c_\ell \circthen {} \\
      \t4 \lschexpract InterpreterNewStackFrame[ \\
      \t5 classInfo/class?,
      \t5 m/methodID?, \\
      \t5 poppedArgs/methodArgs?] \rschexpract) \circseq \\
      \t4 Poll \circseq M \circseq pc := j + 1 \\
      \t3 {} \cdots {} \\
      \t3 {} \circelse cid = c_n \circthen A_n \\
      \t3 \circfi \\
      \t2 {} \circelse pc = k \circthen M \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}

\subsection{Refine Main Actions}

\RunningRefinementRule*

\section{Elimination of Frame Stack}

\subsection{Remove Launcher Returns}

\RefineHandleReturnEPCEmptyFrameStackRule*

\begin{restatable}[refine-$HandleReturnEPC$-nonempty-$frameStack$]{crule}{RefineHandleReturnEPCNonemptyFrameStackRule}
  \label{refine-HandleReturnEPC-nonempty-frameStack-rule}
  \begin{circus}
    \begin{array}{l}
      HandleReturnEPC \circseq \\
      \{ frameStack \neq \emptyset \}
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \lschexpract InterpreterReturnEPC \rschexpract
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[refine-$HandleAreturnEPC$-empty-$frameStack$]{crule}{RefineHandleAreturnEPCEmptyFrameStackRule}
  \label{refine-HandleAreturnEPC-empty-frameStack-rule}
  \begin{circus}
    \begin{array}{l}
      HandleAreturnEPC \circseq \\
      \{ frameStack = \emptyset \}
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circvar returnValue : Word \circspot \\
      \lschexpract InterpreterAreturn2 \rschexpract \circseq \\
      executeMethodRet!thread!returnValue \then \Skip
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[refine-$HandleAreturnEPC$-nonempty-$frameStack$]{crule}{RefineHandleAreturnEPCNonemptyFrameStackRule}
  \label{refine-HandleAreturnEPC-nonempty-frameStack-rule}
  \begin{circus}
    \begin{array}{l}
      HandleAreturnEPC \circseq \\
      \{ frameStack \neq \emptyset \}
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \lschexpract InterpreterAreturn1 \rschexpract
    \end{array}
  \end{circus}
\end{restatable}

\subsection{Localise Stack Frames}

\ArgumentsIntroductionRule*

\HandleReturnEPCStackFrameIntroductionRule*

% \begin{restatable}[$InterpreterAreturn$-$stackFrame$-introduction]{crule}{HandleAreturnEPCStackFrameIntroductionRule}
%   \label{HandleAreturnEPC-stackFrame-introduction-rule}
%   %\setlength{\zedtab}{0.4cm}
%   %\setlength{\zedindent}{0pt}
%   %\setlength{\zedleftsep}{0pt}
%   If the actions in $A$ operate solely on $last~frameStack$ and do not
%   change the length of $frameStack$, then
%   \begin{circus}
%     \begin{array}{l}
%       InterpreterNewStackFrame[ \\
%       \t1 c/class?, \\
%       \t1 m/methodID?, \\
%       \t1 args/methodArgs?] \circseq \\
%       A \circseq \lschexpract InterpreterAreturn1 \rschexpract
%     \end{array}
%     \circrefines_A
%     \begin{array}{l}
%       (\circvar retVal : Word \circspot \\
%       \t1 (\circvar stackFrame : StackFrameEPC \circspot \\
%       \t2 \lschexpract [stackFrame' : StackFrameEPC | \\
%       \t3 args \subseteq stackFrame'.localVariables \land \\
%       \t3 \# stackFrame'.localVariables = \ell \land \\
%       \t3 stackFrame'.operandStack = \langle\rangle \land \\
%       \t3 stackFrame'.frameClass = c \land \\
%       \t3 stackFrame'.stackSize = s] \rschexpract \circseq \\
%       \t2 A[stackFrame/last~frameStack, \\
%       \t3 stackFrame'/last~frameStack'] \circseq \\
%       \t2 \lschexpract InterpreterPopEPC[ \\
%       \t3 stackFrame/last~frameStack, \\
%       \t3 stackFrame'/last~frameStack', \\
%       \t3 retVal!/value!] \rschexpract) \\
%       \t1 \lschexpract InterpreterPushEPC[retVal?/value?]  \rschexpract)
%     \end{array}
%   \end{circus}
%   where $\ell = c.methodLocals~m$ and $s = c.methodStackSize~m$.
% \end{restatable}

% TODO: rules for the areturn cases here?

\subsection{Introduce Variables}

\RefinePutfieldSFRule*

\begin{restatable}[refine-$GetfieldSF$]{crule}{RefineGetfieldSFRule}
  \label{refine-GetfieldSF-rule}
  \begin{circus}
    \begin{array}{l}
      \{stackFrame.frameClass = c\} \circseq \\
      GetfieldSF(cpi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      (\circvar oid : ObjectID \circspot \\
      \t1 \lschexpract InterpreterPop[ \\
      \t2 oid!/value!, \\
      \t2 stackFrame/last~frameStack, \\
      \t2 stackFrame'/last~frameStack'] \rschexpract \circseq \\
      \t1 getField!oid!cid!fid! \\
      \t1 {} \then getFieldRet?value \\
      \t1 {} \then \lschexpract InterpreterPush[ \\
      \t2 stackFrame/last~frameStack, \\
      \t2 stackFrame'/last~frameStack'] \rschexpract)
    \end{array}
  \end{circus}
  where
  \begin{circus}
    cpi \in fieldRefIndices~c \land \\
    c.constantPool~cpi = FieldRef~(cid, fid)
  \end{circus}
\end{restatable}

\begin{restatable}[refine-$PutstaticSF$]{crule}{RefinePutstaticSFRule}
  \label{refine-PutstaticSF-rule}
  \begin{circus}
    \begin{array}{l}
      \{stackFrame.frameClass = c\} \circseq \\
      PutstaticSF(cpi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      (\circvar value : Word \circspot \\
      \t1 \lschexpract InterpreterPop[ \\
      \t2 stackFrame/last~frameStack, \\
      \t2 stackFrame'/last~frameStack'] \rschexpract \circseq \\
      \t1 putStatic!cid!fid!value \then \Skip)
    \end{array}
  \end{circus}
  where
  \begin{circus}
    cpi \in fieldRefIndices~c \land \\
    c.constantPool~cpi = FieldRef~(cid, fid)
  \end{circus}
\end{restatable}

\begin{restatable}[refine-$GetstaticSF$]{crule}{RefineGetstaticSFRule}
  \label{refine-GetstaticSF-rule}
  \begin{circus}
    \begin{array}{l}
      \{stackFrame.frameClass = c\} \circseq \\
      GetstaticSF(cpi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      getStatic!cid!fid \\
      {} \then getStaticRet?value \\
      {} \then \lschexpract InterpreterPush[ \\
      \t1 stackFrame/last~frameStack, \\
      \t1 stackFrame'/last~frameStack'] \rschexpract)
    \end{array}
  \end{circus}
  where
  \begin{circus}
    cpi \in fieldRefIndices~c \land \\
    c.constantPool~cpi = FieldRef~(cid, fid)
  \end{circus}
\end{restatable}

\begin{restatable}[refine-$NewSF$]{crule}{RefineNewSFRule}
  \label{refine-NewSF-rule}
  \begin{circus}
    \begin{array}{l}
      \{stackFrame.frameClass = c\} \circseq \\
      NewSF(cpi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      newObject!thread!cid \\
      {} \then newObjectRet?oid \\
      {} \then \lschexpract InterpreterPush[ \\
      \t1 oid/value?, \\
      \t1 stackFrame/last~frameStack, \\
      \t1 stackFrame'/last~frameStack'] \rschexpract)
    \end{array}
  \end{circus}
  where
  \begin{circus}
    cpi \in ClassRefIndices~c \land \\
    c.constantPool~cpi = ClassRef~cid
  \end{circus}
\end{restatable}

\begin{restatable}[$HandleAconst\_nullSF$-simulation]{crule}{HandleAconstNullSFSimulationRule}
  \label{HandleAconst_nullSF-simulation-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# stackFrame.operandStack = k\} \circseq \\
      HandleAconst\_nullSF
    \end{array}
    \circsimulates
    \begin{array}{l}
      stack{<}k+1{>} := null
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$HandleDupSF$-simulation]{crule}{HandleDupSFSimulationRule}
  \label{HandleDupSF-simulation-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# stackFrame.operandStack = k\} \circseq \\
      HandleDupSF
    \end{array}
    \circsimulates
    \begin{array}{l}
      stack{<}k+1{>} := stack{<}k{>}
    \end{array}
  \end{circus}
\end{restatable}

\HandleAloadSFSimulationRule*

\begin{restatable}[$HandleAstoreSF$-simulation]{crule}{HandleAstoreSFSimulationRule}
  \label{HandleAstoreSF-simulation-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# stackFrame.operandStack = k\} \circseq \\
      HandleAstoreSF(lvi)
    \end{array}
    \circsimulates
    \begin{array}{l}
      var{<}lvi{>} := stack{<}k{>} 
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$HandleIaddSF$-simulation]{crule}{HandleIaddSFSimulationRule}
  \label{HandleIaddSF-simulation-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# stackFrame.operandStack = k\} \circseq \\
      HandleIaddSF
    \end{array}
    \circsimulates
    \begin{array}{l}
      stack{<}k-1{>} := stack{<}k-1{>} + stack{<}k{>} 
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$HandleIconstSF$-simulation]{crule}{HandleIconstSFSimulationRule}
  \label{HandleIconstSF-simulation-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# stackFrame.operandStack = k\} \circseq \\
      HandleIconstSF(n)
    \end{array}
    \circsimulates
    \begin{array}{l}
      stack{<}k+1{>} := n 
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$HandleInegSF$-simulation]{crule}{HandleInegSFSimulationRule}
  \label{HandleInegSF-simulation-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# stackFrame.operandStack = k\} \circseq \\
      HandleInegSF
    \end{array}
    \circsimulates
    \begin{array}{l}
      stack{<}k{>} := \negate stack{<}k{>} 
    \end{array}
  \end{circus}
\end{restatable}

\InterpreterPopEPCSimulationRule*

\begin{restatable}[$InterpreterPushEPC$-simulation]{crule}{InterpreterPushEPCSimulationRule}
  \label{InterpreterPushEPC-simulation-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# stackFrame.operandStack = k\} \circseq \\
      \lschexpract InterpreterPushEPC[ \\
      \t1 stackFrame/last~frameStack, \\
      \t1 stackFrame'/last~frameStack']\rschexpract
    \end{array}
    \circsimulates
    \begin{array}{l}
      stack{<}k+1{>} := value
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$InterpreterPop2EPC$-simulation]{crule}{InterpreterPop2EPCSimulationRule}
  \label{InterpreterPop2EPC-simulation-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# stackFrame.operandStack = k\} \circseq \\
      \lschexpract InterpreterPopEPC[ \\
      \t1 stackFrame/last~frameStack, \\
      \t1 stackFrame'/last~frameStack']\rschexpract
    \end{array}
    \circsimulates
    \begin{array}{l}
      value1 := stack{<}k-1{>} \circseq \\
      value2 := stack{<}k{>}      
    \end{array}
  \end{circus}
\end{restatable}

\InvokeSFSimulationRule*

\StackFrameInitSimulationRule*

\EliminateValueOneValueTwoConditional*

\begin{restatable}[$getField$-$oid$-elim]{crule}{EliminateOidGetField}
  \label{eliminate-oid-getField-rule}
  \begin{circus}
    \begin{array}{l}
      (\circvar oid : ObjectID \circspot \\
      \t1 oid := stack{<}k{>} \circseq \\
      \t1 getfield!oid!cid!fid \\
      \t1 {} \then getFieldRet?value \\
      \t1 {} \then stack{<}k{>} := value)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      getfield!stack{<}k{>}!cid!fid \\
      \t1 {} \then getFieldRet?value \\
      \t1 {} \then stack{<}k{>} := value
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$putField$-$oid$-$value$-elim]{crule}{EliminateOidValuePutField}
  \label{eliminate-oid-value-putField-rule}
  \begin{circus}
    \begin{array}{l}
      (\circvar oid : ObjectID; value : Word \circspot \\
      \t1 value := stack{<}k{>} \circseq \\
      \t1 oid := stack{<}k-1{>} \circseq \\
      \t1 putField!oid!cid!fid!value \\
      \t1 {} \then \Skip)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      putField!stack{<}k-1{>}!cid!fid!stack{<}k{>} \\
      {} \then \Skip
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$putStatic$-$value$-elim]{crule}{EliminateValuePutStatic}
  \label{eliminate-value-putStatic-rule}
  \begin{circus}
    \begin{array}{l}
      (\circvar value : Word \circspot \\
      \t1 value := stack{<}k{>} \circseq \\
      \t1 putStatic!cid!fid!value \then \Skip)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      putStatic!cid!fid!stack{<}k{>} \then \Skip
    \end{array}
  \end{circus}
\end{restatable}

\MethodParameterIntroductionRule*

\begin{restatable}[$getClassIDOf$-$poppedArgs$-elim]{crule}{GetClassIDOfMethodParameterIntroductionRule}
  \label{getClassIDOf-method-parameter-introduction-rule}
  \begin{circus}
    \begin{array}{l}
      (\circvar poppedArgs : \seq Word \circspot \\
      poppedArgs := \langle arg_1, \ldots, arg_n \rangle \circseq \\
      getClassIDOf!(head~poppedArgs)!cid \\
      {} \then M(poppedArgs~1, \ldots, poppedArgs~n))
      % Remember: Poll starts the \cdots
    \end{array}
    \circrefines_A
    \begin{array}{l}
      getClassIDOf!arg_1!cid \\
      {} \then M(arg_1, \ldots, arg_n))
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$getClassIDOf$-multi-$poppedArgs$-elim]{crule}{GetClassIDOfMultiMethodParameterIntroductionRule}
  \label{getClassIDOf-multi-method-parameter-introduction-rule}
  \begin{circus}
    \begin{array}{l}
      (\circvar poppedArgs : \seq Word \circspot \\
      poppedArgs := \langle arg_1, \ldots, arg_n \rangle \circseq \\
      getClassIDOf!(head~poppedArgs)!cid \then {} \\
      \circif cid = c_1 \circthen {} \\
      \t1 M_1(poppedArgs~1, \ldots, poppedArgs~n) \\
      {} \cdots {}
      \circelse cid = c_m \circthen {} \\
      \t1 M_m(poppedArgs~1, \ldots, poppedArgs~n) \\
      \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      getClassIDOf!arg_1!cid \then {} \\
      \circif cid = c_1 \circthen {} \\
      {} \circelse cid = c_m \circthen {} \\
      \t1 (\circval var1, \ldots, var{<}n{>} : Word \circspot \\
      \t1 \circvar var{<}n+1{>}, \ldots, var{<}\ell_m{>}) : Word \circspot \\
      \t1 \circvar stack1, \ldots, stack{<}s_m{>} : Word \circspot \\
      \t2 {} \cdots {})(arg_1, \ldots, arg_n)) \\
      {} \cdots {} \\
      \circfi
    \end{array}
  \end{circus}
\end{restatable}

% \begin{restatable}[toplevel-$poppedArgs$-elimination]{crule}{ToplevelMethodParameterIntroductionRule}
%   \label{toplevel-method-parameter-introduction-rule}
%   \begin{circus}
%     \begin{array}{l}
%       (\circvar var1, \ldots, var{<}\ell{>} : Word \circspot \\
%       \circvar stack1, \ldots, stack{<}s{>} : Word \circspot \\
%       var1 := methodArgs~1 \circseq \\
%       \t1 \vdots \\
%       var{<}n{>} := methodArgs~n \circseq \\
%       \t1 {} \cdots {})) \\
%       % Remember: Poll starts the \cdots
%     \end{array}
%     \circrefines_A
%     \begin{array}{l}
%       (\circval var1, \ldots, var{<}n{>} : Word \circspot \\
%       \circvar var{<}n+1{>}, \ldots, var{<}\ell{>}) : Word \circspot \\
%       \circvar stack1, \ldots, stack{<}s{>} : Word \circspot \\
%       \t1 {} \cdots {})(methodArgs~1, \ldots, methodArgs~n) \\
%     \end{array}
%   \end{circus}
% \end{restatable}

\VarParameterConversionRule*

\ArgumentVariableEliminationRule*
\addchange{Added introductory paragraph to
  Appendix\protect~\protect\ref{compilation-rules-appendix}}
\added{
This appendix contains the compilation rules used in the compilation
strategy described in Chapter~\ref{strategy-chapter}.
We present the compilation rules in sections corresponding to the
sections of Chapter~\ref{strategy-chapter} in which they are first
used.
The rules for Section~\ref{expand-bytecode-subsection} are presented
in Section~\ref{expand-bytecode-rules-subsection}, the rules for
Section~\ref{introduce-forward-sequence-subsection} in
Section~\ref{sequential-composition-rules-subsection}, the rules for
Section~\ref{introduce-loops-and-conditionals-subsection} in
Section~\ref{loops-and-conditionals-rules-subsection}, the rules for
Section~\ref{resolve-method-calls-subsection} in
Section~\ref{method-calls-rules-subsection}, the rules for
Section~\ref{refine-main-actions-subsection} in
Section~\ref{main-actions-rules-subsection}, the rules for
Section~\ref{remove-launcher-returns-subsection} in
Section~\ref{remove-launcher-returns-appendix-subsection}, the rules
for Section~\ref{localise-stack-frames-subsection} in
Section~\ref{localise-stack-frames-appendix-subsection}, the rules for
Section~\ref{introduce-variables-subsection} in
Section~\ref{introduce-variables-appendix-subsection}, and the rules
for Section~\ref{data-refinement-of-objects-section} in
Section~\ref{data-refinement-of-objects-appendix-section}. 
We also include in this appendix additional algorithms referenced in
the compilation strategy but not included in the main body in the
thesis, which are included in the sections of this appendix
corresponding to the sections of Chapter~\ref{strategy-chapter} in
which they are used.
Finally, we also list the algebraic laws applied by the algorithms of
our compilation strategy in
Section~\ref{compilation-strategy-algebraic-laws-section} at the end
of this appendix.
}

\section{Elimination of Program Counter}

\subsection{Expand Bytecode}
\label{expand-bytecode-rules-subsection}

\begin{minipage}{\textwidth}
  \PCExpansionRule*
\end{minipage}

\begin{minipage}{\textwidth}
  \HandleInstructionRefinementRule*
\end{minipage}

\begin{minipage}{\textwidth}
  \CheckSynchronizedReturnSynchronizedRefinementRule*
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[$CheckSynchronizedReturn$-nonsync-refinement]{crule}{CheckSynchronizedReturnNonsynchronizedRefinementRule}
  \label{CheckSynchronizedReturn-nonsynchronized-refinement-rule}
  Given $i : ProgramAddress$,
  \setlength{\zedindent}{0.5cm}
  \setlength{\zedtab}{0.5cm}
  \begin{circus}
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen CheckSynchronizedReturn \circseq A \\
      {} \cdots {} \\
      \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen A \\
      {} \cdots {} \\
      \circfi
    \end{array}
  \end{circus}
  provided
  \begin{displaymath}
    \exists c : Class; m : MethodID | \\
    \t1 c \in \ran cs \land m \in \dom c.methodEntry @ \\
    \t1 i \in c.methodEntry~m \upto c.methodEnd~m \land \\
    \t1 m \notin c.synchronizedMethods \lor m \in c.staticMethods
  \end{displaymath}
\end{restatable}
\end{minipage}

\subsection{Introduce Sequential Composition}
\label{sequential-composition-rules-subsection}

\begin{minipage}{\textwidth}
\SequenceIntroductionRule*
\end{minipage}

\subsection{Introduce Loops and Conditionals}
\label{loops-and-conditionals-rules-subsection}

\begin{minipage}{\textwidth}
  \IfConditionalIntroductionRule*
\end{minipage}  

\begin{minipage}{\textwidth}
\begin{restatable}[\texttt{if}-\texttt{else}-conditional-intro]{crule}{IfElseConditionalIntroductionRule}
  \label{if-else-introduction-rule}
  \setlength{\zedindent}{0.25cm}
  \setlength{\zedtab}{0.57cm}
  % \setlength{\abovedisplayskip}{0.1cm}
  % \setlength{\belowdisplayskip}{0.1cm}
  Given $i : ProgramAddress$, if $i \neq j$, $i \neq k$, and 
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \circseq P \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq P \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 (\circvar value1, value2 : Word \circspot P \circseq \\
      \t3 pc := \IF b \THEN j \ELSE k) \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = j \circthen B \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen C \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 (\circvar value1, value2 : Word \circspot P \circseq \\
      \t3 \circif b \circthen pc := j \circseq Poll \circseq B \\
      \t3 {} \circelse \lnot b \circthen pc := k \circseq Poll \circseq C \\
      \t3 \circfi) \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = j \circthen B \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen C \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[conditional-intro]{crule}{ConditionalIntroductionRule}
  \label{conditional-introduction-rule}
  \setlength{\zedindent}{0.25cm}
  \setlength{\zedtab}{0.57cm}
  % \setlength{\abovedisplayskip}{0.1cm}
  % \setlength{\belowdisplayskip}{0.1cm}
  Given $i : ProgramAddress$, if $i \neq j$, $i \neq k$, and
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \circseq P \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq P \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 (\circvar value1, value2 : Word \circspot P \circseq \\
      \t3 pc := \IF b \THEN j \ELSE k) \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = j \circthen B \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen C \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 (\circvar value1, value2 : Word \circspot P \circseq \\
      \t3 \circif b \circthen pc := j \circseq Poll \circseq B \\
      \t3 {} \circelse \lnot b \circthen pc := k \circseq Poll \circseq C \\
      \t3 \circfi) \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = j \circthen B \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen C \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
  \WhileLoopIntroductionRuleA*
\end{minipage}

\begin{minipage}{\textwidth}
\begin{crule}[\texttt{while}-loop-intro2]
  \label{while-introduction-rule2}
  \setlength{\zedindent}{0.2cm}
  \setlength{\zedtab}{0.58cm}
  Given $i : ProgramAddress$, if $i \neq j$,
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \circseq P \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq P \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  and
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq B \circseq \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq B \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 (\circvar value1, value2 : Word \circspot P \circseq \\
      \t3 pc := \IF b \THEN j \ELSE k) \\
      \t2 \cdots \\
      \t2 {} \circelse pc = j \circthen B \circseq pc := i \\
      \t2 \cdots \\
      \t2 {} \circelse pc = k \circthen C \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen (\circmu Y \circspot A \circseq \\
      \t3 (\circvar value1, value2 : Word \circspot P \circseq \\
      \t3 \circif b \circthen \\
      \t4 pc := j \circseq Poll \circseq B \circseq \\
      \t4 pc := i \circseq Poll \circseq Y \\
      \t3 {} \circelse \lnot b \circthen \Skip \\
      \t3 \circfi)) \circseq pc := k \\
      \t2 \cdots \\
      \t2 {} \circelse pc = j \circthen B \circseq pc := i \\
      \t2 \cdots \\
      \t2 {} \circelse pc = k \circthen C \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{crule}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[\texttt{do}-\texttt{while}-loop-intro]{crule}{DoWhileLoopIntroductionRule}
  \label{do-while-introduction-rule}
  \setlength{\zedindent}{0.2cm}
  \setlength{\zedtab}{0.58cm}
  Given $i : ProgramAddress$, if $i \neq j$,
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \circseq P \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq P \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 (\circvar value1, value2 : Word \circspot P \circseq \\
      \t3 pc := \IF b \THEN i \ELSE j) \\
      \t2 \cdots \\
      \t2 {} \circelse pc = j \circthen B \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen (\circmu Y \circspot A \\
      \t3 (\circvar value1, value2 : Word \circspot P \circseq \\
      \t3 \circif b \circthen pc := i \circseq Poll \circseq Y \\
      \t3 {} \circelse \lnot b \circthen \Skip \\
      \t3 \circfi)) \circseq pc := j \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[infinite-loop-intro]{crule}{InfiniteLoopIntroductionRule}
  \label{infinite-loop-introduction-rule}
  Given $i : ProgramAddress$, if
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \def\zedindent{0.25cm}
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen {} \\
      \t3 A \circseq pc := i \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen {} \\
      \t3 \circmu Y \circspot A \circseq pc := i \circseq Poll \circseq Y \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\subsection{Resolve Method Calls}
\label{method-calls-rules-subsection}

\begin{minipage}{\textwidth}
\begin{restatable}[refine-invokespecial]{crule}{RefineInvokespecialRule}
  \label{refine-invokespecial-rule}
  \setlength{\zedindent}{0.25cm}
  \begin{circus}
    \begin{array}{l}
      \{ pc = i \} \circseq \\
      HandleInvokespecialEPC(cpi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ pc = i \} \circseq \circvar poppedArgs : \seq Word \circspot \\
      \t1 \lschexpract \exists argsToPop? == methodArguments~m + 1 @ \\
      \t2 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t1 Invoke(c, m, poppedArgs)
    \end{array}
  \end{circus}
  where $m : MethodID$ and $c : ClassID$ are such that
  \begin{displaymath}
    \exists c_0 : Class; m_0 : MethodID | c_0 \in \ran cs \land m_0 \in \dom c_0.methodEntry @ \\
    \t1 cpi \in methodRefIndices~c_0 \land \\
    \t1 (\exists c_1 : ClassID | c_0.constantPool~cpi = MethodRef~(c_1,m) @ \\
    \t2 (((thisClassID~c_0,c_1) \in subclassRel~cs \\
    \t2 {} \land c_1 \neq thisClassID~c_0 \\
    \t2 {} \land m \notin initialisationMethodIDs) \\
    \t3 {} \implies c = superClassID~c_0) \land \\
    \t2 (((thisClassID~c_0,c_1) \notin subclassRel~cs \\
    \t2 {} \lor c_1 = thisClassID~c_0 \\
    \t2 {} \lor m \in initialisationMethodIDs) \\
    \t3 {} \implies c = c_1)) \land \\
    \t1 i \in c_0.methodEntry~m_0 \upto c_0.methodEnd~m_0.
  \end{displaymath}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
  \RefineInvokestaticRule*
\end{minipage}

\begin{minipage}{\textwidth}
  \RefineInvokeVirtualMultiRule*
\end{minipage}

\begin{minipage}{\textwidth}
  \ResolveSpecialMethodRule*
\end{minipage}

\begin{minipage}{\textwidth}
  \ResolveNormalMethodRule*
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[$CheckSynchronizedInvoke$-sync-refinement]{crule}{CheckSynchronizedInvokeSynchronizedRefinementRule}
  \label{CheckSynchronizedInvoke-synchronized-refinement-rule}
  \hfill \\
  If $m \in c.synchronizedMethods \land m \notin c.staticMethods$, then
  \begin{circus}
    \begin{array}{l}
      CheckSynchronizedInvoke(c, m, args)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      takeLock!(head~args) \\
      {} \then takeLockRet \then \Skip
    \end{array}
  \end{circus}
\end{restatable}

\begin{restatable}[$CheckSynchronizedInvoke$-nonsync-refinement]{crule}{CheckSynchronizedInvokeNonsynchronizedRefinementRule}
  \label{CheckSynchronizedInvoke-nonsynchronized-refinement-rule}
  \hfill \\
  If $m \notin c.synchronizedMethods \lor m \in c.staticMethods$, then
  \begin{circus}
    \begin{array}{l}
      CheckSynchronizedInvoke(c, m, args)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \Skip
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

% \begin{restatable}[resolve-special-method-branch]{crule}{ResolveSpecialMethodBranchRule}
%   \label{resolve-special-method-branch-rule}
%   Given $c_\ell : ClassID$, if $c = c_\ell$, $m$ and $static = \false$
%   match one of the rows of Table~\ref{special-method-action-table},
%   then
%   \setlength{\zedindent}{0.25cm}
%   \setlength{\zedtab}{0.5cm}
%   \begin{circus}
%     \begin{array}{l}
%       \circvar poppedArgs : \seq Word \circspot \\
%       \lschexpract \exists argsToPop? == e @ \\
%       \t1 InterpreterStackFrameInvoke \rschexpract \circseq \\
%       \circif cid = c_1 \circthen A_1 \\
%       {} \cdots {} \\
%       {} \circelse cid = c_\ell \circthen {} \\
%       \t1 \{ (last~frameStack).storedPC = j + 1 \} \circseq \\
%       \t1 Invoke(c_\ell, m, poppedArgs, \false) \\
%       {} \cdots {} \\
%       {} \circelse cid = c_n \circthen A_n \\
%       \circfi
%     \end{array}
%     \circrefines_A
%     \begin{array}{l}
%       \{ pc = i \} \circseq \circvar poppedArgs : \seq Word \circspot \\
%       \lschexpract \exists argsToPop? == e @ \\
%       InterpreterStackFrameInvoke \rschexpract \circseq \\
%       \circif cid = c_1 \circthen A_1 \\
%       {} \cdots {} \\
%       {} \circelse cid = c_\ell \circthen {} \\
%       \t1 specialMethodAction(c_\ell, m, \false) \circseq pc := i + 1 \\
%       {} \cdots {} \\
%       {} \circelse cid = c_n \circthen A_n \\
%       \circfi
%     \end{array} 
%   \end{circus}
%   where $specialMethodAction$ is the syntactic function defined by
%   Table~\ref{special-method-action-table}.
% \end{restatable}

\begin{minipage}{\textwidth}
\begin{restatable}[resolve-normal-method-branch]{crule}{ResolveNormalMethodBranchRule}
  \label{resolve-normal-method-branch-rule}
  Given $i : ProgramAddress$ and $c_{\ell} : ClassID$, if
  \begin{itemize}
  \item \hfill{\vspace*{-\baselineskip}\setlength{\abovedisplayskip}{0cm}\setlength{\abovedisplayshortskip}{0cm}
      \begin{circus}
      \{frameStack \neq \emptyset\} \circseq A \\
      {} = {} \\
      \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\},
    \end{circus}}
  \item $methodID = m \land classID = c_{\ell} \implies \pre ResolveMethod$ and there is $classInfo : Class$ such that
    \begin{circus}
      \{ methodID = m \land classID = c_{\ell} \} \circseq \lschexpract ResolveMethod \rschexpract \\
      {} = {} \\
      \{ methodID = m \land classID = c_{\ell} \} \circseq \lschexpract ResolveMethod \rschexpract \circseq \\
      \t1 \{ class = classInfo \land class.methodEntry~m = k \},
    \end{circus}
  \item for any $x : ProgramAddress$,
    \begin{circus}
      \{ (last~(front~frameStack)).storedPC = x \} \circseq M \\
      {} = {} \\
      \{ (last~(front~frameStack)).storedPC = x \} \circseq M \circseq \{ pc = x \},
    \end{circus}
  \item $m$ and $c$ do not match any of the conditions in
    Table~\ref{special-method-action-table},
  \end{itemize}
  then,
  \setlength{\zedtab}{0.3cm}
  \setlength{\zedindent}{0cm}
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 \circvar poppedArgs : \seq Word \circspot \\
      \t3 \lschexpract \exists argsToPop? == e @ \\
      \t4 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t3 \circif cid = c_1 \circthen A_1 \\
      \t3 {} \cdots {} \\
      \t3 {} \circelse cid = c_\ell \circthen {} \\
      \t4 \{ (last~frameStack).storedPC = j + 1 \} \circseq \\
      \t4 Invoke(c_\ell, m, poppedArgs, \false) \\
      \t3 {} \cdots {} \\
      \t3 {} \circelse cid = c_n \circthen A_n \\
      \t3 \circfi \\
      \t2 {} \circelse pc = k \circthen M \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \{ pc = j \} \circseq  \\
      \t3 \circvar poppedArgs : \seq Word \circspot \\
      \t3 \lschexpract \exists argsToPop? == e @ \\
      \t4 InterpreterStackFrameInvoke \rschexpract \circseq \\
      \t3 \circif cid = c_1 \circthen A_1 \\
      \t3 {} \cdots {} \\
      \t3 {} \circelse cid = c_\ell \circthen {} \\
      \t4 CheckSynchronizedInvoke( \\
      \t5 classInfo, m, poppedArgs) \circseq \\
      \t4 \lschexpract InterpreterNewStackFrame[ \\
      \t5 classInfo/class?, \\
      \t5 m/methodID?, \\
      \t5 poppedArgs/methodArgs?] \rschexpract \circseq \\
      \t4 Poll \circseq M \circseq pc := j + 1 \\
      \t3 {} \cdots {} \\
      \t3 {} \circelse cid = c_n \circthen A_n \\
      \t3 \circfi) \\
      \t2 {} \circelse pc = k \circthen M \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[virtual-method-call-dist]{crule}{VirtualMethodCallDist}
  \label{virtual-method-call-dist-rule}
  \setlength{\zedtab}{0.3cm}
  \setlength{\zedindent}{0cm}
  \begin{circus}
    \begin{array}{l}
      (\circvar poppedArgs : \seq Word \circspot P \\
      getClassIDOf!(head~poppedArgs)?cid \then {} \\
      \circif cid = c_1 \circthen A_1  \circseq pc := x \\
      {} \cdots {} \\
      {} \circelse cid = c_n \circthen A_\ell \circseq pc := x \\
      \circfi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      (\circvar poppedArgs : \seq Word \circspot P \\
      getClassIDOf!(head~poppedArgs)?cid \then {} \\
      \circif cid = c_1 \circthen A_1 \\
      {} \cdots {} \\
      {} \circelse cid = c_n \circthen A_\ell \\
      \circfi) \circseq pc := x
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\subsection{Refine Main Actions}
\label{main-actions-rules-subsection}

\begin{minipage}{\textwidth}
  \RunningRefinementRule*
\end{minipage}

\section{Elimination of Frame Stack}

\subsection{Remove Launcher Returns}
\label{remove-launcher-returns-appendix-subsection}

\begin{minipage}{\textwidth}
\begin{restatable}[conditional-dist]{crule}{ReturnActionConditionalDist}
  \label{conditional-dist-rule}
  Given an action $X$,
  \begin{circus}
    \begin{array}{l}
      \circvar value1, value2 : Word \circspot A \circseq \\
      \t1 \circif b \circthen B \circseq X \\
      \t1 {} \circelse c \circthen C \circseq X \\
      \t1 \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      (\circvar value1, value2 : Word \circspot A \circseq \\
      \t1 \circif b \circthen B \\
      \t1 {} \circelse c \circthen C \\
      \t1 \circfi) \circseq X
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{algorithm}[H]
  \begin{algorithmic}[1]
    \State $methodBody \gets$ \Call{ActionBody}{$methodName$}
    \Match{$methodBody$}{($A \circseq returnAction$)}
    \State \ApplyFor{Law~[\nameref{action-intro-law}]}{$methodName'$, $A$}
    \State \ApplyReverseToFor{Law~[\nameref{copy-rule-law}]}{$methodBody$}{$methodName'$}
    \State \ExhaustivelyApplyFor{Law~[\nameref{copy-rule-law}]}{$methodName$}
    \State \ApplyReverseFor{Law~[\nameref{action-intro-law}]}{$methodName$, $methodBody$}
    \State \ApplyFor{Law~[\nameref{action-rename-law}]}{$methodName$, $methodName'$}
  \end{algorithmic}
  \caption{RedefineMethodExcludingReturn($methodName$,$returnAction$)}
  \label{redefine-method-action-excluding-return-action-algorithm}
\end{algorithm}

\begin{algorithm}[H]
  \begin{algorithmic}[1]
    \State \Apply{Rule~[\nameref{InterpreterInitEPC-frameStack-assump-intro-rule}]} 
    \State {\bf exhaustively apply} \\
    $\t1$ Rule~[\nameref{frameStack-assump-non-return-dist-rule}] \\
    $\t1$ Rule~[\nameref{frameStack-assump-return-dist-rule}] \\
    $\t1$ Rule~[\nameref{frameStack-assump-NewStackFrame-dist-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-alt-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-alt-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-var-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-var-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-output-prefix-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-output-prefix-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-input-prefix-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-input-prefix-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-infinite-loop-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-infinite-loop-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-while-loop-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-while-loop-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-do-while-loop-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-do-while-loop-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-mid-while-loop-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-mid-while-loop-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-extchoice-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-extchoice-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-guard-dist-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-assign-dist-rule}]
  \end{algorithmic}
  \caption{IntroduceFrameStackAssumptions}
  \label{introduce-frameStack-assumptions-algorithm}
\end{algorithm}

\begin{minipage}{\textwidth}
\begin{restatable}[$InterpreterInitEPC$-$frameStack$-assump-intro]{crule}{InterpreterInitEPCFrameStackAssumpIntro}
  \label{InterpreterInitEPC-frameStack-assump-intro-rule}
  \begin{circus}
    \begin{array}{l}
      \lschexpract InterpreterInitEPC \rschexpract
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \lschexpract InterpreterInitEPC \rschexpract \circseq
      \{ \# frameStack = 0 \}
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[$frameStack$-assump-NewStackFrame-dist]{crule}{FrameStackAssumpNewStackFrameDist}
  \label{frameStack-assump-NewStackFrame-dist-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# frameStack = k\} \circseq \\
      \lschexpract InterpreterNewStackFrame[ \\
      \t1 c/class?,
      \t1 m/methodID?, \\
      \t1 args/methodArgs?]\rschexpract
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{\# frameStack = k\} \circseq \\
      \lschexpract InterpreterNewStackFrame[ \\
      \t1 c/class?,
      \t1 m/methodID?, \\
      \t1 args/methodArgs?]\rschexpract \circseq \\
      \{\# frameStack = k + 1 \}
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[$frameStack$-assump-non-return-dist]{crule}{FrameStackAssumpNonReturnDist}
  \label{frameStack-assump-non-return-dist-rule}
  If $A$ is one of
  \begin{itemize}
  \item $\Skip$
  \item $Poll$,
  \item $HandleAconst\_nullEPC$,
  \item $HandleDupEPC$,
  \item $HandleAloadEPC(lvi)$,
  \item $HandleAstoreEPC(lvi)$,
  \item $HandleIaddEPC$,
  \item $HandleIconstEPC(n)$,
  \item $HandleInegEPC$,
  \item $\lschexpract InterpreterPopEPC \rschexpract$,
  \item $\lschexpract InterpreterPushEPC \rschexpract$,
  \item $\lschexpract \exists argsToPop? == m @ InterpreterStackFrameInvoke \rschexpract$,
  \item $HandleNewEPC(cpi)$,
  \item $HandleGetfieldEPC(cpi)$,
  \item $HandlePutfieldEPC(cpi)$,
  \item $HandleGetstaticEPC(cpi)$, or
  \item $HandlePutstaticEPC(cpi)$,
  \end{itemize}
  and $B$ does not begin with $\{\# frameStack = k\}$, then
  \begin{circus}
    \begin{array}{l}
      \{\# frameStack = k\} \circseq A \circseq B
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{\# frameStack = k\} \circseq A \circseq \{\# frameStack = k \} \circseq B
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[$frameStack$-assump-return-dist-rule]{crule}{FrameStackAssumpReturnDist}
  \label{frameStack-assump-return-dist-rule}
  If $A$ is $HandleAreturnEPC$ or $HandleReturnEPC$, $B$ does not begin with
  $\{\# frameStack = k\}$, and $k > 0$ then
  \begin{circus}
    \begin{array}{l}
      \{\# frameStack = k\} \circseq A \circseq B
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{\# frameStack = k\} \circseq A \circseq \\
      \t1 \{\# frameStack = k - 1 \} \circseq B
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[restricted-assump-alt-distl]{crule}{RestrictedAssumpAltDistl}
  \label{restricted-assump-alt-distl-rule}
  If no $A_i$ begins with $\{h\}$ then
  \begin{circus}
    \{h\} \circseq \circif {} \circelse_{i} g_i \circthen A_i \circfi
    =
    \{h\} \circseq \circif {} \circelse_{i} g_i \circthen \{h\} \circseq A_i \circfi
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[restricted-assump-alt-distr]{crule}{RestrictedAssumpAltDistr}
  \label{restricted-assump-alt-distr-rule}
  If no $A_i$ begins with $\{h\}$ then
  \begin{circus}
    \circif {} \circelse_{i} g_i \circthen A_i \circseq \{h\} \circfi
    =
    \{h\} \circseq \circif {} \circelse_{i} g_i \circthen A_i \circfi \circseq \{h\}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[restricted-assump-var-distl]{crule}{RestrictedAssumpVarDistl}
  \label{restricted-assump-var-distl-rule}
  If $A$ does not begin with $\{h\}$ then
  \begin{circus}
    \{h\} \circseq (\circvar x : T \circspot A)
    =
    \{h\} \circseq (\circvar x : T \circspot \{h\} \circseq A)
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[restricted-assump-var-distr]{crule}{RestrictedAssumpVarDistr}
  \label{restricted-assump-var-distr-rule}
  If $B$ does not begin with $\{h\}$ then
  \begin{circus}
    (\circvar x : T \circspot A \circseq \{h\}) \circseq B
    =
    (\circvar x : T \circspot A \circseq \{h\}) \circseq \{h\} \circseq B
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[restricted-assump-output-prefix-distl]{crule}{RestrictedAssumpOutputPrefixDistl}
  \label{restricted-assump-output-prefix-distl-rule}
  If $A$ does not begin with $\{g\}$  then
  \begin{circus}
    \{ g \} \circseq c!x \then A = \{ g \} \circseq c!x \then \{ g \} \circseq A
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[restricted-assump-output-prefix-distr]{crule}{RestrictedAssumpOutputPrefixDistr}
  \label{restricted-assump-output-prefix-distr-rule}
  If $B$ does not begin with $\{g\}$ then
  \begin{circus}
    (c!x \then A \circseq \{ g \}) \circseq B
    =
    (c!x \then A \circseq \{ g \}) \circseq \{ g \} \circseq B
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[restricted-assump-input-prefix-distl]{crule}{RestrictedAssumpInputPrefixDistl}
  \label{restricted-assump-input-prefix-distl-rule}
  If $A$ does not begin with $\{g\}$ and $x$ is not free in $\{g\}$
  then
  \begin{circus}
    \{ g \} \circseq c?x \then A
    =
    \{ g \} \circseq c?x \then \{ g \} \circseq A
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[restricted-assump-input-prefix-distr]{crule}{RestrictedAssumpInputPrefixDistr}
  \label{restricted-assump-input-prefix-distr-rule}
  If $B$ does not begin with $\{g\}$ and $x$ is not free in $\{g\}$ then
  \begin{circus}
    (c?x \then A \circseq \{ g \}) \circseq B
    =
    (c?x \then A \circseq \{ g \}) \circseq \{ g \} \circseq B
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[restricted-assump-infinite-loop-distl]{crule}{RestrictedAssumpInfiniteLoopDistl}
  \label{restricted-assump-infinite-loop-distl-rule}
  If $A$ does not begin with $\{g\}$ and
  $\{g\} \circseq A \circrefines_A A \circseq \{g\}$ then
  \begin{circus}
    \{g\} \circseq (\circmu X \circspot A \circseq X)
    \circrefines_A
    \{g\} \circseq (\circmu X \circspot \{g\} \circseq A \circseq X)
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[restricted-assump-infinite-loop-distr]{crule}{RestrictedAssumpInfiniteLoopDistr}
  \label{restricted-assump-infinite-loop-distr-rule}
  If $B$ does not begin with $\{g\}$ then
  \begin{circus}
    (\circmu X \circspot A \circseq \{g\} \circseq X) \circseq B
    =
    (\circmu X \circspot A \circseq \{g\} \circseq X) \circseq \{g\} \circseq B
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[restricted-assump-mid-while-loop-distl]{crule}{RestrictedAssumpMidWhileLoopDistl}
  \label{restricted-assump-mid-while-loop-distl-rule}
  If $A$ does not begin with $\{g\}$,
  $\{g\} \circseq A \circrefines_A A \circseq \{g\}$,
  $\{g\} \circseq B \circrefines_A B \circseq \{g\}$,
  then
  \begin{circus}
    \begin{array}{l}
      \{g\} \circseq (\circmu X \circspot A \circseq \\
      \t1 \circif h \circthen B \circseq X \\
      \t1 {} \circelse \lnot h \circthen \Skip \\
      \t1 \circfi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{g\} \circseq (\circmu X \circspot \{g\} \circseq A \circseq \\
      \t1 \circif h \circthen B \circseq X \\
      \t1 {} \circelse \lnot h \circthen \Skip \\
      \t1 \circfi)
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[restricted-assump-mid-while-loop-distr]{crule}{RestrictedAssumpMidWhileLoopDistr}
  \label{restricted-assump-mid-while-loop-distr-rule}
  If $C$ does not begin with $\{g\}$,
  $\{g\} \circseq A \circrefines_A A \circseq \{g\}$,
  $\{g\} \circseq B \circrefines_A B \circseq \{g\}$,
  then
  \begin{circus}
    \begin{array}{l}
      (\circmu X \circspot A \circseq \\
      \t1 \circif h \circthen B \circseq \{g\} \circseq X \\
      \t1 {} \circelse \lnot h \circthen \Skip \circseq \{g\} \\
      \t1 \circfi) \circseq C
    \end{array}
    \circrefines_A
    \begin{array}{l}
      (\circmu X \circspot A \circseq \\
      \t1 \circif h \circthen B \circseq \{g\} \circseq X \\
      \t1 {} \circelse \lnot h \circthen \Skip \circseq \{g\}  \\
      \t1 \circfi) \circseq \{g\} \circseq C
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[restricted-assump-do-while-loop-distl]{crule}{RestrictedAssumpDoWhileLoopDistl}
  \label{restricted-assump-do-while-loop-distl-rule}
  If $A$ does not begin with $\{g\}$ and
  $\{g\} \circseq A \circrefines_A A \circseq \{g\}$,
  then
  \begin{circus}
    \begin{array}{l}
      \{g\} \circseq (\circmu X \circspot A \circseq \\
      \t1 \circif h \circthen X \\
      \t1 {} \circelse \lnot h \circthen \Skip \\
      \t1 \circfi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{g\} \circseq (\circmu X \circspot \{g\} \circseq A \circseq \\
      \t1 \circif h \circthen X \\
      \t1 {} \circelse \lnot h \circthen \Skip \\
      \t1 \circfi)
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[restricted-assump-do-while-loop-distr]{crule}{RestrictedAssumpDoWhileLoopDistr}
  \label{restricted-assump-do-while-loop-distr-rule}
  If $B$ does not begin with $\{g\}$ and
  $\{g\} \circseq A \circrefines_A A \circseq \{g\}$,
  then
  \begin{circus}
    \begin{array}{l}
      (\circmu X \circspot A \circseq \\
      \t1 \circif h \then \{g\} \circseq X \\
      \t1 {} \circelse \lnot h \circseq \Skip \circseq \{g\} \\
      \t1 \circfi) \circseq B
    \end{array}
    \circrefines_A
    \begin{array}{l}
      (\circmu X \circspot A \circseq \\
      \t1 \circif h \then \{g\} \circseq X \\
      \t1 {} \circelse \lnot h \circseq \Skip \circseq \{g\} \\
      \t1 \circfi) \circseq \{g\} \circseq B
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[restricted-assump-while-loop-distl]{crule}{RestrictedAssumpWhileLoopDistl}
  \label{restricted-assump-while-loop-distl-rule}
  If $A$ does not begin with $\{g\}$ and
  $\{g\} \circseq A \circrefines_A A \circseq \{g\}$,
  then
  \begin{circus}
    \begin{array}{l}
      \{g\} \circseq (\circmu X \circspot \\
      \t1 \circif h \circthen A \circseq X \\
      \t1 {} \circelse \lnot h \circthen \Skip \\
      \t1 \circfi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{g\} \circseq (\circmu X \circspot \{g\} \circseq \\
      \t1 \circif h \circthen A \circseq X \\
      \t1 {} \circelse \lnot h \circthen \Skip \\
      \t1 \circfi)
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[restricted-assump-while-loop-distr]{crule}{RestrictedAssumpWhileLoopDistr}
  \label{restricted-assump-while-loop-distr-rule}
  If $B$ does not begin with $\{g\}$ and
  $\{g\} \circseq A \circrefines_A A \circseq \{g\}$,
  then
  \begin{circus}
    \begin{array}{l}
      (\circmu X \circspot \\
      \t1 \circif h \circthen A \circseq \{g\} \circseq X \\
      \t1 {} \circelse \lnot h \circthen \Skip \circseq \{g\}  \\
      \t1 \circfi) \circseq B
    \end{array}
    \circrefines_A
    \begin{array}{l}
      (\circmu X \circspot \\
      \t1 \circif h \circthen A \circseq \{g\} \circseq X \\
      \t1 {} \circelse \lnot h \circthen \Skip \circseq \{g\} \\
      \t1 \circfi) \circseq \{g\} \circseq B
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[restricted-assump-extchoice-distl]{crule}{RestrictedAssumpExtchoiceDistl}
  \label{restricted-assump-extchoice-distl-rule}
  If $A$ and $B$ do not begin with $\{g\}$ then
  \begin{circus}
    \begin{array}{l}
      \{g\} \circseq (A \extchoice B)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{g\} \circseq ((\{g\} \circseq A) \extchoice (\{g\} \circseq B))
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[restricted-assump-extchoice-distr]{crule}{RestrictedAssumpExtchoiceDistr}
  \label{restricted-assump-extchoice-distr-rule}
  If $C$ does not begin with $\{g\}$ then
  \begin{circus}
    \begin{array}{l}
      ((A \circseq \{g\}) \extchoice (B \circseq \{g\})) \circseq C
    \end{array}
    \circrefines_A
    \begin{array}{l}
      ((A \circseq \{g\}) \extchoice (B \circseq \{g\})) \circseq \{g\} \circseq C
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[restricted-assump-guard-dist]{crule}{RestrictedAssumpGuardDist}
  \label{restricted-assump-guard-dist-rule}
  If $A$ does not begin with $\{g\}$ then
  \begin{circus}
    \begin{array}{l}
      \{g\} \circseq \lcircguard h \rcircguard \circguard A
    \end{array}
    =
    \begin{array}{l}
      \{g\} \circseq \lcircguard h \rcircguard \circguard \{g\} \circseq A
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[restricted-assump-assign-dist]{crule}{RestrictedAssumpAssignDist}
  \label{restricted-assump-assign-dist-rule}
  If $B$ does not begin with $\{g\}$ and $x$ is not free in $g$ then
  \begin{circus}
    \begin{array}{l}
      \{g\} \circseq x := e \circseq B
    \end{array}
    =
    \begin{array}{l}
      \{g\} \circseq x := e \circseq \{g\} \circseq B
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\RefineHandleReturnEPCEmptyFrameStackRule*
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[refine-$HandleReturnEPC$-nonempty-$frameStack$]{crule}{RefineHandleReturnEPCNonemptyFrameStackRule}
  \label{refine-HandleReturnEPC-nonempty-frameStack-rule}
  If $k > 1$ then
  \begin{circus}
    \begin{array}{l}
      \{\# frameStack = k\} \circseq \\
      HandleReturnEPC
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \lschexpract InterpreterReturnEPC \rschexpract
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[refine-$HandleAreturnEPC$-empty-$frameStack$]{crule}{RefineHandleAreturnEPCEmptyFrameStackRule}
  \label{refine-HandleAreturnEPC-empty-frameStack-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# frameStack = 1\} \circseq \\
      HandleAreturnEPC
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circvar returnValue : Word \circspot \\
      \lschexpract InterpreterAreturn2EPC \rschexpract \circseq \\
      executeMethodRet!thread!returnValue \then \Skip
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[refine-$HandleAreturnEPC$-nonempty-$frameStack$]{crule}{RefineHandleAreturnEPCNonemptyFrameStackRule}
  \label{refine-HandleAreturnEPC-nonempty-frameStack-rule}
  If $k > 1$ then
  \begin{circus}
    \begin{array}{l}
      \{\# frameStack = k\} \circseq \\
      HandleAreturnEPC
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \lschexpract InterpreterAreturn1EPC \rschexpract
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\subsection{Localise Stack Frames}
\label{localise-stack-frames-appendix-subsection}

\begin{minipage}{\textwidth}
  \ArgumentsIntroductionRule*
\end{minipage}

\begin{algorithm}[H]
  \begin{algorithmic}[1]
    \MatchThen{%
      $\begin{array}[t]{l}
         (\circval arg1, \ldots, arg{<}n{>} : Word \circspot \\
         \t1 \lschexpract \exists methodArgs? == \langle arg1, \ldots, arg{<}n{>} \rangle @ \\
         \t2 InterpreterNewStackFrame[c/class?, m/methodID?] \rschexpract \circseq \\
         \t1 Poll \circseq methodName \circseq \lschexpract InterpreterReturn \rschexpract)(args~1, \ldots, args~n)
       \end{array}$}
     \State \ApplyFor{Law~[\nameref{action-intro-law}]}{$methodName'$, %
       $\begin{array}[t]{l}
          (\circval arg1, \ldots, arg{<}n{>} : Word \circspot \\
          \t1 \lschexpract \exists methodArgs? \\
          \t3 {} == \langle arg1, \ldots, arg{<}n{>} \rangle @ \\
          \t2 InterpreterNewStackFrame[ \\
          \t3 c/class?, m/methodID?] \rschexpract \circseq \\
          \t1 Poll \circseq methodName \circseq \\
          \t1 \lschexpract InterpreterReturn \rschexpract)
        \end{array}$}
      \State \ExhaustivelyApplyReverseFor{Law~[\nameref{copy-rule-law}]}{$methodName'$}
      \State \ApplyToFor{Law~[\nameref{copy-rule-law}]}{\Call{ActionBody}{$methodName'$}}{$methodName$}
      \State \ApplyReverseFor{Law~[\nameref{action-intro-law}]}{$methodName$, $methodBody$}
      \State \ApplyFor{Law~[\nameref{action-rename-law}]}{$methodName'$, $methodName$}
  \end{algorithmic}
  \caption{RedefineMethodToIncludeParameters($nethodName$)}
  \label{redefine-method-action-to-include-parameters-algorithm}
\end{algorithm}

\begin{minipage}{\textwidth}
  \HandleReturnEPCStackFrameIntroductionRule*
\end{minipage}

% \begin{restatable}[$InterpreterAreturn$-$stackFrame$-introduction]{crule}{HandleAreturnEPCStackFrameIntroductionRule}
%   \label{HandleAreturnEPC-stackFrame-introduction-rule}
%   %\setlength{\zedtab}{0.4cm}
%   %\setlength{\zedindent}{0pt}
%   %\setlength{\zedleftsep}{0pt}
%   If the actions in $A$ operate solely on $last~frameStack$ and do not
%   change the length of $frameStack$, then
%   \begin{circus}
%     \begin{array}{l}
%       InterpreterNewStackFrame[ \\
%       \t1 c/class?, \\
%       \t1 m/methodID?, \\
%       \t1 args/methodArgs?] \circseq \\
%       A \circseq \lschexpract InterpreterAreturn1 \rschexpract
%     \end{array}
%     \circrefines_A
%     \begin{array}{l}
%       (\circvar retVal : Word \circspot \\
%       \t1 (\circvar stackFrame : StackFrameEPC \circspot \\
%       \t2 \lschexpract [stackFrame' : StackFrameEPC | \\
%       \t3 args \subseteq stackFrame'.localVariables \land \\
%       \t3 \# stackFrame'.localVariables = \ell \land \\
%       \t3 stackFrame'.operandStack = \langle\rangle \land \\
%       \t3 stackFrame'.frameClass = c \land \\
%       \t3 stackFrame'.stackSize = s] \rschexpract \circseq \\
%       \t2 A[stackFrame/last~frameStack, \\
%       \t3 stackFrame'/last~frameStack'] \circseq \\
%       \t2 \lschexpract InterpreterPopEPC[ \\
%       \t3 stackFrame/last~frameStack, \\
%       \t3 stackFrame'/last~frameStack', \\
%       \t3 retVal!/value!] \rschexpract) \\
%       \t1 \lschexpract InterpreterPushEPC[retVal?/value?]  \rschexpract)
%     \end{array}
%   \end{circus}
%   where $\ell = c.methodLocals~m$ and $s = c.methodStackSize~m$.
% \end{restatable}

% TODO: rules for the areturn cases here?

\subsection{Introduce Variables}
\label{introduce-variables-appendix-subsection}

\begin{algorithm}[H]
  \begin{algorithmic}[1]
    \State \ApplyTo{Rule~[\nameref{stackFrame-init-frameClass-assump-intro-rule}]}{$A$}
    \State {\bf exhaustively apply to }{$A$}  \\
    $\t1$ Rule~[\nameref{frameClass-assump-dist-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-alt-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-alt-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-var-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-var-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-output-prefix-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-output-prefix-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-input-prefix-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-input-prefix-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-infinite-loop-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-infinite-loop-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-while-loop-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-while-loop-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-do-while-loop-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-do-while-loop-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-mid-while-loop-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-mid-while-loop-distr-rule}]
    % $\t1$ Rule~[\nameref{restricted-assump-extchoice-distl-rule}] \\
    % $\t1$ Rule~[\nameref{restricted-assump-extchoice-distr-rule}] \\
    % $\t1$ Rule~[\nameref{restricted-assump-guard-dist-rule}] \\
    % $\t1$ Rule~[\nameref{restricted-assump-assign-dist-rule}]
  \end{algorithmic}
  \caption{IntroduceFrameClassAssumptions(A)}
  \label{introduce-frameClass-assumptions-algorithm}
\end{algorithm}

\begin{minipage}{\textwidth}
\begin{restatable}[$stackFrame$-init-$frameClass$-assump-intro]{crule}{StackFrameInitFrameClassAssumpIntroRule}
  \label{stackFrame-init-frameClass-assump-intro-rule}
  \setlength{\zedindent}{0.5cm}
  \begin{circus}
    \begin{array}{l}
      \lschexpract [arg1?, \ldots, arg{<}n{>}? : Word; \\
      \t1 stackFrame' : StackFrameEPC  | \\
      \t1 \langle arg1?, \ldots, arg{<}n{>}? \rangle \\
      \t2 {} \subseteq stackFrame'.localVariables \land \\
      \t1 \# stackFrame'.localVariables = \ell \land \\
      \t1 stackFrame'.operandStack = \langle\rangle \land \\
      \t1 stackFrame'.frameClass = c \land \\
      \t1 stackFrame'.stackSize = s] \rschexpract
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \lschexpract [arg1?, \ldots, arg{<}n{>}? : Word; \\
      \t1 stackFrame' : StackFrameEPC  | \\
      \t1 \langle arg1?, \ldots, arg{<}n{>}? \rangle \\
      \t2 {} \subseteq stackFrame'.localVariables \land \\
      \t1 \# stackFrame'.localVariables = \ell \land \\
      \t1 stackFrame'.operandStack = \langle\rangle \land \\
      \t1 stackFrame'.frameClass = c \land \\
      \t1 stackFrame'.stackSize = s] \rschexpract \circseq \\
      \{ stackFrame.frameClass = c\}
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[$frameClass$-assump-dist]{crule}{FrameClassAssumpDistRule}
  \label{frameClass-assump-dist-rule}
  If $A$ is one of
  \begin{itemize}
  \item $\Skip$,
  \item $Poll$,
  \item $HandleAconst\_nullSF$,
  \item $HandleDupSF$,
  \item $HandleAloadSF(lvi)$,
  \item $HandleAstoreSF(lvi)$,
  \item $HandleIaddSF$,
  \item $HandleIconstSF(n)$,
  \item $HandleInegSF$,
  \item $\lschexpract InterpreterPopSF \rschexpract$,
  \item $\lschexpract InterpreterPushSF \rschexpract$,
  \item $\lschexpract \exists argsToPop? == m @ InvokeSF \rschexpract$
  \end{itemize}
  and $B$ does not begin with $\{ stackFrame.frameClass = c \}$, then
  \begin{circus}
    \begin{array}{l}
      \{ stackFrame.frameClass = c \} \circseq A \circseq B
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ stackFrame.frameClass = c \} \circseq A \circseq \\
      \{ stackFrame.frameClass = c \} \circseq B
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
  \RefinePutfieldSFRule*
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[refine-$GetfieldSF$]{crule}{RefineGetfieldSFRule}
  \label{refine-GetfieldSF-rule}
  \begin{circus}
    \begin{array}{l}
      \{stackFrame.frameClass = c\} \circseq \\
      GetfieldSF(cpi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      (\circvar oid : ObjectID \circspot \\
      \t1 \lschexpract InterpreterPop[ \\
      \t2 oid!/value!, \\
      \t2 stackFrame/last~frameStack, \\
      \t2 stackFrame'/last~frameStack'] \rschexpract \circseq \\
      \t1 getField!oid!cid!fid! \\
      \t1 {} \then getFieldRet?value \\
      \t1 {} \then \lschexpract InterpreterPush[ \\
      \t2 stackFrame/last~frameStack, \\
      \t2 stackFrame'/last~frameStack'] \rschexpract)
    \end{array}
  \end{circus}
  where
  \begin{circus}
    cpi \in fieldRefIndices~c \land \\
    c.constantPool~cpi = FieldRef~(cid, fid)
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[refine-$PutstaticSF$]{crule}{RefinePutstaticSFRule}
  \label{refine-PutstaticSF-rule}
  \begin{circus}
    \begin{array}{l}
      \{stackFrame.frameClass = c\} \circseq \\
      PutstaticSF(cpi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      (\circvar value : Word \circspot \\
      \t1 \lschexpract InterpreterPop[ \\
      \t2 stackFrame/last~frameStack, \\
      \t2 stackFrame'/last~frameStack'] \rschexpract \circseq \\
      \t1 putStatic!cid!fid!value \then \Skip)
    \end{array}
  \end{circus}
  where
  \begin{circus}
    cpi \in fieldRefIndices~c \land \\
    c.constantPool~cpi = FieldRef~(cid, fid)
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[refine-$GetstaticSF$]{crule}{RefineGetstaticSFRule}
  \label{refine-GetstaticSF-rule}
  \begin{circus}
    \begin{array}{l}
      \{stackFrame.frameClass = c\} \circseq \\
      GetstaticSF(cpi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      getStatic!cid!fid \\
      {} \then getStaticRet?value \\
      {} \then \lschexpract InterpreterPush[ \\
      \t1 stackFrame/last~frameStack, \\
      \t1 stackFrame'/last~frameStack'] \rschexpract)
    \end{array}
  \end{circus}
  where
  \begin{circus}
    cpi \in fieldRefIndices~c \land \\
    c.constantPool~cpi = FieldRef~(cid, fid)
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[refine-$NewSF$]{crule}{RefineNewSFRule}
  \label{refine-NewSF-rule}
  \begin{circus}
    \begin{array}{l}
      \{stackFrame.frameClass = c\} \circseq \\
      NewSF(cpi)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      newObject!thread!cid \\
      {} \then newObjectRet?oid \\
      {} \then \lschexpract InterpreterPush[ \\
      \t1 oid/value?, \\
      \t1 stackFrame/last~frameStack, \\
      \t1 stackFrame'/last~frameStack'] \rschexpract)
    \end{array}
  \end{circus}
  where
  \begin{circus}
    cpi \in ClassRefIndices~c \land \\
    c.constantPool~cpi = ClassRef~cid
  \end{circus}
\end{restatable}
\end{minipage}

\begin{algorithm}[H]
  \begin{algorithmic}[1]
    \State \ApplyTo{Rule~[\nameref{stackFrame-init-operandStack-assump-intro-rule}]}{$A$}
    \State {\bf exhaustively apply to }{$A$}  \\
    $\t1$ Rule~[\nameref{operandStack-assump-unchanged-dist-rule}] \\
    $\t1$ Rule~[\nameref{operandStack-assump-increment-dist-rule}] \\
    $\t1$ Rule~[\nameref{operandStack-assump-decrement-dist-rule}] \\
    $\t1$ Rule~[\nameref{operandStack-assump-InvokeSF-dist-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-alt-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-alt-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-var-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-var-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-output-prefix-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-output-prefix-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-input-prefix-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-input-prefix-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-infinite-loop-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-infinite-loop-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-while-loop-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-while-loop-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-do-while-loop-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-do-while-loop-distr-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-mid-while-loop-distl-rule}] \\
    $\t1$ Rule~[\nameref{restricted-assump-mid-while-loop-distr-rule}]
    % $\t1$ Rule~[\nameref{restricted-assump-extchoice-distl-rule}] \\
    % $\t1$ Rule~[\nameref{restricted-assump-extchoice-distr-rule}] \\
    % $\t1$ Rule~[\nameref{restricted-assump-guard-dist-rule}] \\
    % $\t1$ Rule~[\nameref{restricted-assump-assign-dist-rule}]
  \end{algorithmic}
  \caption{IntroduceOperandStackAssumptions(A)}
  \label{introduce-operandStack-assumptions-algorithm}
\end{algorithm}

\begin{minipage}{\textwidth}
\begin{restatable}[$operandStack$-init-$frameClass$-assump-intro]{crule}{StackFrameInitOperandStackAssumpIntroRule}
  \label{stackFrame-init-operandStack-assump-intro-rule}
  \setlength{\zedindent}{0.1cm}
  \begin{circus}
    \begin{array}{l}
      \lschexpract [arg1?, \ldots, arg{<}n{>}? : Word; \\
      \t1 stackFrame' : StackFrameEPC  | \\
      \t1 \langle arg1?, \ldots, arg{<}n{>}? \rangle \\
      \t2 {} \subseteq stackFrame'.localVariables \land \\
      \t1 \# stackFrame'.localVariables = \ell \land \\
      \t1 stackFrame'.operandStack = \langle\rangle \land \\
      \t1 stackFrame'.frameClass = c \land \\
      \t1 stackFrame'.stackSize = s] \rschexpract
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \lschexpract [arg1?, \ldots, arg{<}n{>}? : Word; \\
      \t1 stackFrame' : StackFrameEPC  | \\
      \t1 \langle arg1?, \ldots, arg{<}n{>}? \rangle \\
      \t2 {} \subseteq stackFrame'.localVariables \land \\
      \t1 \# stackFrame'.localVariables = \ell \land \\
      \t1 stackFrame'.operandStack = \langle\rangle \land \\
      \t1 stackFrame'.frameClass = c \land \\
      \t1 stackFrame'.stackSize = s] \rschexpract \circseq \\
      \{ \# stackFrame.operandStack = 0 \}
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[$operandStack$-assump-unchanged-dist]{crule}{OperandStackAssumpUnchangedDistRule}
  \label{operandStack-assump-unchanged-dist-rule}
  \setlength{\zedindent}{0.1cm}
  If $A$ is one of
  \begin{itemize}
  \item $\Skip$,
  \item $Poll$,
  % \item $HandleAconst\_nullSF$,
  % \item $HandleDupSF$,
  % \item $HandleAloadSF(lvi)$,
  % \item $HandleAstoreSF(lvi)$,
  % \item $HandleIaddSF$,
  % \item $HandleIconstSF(n)$,
  \item $HandleInegSF$,
  % \item $\lschexpract InterpreterPopSF \rschexpract$,
  % \item $\lschexpract InterpreterPushSF \rschexpract$,
  % \item $\lschexpract \exists argsToPop? == m @ InvokeSF \rschexpract$
  \end{itemize}
  and $B$ does not begin with $\{ \# stackFrame.operandStack = k \}$, then
  \begin{circus}
    \begin{array}{l}
      \{ \# stackFrame.operandStack = k \} \circseq A \circseq B
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ \# stackFrame.operandStack = k \} \circseq A \circseq \\ \{ \# stackFrame.operandStack = k \} \circseq B
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[$operandStack$-assump-increment-dist]{crule}{OperandStackAssumpIncrementDistRule}
  \label{operandStack-assump-increment-dist-rule}
  \setlength{\zedindent}{0.1cm}
  If $A$ is one of
  \begin{itemize}
  % \item $\Skip$,
  % \item $Poll$,
  \item $HandleAconst\_nullSF$,
  \item $HandleDupSF$,
  \item $HandleAloadSF(lvi)$,
  % \item $HandleAstoreSF(lvi)$,
  % \item $HandleIaddSF$,
  \item $HandleIconstSF(n)$,
  % \item $HandleInegSF$,
  % \item $\lschexpract InterpreterPopSF \rschexpract$,
  \item $\lschexpract InterpreterPushSF \rschexpract$,
  % \item $\lschexpract \exists argsToPop? == m @ InvokeSF \rschexpract$
  \end{itemize}
  and $B$ does not begin with $\{ \# stackFrame.operandStack = k+1 \}$, then
  \begin{circus}
    \begin{array}{l}
      \{ \# stackFrame.operandStack = k \} \circseq A \circseq B
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ \# stackFrame.operandStack = k \} \circseq A \circseq \\
      \{ \# stackFrame.operandStack = k+1 \} \circseq B
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[$operandStack$-assump-decrement-dist]{crule}{OperandStackAssumpDecrementDistRule}
  \label{operandStack-assump-decrement-dist-rule}
  \setlength{\zedindent}{0.1cm}
  If $A$ is one of
  \begin{itemize}
  % \item $\Skip$,
  % \item $Poll$,
  % \item $HandleAconst\_nullSF$,
  % \item $HandleDupSF$,
  % \item $HandleAloadSF(lvi)$,
  \item $HandleAstoreSF(lvi)$,
  \item $HandleIaddSF$,
  \item $HandleIconstSF(n)$,
  % \item $HandleInegSF$,
  \item $\lschexpract InterpreterPopSF \rschexpract$,
  % \item $\lschexpract InterpreterPushSF \rschexpract$,
  % \item $\lschexpract \exists argsToPop? == m @ InvokeSF \rschexpract$
  \end{itemize}
  and $B$ does not begin with $\{ \# stackFrame.operandStack = k-1 \}$, then
  \begin{circus}
    \begin{array}{l}
      \{ \# stackFrame.operandStack = k \} \circseq A \circseq B
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ \# stackFrame.operandStack = k \} \circseq A \circseq \\ \{ \# stackFrame.operandStack = k-1 \} \circseq B
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[$operandStack$-assump-$InvokeSF$-dist]{crule}{OperandStackAssumpInvokeSFDistRule}
  \label{operandStack-assump-InvokeSF-dist-rule}
  \setlength{\zedindent}{0.1cm}
  If $B$ does not begin with \[\{ \# stackFrame.operandStack = k-m \},\] then
  \begin{circus}
    \begin{array}{l}
      \{ \# stackFrame.operandStack = k \} \circseq \\
      \lschexpract \exists argsToPop? == m @ InvokeSF \rschexpract \circseq B
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ \# stackFrame.operandStack = k \} \circseq \\
      \lschexpract \exists argsToPop? == m @ InvokeSF \rschexpract \circseq \\
      \{ \# stackFrame.operandStack = k-m \} \circseq B
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[$HandleAconst\_nullSF$-simulation]{crule}{HandleAconstNullSFSimulationRule}
  \label{HandleAconst_nullSF-simulation-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# stackFrame.operandStack = k\} \circseq \\
      HandleAconst\_nullSF
    \end{array}
    \circsimulates
    \begin{array}{l}
      stack{<}k+1{>} := null
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[$HandleDupSF$-simulation]{crule}{HandleDupSFSimulationRule}
  \label{HandleDupSF-simulation-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# stackFrame.operandStack = k\} \circseq \\
      HandleDupSF
    \end{array}
    \circsimulates
    \begin{array}{l}
      stack{<}k+1{>} := stack{<}k{>}
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
  \HandleAloadSFSimulationRule*
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[$HandleAstoreSF$-simulation]{crule}{HandleAstoreSFSimulationRule}
  \label{HandleAstoreSF-simulation-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# stackFrame.operandStack = k\} \circseq \\
      HandleAstoreSF(lvi)
    \end{array}
    \circsimulates
    \begin{array}{l}
      var{<}lvi+1{>} := stack{<}k{>} 
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[$HandleIaddSF$-simulation]{crule}{HandleIaddSFSimulationRule}
  \label{HandleIaddSF-simulation-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# stackFrame.operandStack = k\} \circseq \\
      HandleIaddSF
    \end{array}
    \circsimulates
    \begin{array}{l}
      stack{<}k-1{>} := stack{<}k-1{>} + stack{<}k{>} 
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[$HandleIconstSF$-simulation]{crule}{HandleIconstSFSimulationRule}
  \label{HandleIconstSF-simulation-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# stackFrame.operandStack = k\} \circseq \\
      HandleIconstSF(n)
    \end{array}
    \circsimulates
    \begin{array}{l}
      stack{<}k+1{>} := n 
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[$HandleInegSF$-simulation]{crule}{HandleInegSFSimulationRule}
  \label{HandleInegSF-simulation-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# stackFrame.operandStack = k\} \circseq \\
      HandleInegSF
    \end{array}
    \circsimulates
    \begin{array}{l}
      stack{<}k{>} := \negate stack{<}k{>} 
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
  \InterpreterPopEPCSimulationRule*
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[$InterpreterPushEPC$-simulation]{crule}{InterpreterPushEPCSimulationRule}
  \label{InterpreterPushEPC-simulation-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# stackFrame.operandStack = k\} \circseq \\
      \lschexpract InterpreterPushEPC[ \\
      \t1 stackFrame/last~frameStack, \\
      \t1 stackFrame'/last~frameStack']\rschexpract
    \end{array}
    \circsimulates
    \begin{array}{l}
      stack{<}k+1{>} := value
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[$InterpreterPop2EPC$-simulation]{crule}{InterpreterPop2EPCSimulationRule}
  \label{InterpreterPop2EPC-simulation-rule}
  \begin{circus}
    \begin{array}{l}
      \{\# stackFrame.operandStack = k\} \circseq \\
      \lschexpract InterpreterPopEPC[ \\
      \t1 stackFrame/last~frameStack, \\
      \t1 stackFrame'/last~frameStack']\rschexpract
    \end{array}
    \circsimulates
    \begin{array}{l}
      value1 := stack{<}k-1{>} \circseq \\
      value2 := stack{<}k{>}      
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
  \InvokeSFSimulationRule*
\end{minipage}

\begin{minipage}{\textwidth}
  \StackFrameInitSimulationRule*
\end{minipage}

\begin{minipage}{\textwidth}
  \EliminateValueOneValueTwoConditional*
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[$getField$-$oid$-elim]{crule}{EliminateOidGetField}
  \label{eliminate-oid-getField-rule}
  \begin{circus}
    \begin{array}{l}
      (\circvar oid : ObjectID \circspot \\
      \t1 oid := stack{<}k{>} \circseq \\
      \t1 getfield!oid!cid!fid \\
      \t1 {} \then getFieldRet?value \\
      \t1 {} \then stack{<}k{>} := value)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      getfield!stack{<}k{>}!cid!fid \\
      \t1 {} \then getFieldRet?value \\
      \t1 {} \then stack{<}k{>} := value
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[$putField$-$oid$-$value$-elim]{crule}{EliminateOidValuePutField}
  \label{eliminate-oid-value-putField-rule}
  \begin{circus}
    \begin{array}{l}
      (\circvar oid : ObjectID; value : Word \circspot \\
      \t1 value := stack{<}k{>} \circseq \\
      \t1 oid := stack{<}k-1{>} \circseq \\
      \t1 putField!oid!cid!fid!value \\
      \t1 {} \then \Skip)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      putField!stack{<}k-1{>}!cid!fid!stack{<}k{>} \\
      {} \then \Skip
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[$putStatic$-$value$-elim]{crule}{EliminateValuePutStatic}
  \label{eliminate-value-putStatic-rule}
  \begin{circus}
    \begin{array}{l}
      (\circvar value : Word \circspot \\
      \t1 value := stack{<}k{>} \circseq \\
      \t1 putStatic!cid!fid!value \then \Skip)
    \end{array}
    \circrefines_A
    \begin{array}{l}
      putStatic!cid!fid!stack{<}k{>} \then \Skip
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
  \MethodParameterIntroductionRule*
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[$poppedArgs$-sync-elim]{crule}{PoppedArgsSyncElimRule}
  \label{poppedArgs-sync-elim-rule}
  \begin{circus}
    \begin{array}{l}
      (\circvar poppedArgs : \seq Word \circspot \\
      poppedArgs := \langle arg_1, \ldots, arg_n \rangle \circseq \\
      takeLock!(head~methodArgs) \\
      {} \then takeLockRet \then \Skip \circseq \\
      M(poppedArgs~1, \ldots, poppedArgs~n))
    \end{array}
    \circrefines_A
    \begin{array}{l}
      takeLock!arg_1 \\
      {} \then takeLockRet \then \Skip \circseq \\
      M(arg_1, \ldots, arg_n)
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

% not necessary if we don't eliminate the choice for invokevirtual
% \begin{restatable}[$getClassIDOf$-$poppedArgs$-elim]{crule}{GetClassIDOfMethodParameterIntroductionRule}
%   \label{getClassIDOf-method-parameter-introduction-rule}
%   \begin{circus}
%     \begin{array}{l}
%       (\circvar poppedArgs : \seq Word \circspot \\
%       poppedArgs := \langle arg_1, \ldots, arg_n \rangle \circseq \\
%       getClassIDOf!(head~poppedArgs)!cid \\
%       {} \then M(poppedArgs~1, \ldots, poppedArgs~n))
%       % Remember: Poll starts the \cdots
%     \end{array}
%     \circrefines_A
%     \begin{array}{l}
%       getClassIDOf!arg_1!cid \\
%       {} \then M(arg_1, \ldots, arg_n))
%     \end{array}
%   \end{circus}
% \end{restatable}

\begin{minipage}{\textwidth}
\begin{restatable}[invokevirtual-$poppedArgs$-elim]{crule}{GetClassIDOfMultiMethodParameterIntroductionRule}
  \label{getClassIDOf-multi-method-parameter-introduction-rule}
  If, for each $i \in 1 \upto m$, $A_i$ matches
  \begin{circus}
    M_i(poppedArgs~1, \ldots, poppedArgs~n)
  \end{circus}
  or
  \begin{circus}
    takeLock!(head~methodArgs) \then takeLockRet \then \Skip \circseq \\
    M_i(poppedArgs~1, \ldots, poppedArgs~n)
  \end{circus}
  then,
  \begin{circus}
    \begin{array}{l}
      (\circvar poppedArgs : \seq Word \circspot \\
      poppedArgs := \langle arg_1, \ldots, arg_n \rangle \circseq \\
      getClassIDOf!(head~poppedArgs)!cid \then {} \\
      \circif cid = c_1 \circthen A_1 \\
      %\t1 M_1(poppedArgs~1, \ldots, poppedArgs~n) \\
      {} \cdots {} \\
      \circelse cid = c_m \circthen A_m \\
      %\t1 M_m(poppedArgs~1, \ldots, poppedArgs~n) \\
      \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      getClassIDOf!arg_1!cid \then {} \\
      \circif cid = c_1 \circthen instantiateArgs(A_1) \\
      %\t1 M_1(arg_1, \ldots, arg_n) \\
      {} \cdots {} \\
      \circelse cid = c_m \circthen instantiateArgs(A_m) \\
      %\t1 M_m(arg_1, \ldots, arg_n) \\
      \circfi
      % \circif cid = c_1 \circthen {} \\
      % \t1 (\circval var1, \ldots, var{<}n{>} : Word \circspot \\
      % \t1 \circvar var{<}n+1{>}, \ldots, var{<}\ell_1{>}) : Word \circspot \\
      % \t1 \circvar stack1, \ldots, stack{<}s_1{>} : Word \circspot \\
      % \t2 {} \cdots {})(arg_1, \ldots, arg_n)) \\
      % {} \circelse cid = c_m \circthen {} \\
      % \t1 (\circval var1, \ldots, var{<}n{>} : Word \circspot \\
      % \t1 \circvar var{<}n+1{>}, \ldots, var{<}\ell_m{>}) : Word \circspot \\
      % \t1 \circvar stack1, \ldots, stack{<}s_m{>} : Word \circspot \\
      % \t2 {} \cdots {})(arg_1, \ldots, arg_n)) \\
      % {} \cdots {} \\
      % \circfi
    \end{array}
  \end{circus}
  where, for each $i \in 1 \upto m$,
  \begin{circus}
    instantiateArgs(M_i(poppedArgs~1, \ldots, poppedArgs~n)) \\
    {} = {} \\
    instantiateArgs(M_i(arg_1, \ldots, arg_n))
  \end{circus}
  and
  \begin{circus}
    instantiateArgs(takeLock!(head~methodArgs) \then takeLockRet \then \Skip \circseq \\
    \t1 M_i(poppedArgs~1, \ldots, poppedArgs~n)) \\
    {} = {} \\
    instantiateArgs(takeLock!arg_1 \then takeLockRet \then \Skip \circseq \\
    \t1 M_i(arg_1, \ldots, arg_n)) \\
  \end{circus}
\end{restatable}
\end{minipage}

% \begin{restatable}[toplevel-$poppedArgs$-elimination]{crule}{ToplevelMethodParameterIntroductionRule}
%   \label{toplevel-method-parameter-introduction-rule}
%   \begin{circus}
%     \begin{array}{l}
%       (\circvar var1, \ldots, var{<}\ell{>} : Word \circspot \\
%       \circvar stack1, \ldots, stack{<}s{>} : Word \circspot \\
%       var1 := methodArgs~1 \circseq \\
%       \t1 \vdots \\
%       var{<}n{>} := methodArgs~n \circseq \\
%       \t1 {} \cdots {})) \\
%       % Remember: Poll starts the \cdots
%     \end{array}
%     \circrefines_A
%     \begin{array}{l}
%       (\circval var1, \ldots, var{<}n{>} : Word \circspot \\
%       \circvar var{<}n+1{>}, \ldots, var{<}\ell{>}) : Word \circspot \\
%       \circvar stack1, \ldots, stack{<}s{>} : Word \circspot \\
%       \t1 {} \cdots {})(methodArgs~1, \ldots, methodArgs~n) \\
%     \end{array}
%   \end{circus}
% \end{restatable}

\begin{minipage}{\textwidth}
  \VarParameterConversionRule*
\end{minipage}

\begin{algorithm}[H]
  \begin{algorithmic}[1]
     % introduce new method action
     \MatchIn{$%
       \begin{array}[t]{l}
         (\circval var1, \ldots, var{<}n{>} : Word \circspot \\
         \circvar var{<}n+1{>}, \ldots, var{<}\ell{>}) : Word \circspot \\
         \circvar stack1, \ldots, stack{<}s{>} : Word \circspot \\
         \t1 A)(arg_1, \ldots, arg_n)
       \end{array}$
     }{\Call{ActionBody}{$methodName$}}
     \State \ApplyFor{Law~[\nameref{action-intro-law}]}{$methodName'$, $%
       \begin{array}[t]{l}
         (\circval var1, \ldots, var{<}n{>} : Word \circspot \\
         \circvar var{<}n+1{>}, \ldots, var{<}\ell{>}) : Word \circspot \\
         \circvar stack1, \ldots, stack{<}s{>} : Word \circspot \\
         \t1 A)(arg_1, \ldots, arg_n)
       \end{array}$
     }
     % copy out new method action
     \State \ApplyReverseToFor{Law~[\nameref{copy-rule-law}]}{\Call{ActionBody}{$methodName$}}{$methodName'$}
     % expand old method action
     \State \ExhaustivelyApplyFor{Law~[\nameref{copy-rule-law}]}{$methodName$}
     % remove old method method action
     \State \ApplyReverseFor{Law~[\nameref{action-intro-law}]}{$methodName$, \Call{ActionBody}{$methodName$}}
     % rename new method action
     \State \ApplyFor{Law~[\nameref{action-rename-law}]}{$methodName'$, $methodName$}
  \end{algorithmic}
  \caption{RedefineMethodActionToExcludeParameters($methodName$)}
  \label{redefine-method-action-to-exclude-parameters-algorithm}
\end{algorithm}

\begin{minipage}{\textwidth}
  \ArgumentVariableEliminationRule*
\end{minipage}

\section{Data Refinement of Objects}
\label{data-refinement-of-objects-appendix-section}

\begin{minipage}{\textwidth}
  \RefineNewObjectRule*
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[refine-$GetField$]{crule}{RefineGetFieldRule}
  \label{refine-GetField-rule}
  \begin{circus}
    \begin{array}{l}
      \circvar value : Word \circspot \\
      getField?objectID?classID?field \then {}\\
      \circif (objectID \in \dom objects \\ 
      \t1 {} \land (classIDOf~(objects~objectID), classID) \in subclassRel~cs) \circthen {} \\
      \t1 \lschexpract StructManGetField \rschexpract \circseq getFieldRet!value \then \Skip \\
      {} \circelse (objectID \notin \dom objects \\ 
      \t1 {} \lor (classIDOf~(objects~objectID), classID) \notin subclassRel~cs) \circthen \Chaos \\
      \circfi
    \end{array}\\
    \\
    \t2 {} \circrefines_A {} \\
    \\
    \begin{array}{l}
      getField?oid?cid?fid \then {} \\
      \circif oid \in \dom objects \circthen {} \\
      \t1 \circif cid = {<}classID_1{>} \land objects~oid \in \dom cast{<}classID_1{>} \circthen {} \\
      \t2 \circif fid = {<}fieldID_{1,1}{>} \circthen {} \\
      \t3 getFieldRet!((cast{<}classID_1{>}~(objects~oid)).{<}fieldID_{1,1}{>}) \then \Skip \\
      \t3 {} \cdots {} \\
      \t3 {} \circelse fid = {<}fieldID_{1,m_1}{>} \circthen {} \\
      \t3 getFieldRet!((cast{<}classID_1{>}~(objects~oid)).{<}fieldID_{1,m_1}{>}) \then \Skip \\
      \t2 \circfi \\
      \t2 {} \cdots {} \\
      \t1 {} \circelse cid = {<}classID_n{>} \land objects~oid \in \dom cast{<}classID_n{>} \circthen {} \\
      \t2 \circif fid = {<}fieldID_{n,1}{>} \circthen {} \\
      \t3 getFieldRet!((cast{<}classID_n{>}~(objects~oid)).{<}fieldID_{n,1}{>}) \then \Skip \\
      \t3 {} \cdots {} \\
      \t2 {} \circelse fid = {<}fieldID_{n,m_n}{>} \circthen {} \\
      \t3 getFieldRet!((cast{<}classID_n{>}~(objects~oid)).{<}fieldID_{n,m_n}{>}) \then \Skip \\
      \t2 \circfi \\
      \t1 \circfi \\
      {} \circelse oid \notin \dom objects \circthen \Chaos \\
      \circfi
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[refine-$PutField$]{crule}{RefinePutFieldRule}
  \label{refine-PutField-rule}
  \setlength{\zedindent}{0.5cm}
  \setlength{\zedtab}{0.6cm}
  \begin{circus}
    \begin{array}{l}
      putField?objectID?classID?field?value \then {} \\
      \circif (objectID \in \dom objects \\ 
      \t1 {} \land (classIDOf~(objects~objectID), classID) \in subclassRel~cs) \circthen \lschexpract StructManPutField \rschexpract \\
      {} \circelse (objectID \notin \dom objects \\ 
      \t1 {} \lor (classIDOf~(objects~objectID), classID) \notin subclassRel~cs) \circthen \Chaos \\
      \circfi
    \end{array}\\
    \\
    \t2 {} \circrefines_A {} \\
    \\
    \begin{array}{l}
      putField?oid?cid?fid?value \then {} \\
      \circif oid \in \dom objects \circthen {} \\
      \t1 \circif cid = {<}classID_1{>} \land objects~oid \in \dom cast{<}classID_1{>} \circthen {} \\
      \t2 \circif fid = {<}fieldID_{1,1}{>} \circthen {} \\
      \t3 objects := \\
      \t4 objects \oplus \{ oid \mapsto update{<}classID_1{>}\_{<}fieldID_{1,1}{>}~(objects~oid)~value \} \\
      \t3 {} \cdots {} \\
      \t2 {} \circelse fid = {<}fieldID_{1,m_1}{>} \circthen {} \\
      \t3 objects := \\
      \t4 objects \oplus \{ oid \mapsto update{<}classID_1{>}\_{<}fieldID_{1,m_1}{>}~(objects~oid)~value \} \\
      \t2 \circfi \\
      \t2 {} \cdots {} \\
      \t1 {} \circelse cid = {<}classID_n{>} \land objects~oid \in \dom cast{<}classID_n{>}\circthen {} \\
      \t2 \circif fid = {<}fieldID_{n,1}{>} \circthen {} \\
      \t3 objects := \\
      \t4 objects \oplus \{ oid \mapsto update{<}classID_n{>}\_{<}fieldID_{n,1}{>}~(objects~oid)~value \} \\
      \t3 {} \cdots {} \\
      \t2 {} \circelse fid = {<}fieldID_{n,m_n}{>} \circthen {} \\
      \t3 objects := \\
      \t4 objects \oplus \{ oid \mapsto update{<}classID_n{>}\_{<}fieldID_{n,m_n}{>}~(objects~oid)~value \} \\
      \t2 \circfi \\
      \t1 \circfi \\
      {} \circelse oid \notin \dom objects \circthen \Chaos \\
      \circfi
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[refine-$GetStatic$]{crule}{RefineGetStaticRule}
  \label{refine-GetStatic-rule}
  \setlength{\zedindent}{0.5cm}
  \begin{circus}
    \begin{array}{l}
      getStatic?cid?fid \then {} \\
      \circif (cid,fid) \in \dom staticClassFields \circthen {} \\
      \t2 \circvar value : Word \circspot \lschexpract ObjManGetStatic \rschexpract \circseq \\
      \t2 getStaticRet!value \then \Skip \\
      {} \circelse (cid,fid) \notin \dom staticClassFields \circthen \Chaos \\
      \circfi
    \end{array}\\
    \\
    \t2 {} \circrefines_A {} \\
    \\
    \begin{array}{l}
      getStatic?cid?fid \then {} \\
      \circif cid = {<}classID_1{>} \land fid = {<}staticFieldID_{1,1}{>} \circthen {} \\
      \t1 getStaticRet!(staticClassFields.{<}classID_1{>}\_{<}staticFieldID_{1,1}{>}) \then \Skip \\
      \t1 {} \cdots {} \\
      {} \circelse cid = {<}classID_1{>} \land fid = {<}staticFieldID_{1,\ell_1}{>} \circthen {} \\
      \t1 getStaticRet!(staticClassFields.{<}classID_1{>}\_{<}staticFieldID_{1,\ell_1}{>}) \then \Skip \\
      \t1 {} \cdots {} \\
      {} \circelse cid = {<}classID_n{>} \land fid = {<}staticFieldID_{n,1}{>} \circthen {} \\
      \t1 getStaticRet!(staticClassFields.{<}classID_n{>}\_{<}staticFieldID_{n,1}{>}) \then \Skip \\
      \t1 {} \cdots {} \\
      {} \circelse cid = {<}classID_n{>} \land fid = {<}staticFieldID_{n,\ell_n}{>} \circthen {} \\
      \t1 getStaticRet!(staticClassFields.{<}classID_n{>}\_{<}staticFieldID_{n,\ell_n}{>}) \then \Skip \\
      \circfi
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[refine-$PutStatic$]{crule}{RefinePutStaticRule}
  \label{refine-PutStatic-rule}
  \setlength{\zedindent}{0.5cm}
  \setlength{\zedtab}{0.55cm}
  \begin{circus}
    \begin{array}{l}
      putStatic?cid?fid?value \then {} \\
      \circif (cid,fid) \in \dom staticClassFields \circthen \lschexpract StructManPutStatic \rschexpract \\
      {} \circelse (cid,fid) \in \dom staticClassFields \circthen \Chaos \\
      \circfi
    \end{array}\\
    \\
    \t2 {} \circrefines_A {} \\
    \\
    \begin{array}{l}
      putStatic?cid?fid?value \then {} \\
      \circvar staticFieldsID : ObjectID; staticFields : StaticFields \circspot \\
      staticFieldsID := (Initialised\inv)~staticClassFieldsID \circseq \\
      staticFields := staticClassFields~staticFieldsID \circseq \\
      \circif cid = {<}classID_1{>} \land fid = {<}staticFieldID_{1,1}{>} \circthen {} \\
      \t1 staticClassFields := staticClassFields \oplus {} \\
      \t2 \{ staticFieldsID \mapsto updateStatic{<}classID_1{>}\_{<}staticFieldID_{1,1}{>}~staticFields~value \} \\
      \t1 {} \cdots {} \\
      {} \circelse cid = {<}classID_1{>} \land fid = {<}staticFieldID_{1,\ell_1}{>} \circthen {} \\
      \t1 staticClassFields := staticClassFields \oplus {} \\
      \t2 \{ staticFieldsID \mapsto updateStatic{<}classID_1{>}\_{<}staticFieldID_{1,\ell_1}{>}~staticFields~value \} \\
      \t1 {} \cdots {} \\
      {} \circelse cid = {<}classID_n{>} \land fid = {<}staticFieldID_{n,1}{>} \circthen {} \\
      \t1 staticClassFields := staticClassFields \oplus {} \\
      \t2 \{ staticFieldsID \mapsto updateStatic{<}classID_n{>}\_{<}staticFieldID_{n,1}{>}~staticFields~value \} \\
      \t1 {} \cdots {} \\
      {} \circelse cid = {<}classID_n{>} \land fid = {<}staticFieldID_{n,\ell_n}{>} \circthen {} \\
      \t1 staticClassFields := staticClassFields \oplus {} \\
      \t2 \{ staticFieldsID \mapsto updateStatic{<}classID_n{>}\_{<}staticFieldID_{n,\ell_n}{>}~staticFields~value \} \\
      \circfi
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\section{Algebraic Laws Used in the Compilation Strategy}
\label{compilation-strategy-algebraic-laws-section}

\begin{minipage}{\textwidth}
\begin{restatable}[action-intro]{law}{ActionIntroLaw}
  \label{action-intro-law}
  Given an action name $N$ and action body $B$, if $N$ is not
  referenced in the body of $P$ then,
  \begin{circus}
    \begin{array}{l}
      \circprocess P \circdef \circbegin \\
      \t1 {} \cdots {} \\
      \t1 \circstate S \\
      \t1 {} \cdots {} \\
      \t1 \circspot A \\
      \t1 \circend
    \end{array}
    =
    \begin{array}{l}
      \circprocess P \circdef \circbegin \\
      \t1 {} \cdots {} \\
      \t1 \circstate S \\
      \t1 {} \cdots {} \\
      \t1 N \circdef B \\
      \t1 {} \cdots {} \\
      \t1 \circspot A \\
      \t1 \circend
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[action-rename]{law}{ActionRenameLaw}
  \label{action-rename-law}
  Given action names $M$ and $N$, if $N$ is not referenced in the body
  of $P$ then,
  \begin{circus}
    \begin{array}{l}
      \circprocess P \circdef \circbegin \\
      \t1 {} \cdots {} \\
      \t1 \circstate S \\
      \t1 {} \cdots {} \\
      \t1 M \circdef B \\
      \t1 {} \cdots {} \\
      \t1 PPars \\
      \t1 {} \cdots {} \\
      \t1 \circspot A \\
      \t1 \circend
    \end{array}
    =
    \begin{array}{l}
      \circprocess P \circdef \circbegin \\
      \t1 {} \cdots {} \\
      \t1 \circstate S \\
      \t1 {} \cdots {} \\
      \t1 N \circdef B \\
      \t1 {} \cdots {} \\
      \t1 PPars[N/M] \\
      \t1 {} \cdots {} \\
      \t1 \circspot A[N/M] \\
      \t1 \circend
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[assump-elim]{law}{AssumpElimLaw}
  \label{assump-elim-law}
  \begin{circus}
    \{g\} \circrefines_A \Skip
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[copy-rule]{law}{CopyRuleLaw}
  \label{copy-rule-law}
  Give an action name $N$, if $N$ names an action in the current process then,
  \begin{circus}
    N(e) = B(N)(e)
  \end{circus}
  where $B$ is a function that returns the body of an action given its
  name.
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
  \begin{restatable}[forwards-data-refinement]{law}{ForwardsDataRefinementLaw}
    \label{forwards-data-refinement-law}
    Given a new process state $S_2$ and a relation $CI$, if $CI$
    relates a process state $S_1$ to $S_2$, with action local state
    $L$, and, for actions $A_1$ and $A_2$,
  \begin{circus}
    \forall S_2; L @ (\exists S_1 @ CI),
  \end{circus}
  and
  \begin{circus}
    \forall S_1; S_2; S_2'; L @ CI \land A_2 \implies (\exists S_1'; L' @ A_1 \land CI' ),
  \end{circus}
  then,
  \begin{circus}
    \begin{array}{l}
      \circprocess P1 \circdef \circbegin \\
      \t1 {} \cdots {} \\
      \t1 \circstate S_1 \\
      \t1 {} \cdots {} \\
      \t1 \circspot A_1 \\
      \t1 \circend
    \end{array}
    \circrefines_P
    \begin{array}{l}
      \circprocess P_2 \circdef \circbegin \\
      \t1 {} \cdots {} \\
      \t1 \circstate S_2 \\
      \t1 {} \cdots {} \\
      \t1 \circspot A_2 \\
      \t1 \circend
    \end{array}
  \end{circus}
  where $A_2$ is such that $A_1 \circsimulates A_2$
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[process-param-elim]{law}{ProcessParamElimLaw}
  \label{process-param-elim-law}
  If $x$ is not referenced in the body of $P$, then
  \begin{circus}
    \begin{array}{l}
      \circprocess P \circdef x : T \circspot \circbegin \\
      \t1 {} \cdots {} \\
      \t1 \circstate S \\
      \t1 {} \cdots {} \\
      \t1 \circspot A \\
      \t1 \circend
    \end{array}
    =
    \begin{array}{l}
      \circprocess P \circdef \circbegin \\
      \t1 {} \cdots {} \\
      \t1 \circstate S \\
      \t1 {} \cdots {} \\
      \t1 \circspot A \\
      \t1 \circend
    \end{array}
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[rec-action-intro]{law}{RecActionIntroLaw}
  \label{rec-action-intro-law}
  Given an action $B$,
  \begin{circus}
    (\circmu X \circspot A \circseq X) \circrefines_A (\circmu X \circspot A \circseq X) \circseq B
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[rec-rolling-rule]{law}{RecRollingRuleLaw}
  \label{rec-rolling-rule-law}
  Given action functions $F$ and $G$,
  \begin{circus}
    (\circmu X \circspot F(G(X))) = F(\circmu X \circspot G(F(X)))
  \end{circus}
\end{restatable}
\end{minipage}

\begin{minipage}{\textwidth}
\begin{restatable}[seq-unitl]{law}{SeqUnitlLaw}
  \label{seq-unitl-law}
  \begin{circus}
    \Skip \circseq A = A
  \end{circus}
\end{restatable}
\end{minipage}
\chapter{The Core Execution Environment}
\label{cee-chapter}

This chapter describes the core execution environment (CEE) of an
SCJVM, which handles execution of an SCJ program.
% The CEE is aware of the structure of Java objects and classes in order
% to handle bytecode instructions properly.
In addition, the CEE of an SCJVM manages the flow of execution
dictated by the SCJ programming model, including, for example,
\texttt{Safelet} setup and mission execution.

This is the part of our SCJVM model that is handled by our compilation
strategy. 
So, it may take the form of a bytecode interpreter, which is the
starting point for the compilation, or C code, which is the output of
the compilation.
We describe both of these in this chapter
(Sections~\ref{cee-launcher-section}, \ref{cee-interpreter-section}
and~\ref{cee-c-code-section}) while the compilation strategy for
transforming between them is described in the next chapter.
We begin with an overview of the CEE's structure in the next section.
We conclude with some final considerations in
Section~\ref{cee-final-considerations-section}.

\section{Overview}

The core execution environment has three components, two of which
depend on whether it is interpreting bytecodes or executing C code. 
For a bytecode interpreter, the components are those shown in
Figure~\ref{cee-fig}:
\begin{itemize}
\item the object manager, which manages information about objects
  created during execution of the bytecode,
\item the interpreter itself, which handles execution of bytecode
  instructions, and
\item the launcher, which coordinates the startup of the SCJVM, the
  execution of missions, and the execution of methods in the
  interpreter.
\end{itemize}
% The interpreter is central to the main functionality of the core
% execution environment, but proper handling of infrastructure methods
% requires handling the SCJ mission-based programming model, which is
% dealt with by the launcher.
% The interpreter requires access to memory, but the class information
% and bytecode instructions do not change throughout the execution of
% the SCJVM, so they are provided as global constants in our model that
% are passed to the interpreter as parameters.
% Objects do change throughout the execution of the SCJVM and are in a
% separate region of memory to classes and bytecode instructions.
% The management of objects is handled by the object manager component
% of the core execution environment.

\begin{figure}[bth]
  \centering
  \begin{tikzpicture}

    \coordinate (width)  at (10cm,0cm);
    \coordinate (height) at (0cm,6cm);

    \path (0,0) -- (height)
    coordinate[pos=0.18] (OS boundary)
    coordinate[pos=0.20] (VM part bottom)
    coordinate[pos=0.57] (VM part top)
    coordinate[pos=0.60] (API boundary)
    coordinate[pos=0.82] (App boundary);
    
    \path (VM part bottom) -- (VM part top)
    coordinate[pos=0.7] (CEE part top);

    \path (VM part bottom) -- (VM part top)
    coordinate[pos=0.85] (CEE ypos);

    \path (0,0) -- (width)
    coordinate[pos=0.04] (CEE left)
    coordinate[pos=0.76] (CEE right)
    coordinate[pos=0.78] (VM Services left)
    coordinate[pos=0.96] (VM Services right)
    coordinate[pos=0.01] (CEE part sep);

    \path (CEE left) -- (CEE right)
    coordinate[pos=0.5] (CEE xpos);

    \path (0,0) to node[pos=0.5] (mid) {} (width);
    \path (0,0) to node[pos=0.25] (quart) {} (width);

    \draw (0,0) rectangle (width |- height);

    \draw (OS boundary) -- ++(width);
    \path (0,0) rectangle node[pos=0.5] (OS) {} (width |- OS boundary);
    \draw (mid |- API boundary) rectangle node[pos=0.5] (API) {} (width |- App boundary);
    \draw (App boundary) -- ++(width);
    \path (App boundary) rectangle node[pos=0.5] (App) {} (width |- height);

    \path (quart |- API boundary) rectangle node[pos=0.4] (SCJVM) {} (quart |- App boundary);
    \draw (CEE left |- VM part bottom) rectangle (CEE right |- VM part top);
    \draw (VM Services left |- VM part bottom) rectangle node[pos=0.5] (VM Services) {} (VM Services right |- VM part top);
    \coordinate (CEE) at (CEE xpos |- CEE ypos);

    \node[align=center] at (App)   {SCJ Application};
    \node[align=center] at (API)   {SCJ\\Infrastructure\\and API};
    \node[align=center] at (SCJVM) {SCJ\\Virtual Machine};
    \node[align=center] at (CEE)   {Core Execution Environment};
    \node[align=center] at (VM Services)  {SCJVM\\Services};
    \node[align=center] at (OS)    {Operating System/Hardware Abstraction Layer};

    \foreach \x in {1,...,3}
    \pgfmathsetmacro{\a}{0.33*(\x - 1)}
    \pgfmathsetmacro{\b}{0.33*\x}
    \path ($(CEE left) + (VM part bottom)!0.07!(VM part top)$) -- 
    node[pos=\a] (CEE part \x start) {}
    node[pos=\b] (CEE part \x end) {}
    ($(CEE right) + (VM part bottom)!0.07!(VM part top) - (CEE part sep)$);

    \foreach \x in {1,...,3} 
    \draw ($(CEE part \x start) + (CEE part sep)$)
    rectangle node[pos=0.5] (CEE part \x) {}
    (CEE part \x end |- CEE part top);
    
    \node[align=center] at (CEE part 1) {\small Object \\ \small Manager};
    \node[align=center] at (CEE part 2) {\small Interpreter};
    \node[align=center] at (CEE part 3) {\small Launcher};
  \end{tikzpicture}
  \caption{Structure of an SCJVM, showing the components of the CEE,
    and its relation to the SCJ infrastructure and the operating
    system/hardware abstraction layer}
  \label{cee-fig}
\end{figure}

The components after compilation to C are similar, but the object
manager is replaced with a struct manager, which manages C struct
types representing objects, and the interpreter is replaced with the C
program itself.
The launcher remains unchanged throughout the compilation.
It is assumed that it is already in the form of native code that can
be called from the C code.

The CEE is combined with the SCJVM services to form the complete
SCJVM; this can be seen in Figure~\ref{cee-fig}, which shows the same
structure described in Figure~\ref{scjvm-services-fig} in the previous
chapter, but has a focus on the CEE components.
The SCJVM services are unaffected by the compilation strategy and can
be implemented as a separate library.

Each of the components of the CEE is represented by a single \Circus{}
process in our model.
The structure of the communication between the processes before
compilation is show in Figure~\ref{cee-model-fig}.
The communication is unaffected by the compilation.

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}
    \node[draw, minimum size=2cm, below right=2cm, align=center]
    (M) {Object\\Manager};
    \node[draw, minimum size=2cm, below=2cm]
    (I) {Interpreter};
    \node[draw, minimum size=2cm, right=2cm]
    (L) {Launcher};

    \draw[-latex, bend left=10] (I) edge (L);
    \draw[-latex, bend left=10] (L) edge (I);
    \draw[-latex] (I) edge (M);
    \draw[-latex] (L) edge (M);
    

    \node[below=1.5cm, right=4.5cm] (MM) {Memory Manager};
    \node[] (S) {Scheduler};
    \draw[-latex] (M) edge (MM);
    \draw (L) edge[-latex] (S);
    \draw (S) edge[-latex, bend left=20] (I);
    \draw (I) edge[-latex, bend left=20] (S);
    \draw (L) edge[-latex] (MM);

    \node[below=2.5cm, left=2cm] (In) {Input};
    \node[below=3.5cm, left=2cm] (Out) {Output};
    \draw[-latex] (In) to (I.153);
    \draw[-latex] (I.207) to (Out);
  \end{tikzpicture}
  \caption{The CEE model processes and their communication with each
    other and the SCJVM services}
  \label{cee-model-fig}
\end{figure}

The launcher manages the startup procedure for the SCJVM and the
execution of missions.
This involves communication with the interpreter to execute
initialisation methods.
The interpreter then communicates back to perform tasks such as
registering a schedulable object with the current mission.
Allocation of backing stores for the schedulable objects and entering
the corresponding memory areas involves communication with both the
object manager in the CEE and the memory manager of the SCJVM
services.
The launcher must also communicate with the scheduler to indicate when
threads should be started or suspended during mission execution.

The interpreter must accept the requests to execute methods on the
main thread from the launcher, and it must also respond to requests
from the scheduler to start the other threads.
When a thread has finished execution, the interpreter signals to the
scheduler that the thread has finished so that it will no longer be
scheduled.
The interpreter must also communicate with the launcher to handle
calls to methods that affect the SCJ infrastructure, such as the
methods to enter memory areas.
Handling of memory allocation during method execution is performed via
communication with the object manager, which then communicates with
the SCJVM memory manager, since memory allocation does not depend on
the structure of missions.
Additionally, the interpreter communicates input and output to some
console input/output device, which is the only such device required by
the SCJ specification.
Supporting a full range of hardware connections is beyond the scope of
this work.

Having described the overall communication structure, we now present
the channels used for these communications.
The communications with the SCJVM services scheduler and memory
manager use the channels already described in
Sections~\ref{memory-manager-model-section}
and~\ref{scheduler-model-section}.
The types of values communicated by those channels are also used by
the CEE processes.
These include the type of object identifiers, $ObjectID$, the type of
thread identifiers, $ThreadID$, the type of backing store identifiers,
$BackingStoreID$, and the type of virtual machine data words, $Word$.
We also use the $ClassID$ and $MethodID$ types, which are the types of
class and method identifiers that were declared in the scheduler model
to provide for the declaration of the $CEEstartThread$ channel.
Additionally, we declare a field identifier type, $FieldID$.
\begin{zed}
  [FieldID]
\end{zed}
The class, method and field identifiers may be the full names used in
Java class files or some shorter representation such as unique
identification numbers.
In any case, type information needs to be taken into account so that
methods and fields with the same name but different type signatures
have different identifiers.
This is because the identifiers in Java class files include the type
information and the correct operation of method overloading relies on
it.

\input{../../SCJ-VM/James/LIchans.zed}

\input{../../SCJ-VM/James/memory_chans.zed}

In Section~\ref{cee-launcher-section}, we describe our model of the
launcher, which is shared between the bytecode interpreter model and
the C code model.
We then detail the bytecode interpreter model in
Section~\ref{cee-interpreter-section}, and the C code model in
Section~\ref{cee-c-code-section}.
Finally, we conclude in
Section~\ref{cee-final-considerations-section}.

\section{Launcher}
\label{cee-launcher-section}

The launcher is the component of the core execution environment that
manages parts of the SCJ infrastructure such as the safelet and
mission model.


\input{../../SCJ-VM/James/launcher.zed}

\section{Bytecode Interpreter Model}
\label{cee-interpreter-section}

% This chapter begins in Section~\ref{cee-assumptions-section} with an
% explanation of the bytecode subset used in our work.
% Afterwards, each part of the \Circus{} model of the core execution
% environment is presented in a separate section.
% The object manager, along with the structure of objects, is
% described in Section~\ref{cee-memory-section}.
% The interpreter is described by first describing the stack frame
% structure in Section~\ref{cee-stack-frames-section}, then the
% interpreter itself is presented in
% Section~\ref{cee-interpreter-section}.
% The launcher is presented in Section~\ref{cee-launcher-section}.
% Finally the parts are drawn together into the complete model in
% Section~\ref{complete-cee-section}. 
% A full version of the CEE model can be found in
% Appendix~\ref{full-cee-model}.

\subsection{Bytecode Subset}
\label{cee-assumptions-subsection}

Due to the complexity of the JVM and Java bytecode, we model a subset
of Java bytecode.
It is sufficient to express a wide variety of SCJ programs and
illustrate how further features may be added, but small enough to
permit effective reasoning.
The subset has been chosen by considering the bytecode generated from
a minimal SCJ program and removing instructions similar to those
already in the subset.
This ensures the model is not unnecessarily complicated with trivial
or redundant instructions, so we can concentrate on the instructions
that are most of interest in creating the compilation strategy.

The bytecode instructions in our subset are described in
Table~\ref{bytecode-subset-table}.
Java bytecode instructions operate over a state that records
information on all loaded classes, a stack frame, and the object data
residing in memory.
Various pieces of class information are required for execution of
bytecode instructions, but a constant pool, which stores all the
constants and names required by the class, is the main information
used.
The constant pool contains references to classes, methods and fields
used by the bytecode instructions in the class, as well as constant
values used in the code.
The form of the constant pool is a large array.
Indices into this array are used as parameters to instructions
requiring information from the constant pool.
For example, the \texttt{getfield} and \texttt{putfield} instructions
take constant pool index parameters pointing to a reference to a field
whose value should be obtained or set.
Other class information used at runtime includes information on fields
and methods belonging to the class, which is required for creation of
objects and invocation of methods.

\begin{table}
  \centering
  \begin{tabular}{llp{8cm}}
    \hline
    Instruction & Parameter & Description \\
    \hline
    \texttt{aconst\_null} & (none) & 
    Pushes a null object reference onto the operand stack.
    \\
    \texttt{aload} & local variable index &
    Loads the value from a specified local variable and pushes it
    onto the operand stack.
    \\
    \texttt{areturn} & (none) &
    Returns from the current method, pushing the value on top of the
    current method's operand stack onto the operand stack of the
    method returned to.
    \\
    \texttt{astore} & local variable index &
    Pops a value from the operand stack and stores it in the specified
    local variable.
    \\
    \texttt{dup} & (none) &
    Duplicates the value on top of the operand stack.
    \\
    \texttt{getfield} & constant pool index &
    Pops an object reference from the operand stack, gets the value of
    the field specified by the identifier at the given constant pool
    index for the referenced object, and pushes it onto the operand
    stack.
    \\
    \texttt{iadd} & (none) &
    Pops two integer values from the operand stack, adds them, and
    pushes the result back onto the operand stack.
    \\
    \texttt{iconst} & integer value &
    Pushes the given integer value onto the operand stack of the
    current method.
    \\
    \texttt{ineg} & (none) &
    Pops an integer value from the operand stack, negates it, and
    pushes the negated value onto the operand stack.
    \\
    \texttt{invokespecial} & constant pool index &
    Gets the method and class identifier at the given constant pool
    index and invokes the specified method of the specified class,
    popping the method's arguments, including a \texttt{this} object
    reference, from the operand stack.
    \\
    \texttt{invokevirtual} & constant pool index &
    Gets the method and class identifier at the given constant pool
    index, pops the arguments of the specified method, including a
    \texttt{this} object reference, from the operand stack, and
    invokes the specified method of the class of referenced object.
    \\
    \texttt{new} & constant pool index &
    Allocates a new object of the class specified by the identifier at
    the given constant pool index and pushes a reference to the new
    object onto the operand stack.
    \\
    \texttt{putfield} & constant pool index &
    Pops an object reference and value from the operand stack and
    stores the value in the field specified by the identifier at the
    given constant pool index for the referenced object.
    \\
    \texttt{return} & (none) &
    Returns from a method with no return value.
    \\
    \hline
  \end{tabular}
  \caption{The instructions in our bytecode subset}
  \label{bytecode-subset-table}
\end{table}

The frame stack forms the second part of the JVM manipulated by
bytecode instructions and consists of a series of frames that contain
the runtime information for each invocation of a method.
When a method is invoked, a new stack frame is created for it and
pushed onto the frame stack, and when the method returns, the stack
frame is popped from the stack.
Each stack frame contains an operand stack, which is used to store
values manipulated by bytecode instructions, and an array of local
variables.
Most bytecode instructions manipulate the operand stack in some way,
popping arguments from it, pushing results to it or performing
specific operations upon it (such as in the case of the \texttt{dup}
instruction, which duplicates the value on top of the operand stack).
The local variables are used to store the arguments of a method and
the results of computations performed on the operand stack.
Operations are not performed directly on the local variables, so the
only bytecode instructions that affect them are those for moving
values between the operand stack and the local variables
(\texttt{aload} and \texttt{astore} are examples of such
instructions).

Some bytecode instructions also manipulate objects, which in our case
reside in backing store memory.
Such instructions include \texttt{new}, which creates objects, and
\texttt{getfield}, which gets the value from a field of an object.

In our choice of instructions for the subset, we mainly focus on
manipulation of objects and method invocation, since those are core
concepts of Java bytecode and require special handling by the
compilation strategy.

The instruction \texttt{dup} is included as an example of a simple
instruction that operates on the operand stack.
It has been chosen for its frequent occurrence in object initialisation.
Other instructions that do simple operand stack manipulation,
including the arithmetic instructions, can be specified similarly.

Instructions that create object references and pass them around are
also included to allow the full range of object manipulations.
However, arrays are not included as they require additional
instructions and can be emulated, albeit inefficiently, with the
instructions given here.

Both the \texttt{invokevirtual} and \texttt{invokespecial}
instructions, which invoke methods on objects, are included.
The \texttt{invokevirtual} instruction looks up the method to invoke
in the method table for the class of the object that the method is
invoked on.
The \texttt{invokespecial} method, on the other hand, uses the class
identifier supplied in the method reference pointed to by the
parameter of the instruction when looking up the method.

We do not handle exceptions; errors in the SCJVM are instead handled
by simply aborting execution.
While the exception handling mechanism of Java is quite complex, the
correct application of formal methods should eliminate errors in the
SCJVM.
The bytecode instructions that relate to throwing and catching
exceptions are, therefore, not included in our bytecode subset.

As a simplifying assumption, we consider that all values consist of
only a single virtual machine word.
This means that \texttt{long} and \texttt{double} values are not
handled.
Any SCJ API methods that take \texttt{long} or \texttt{double}
arguments are viewed as taking \texttt{int} or \texttt{float} instead.
The reason for this assumption is that handling of two word values
complicates many bytecode instructions while adding little to the
power of the bytecode subset.
This makes little difference at the level of the formal model and our
approach can be easily extended to deal with more types.

Further, we do not make a distinction between the different virtual
machine types in our bytecode instructions.
This is justified as the bytecode instructions simply handle values as
32-bit words, with the type information only used for typechecking
during bytecode validation, which the code passed into the core
execution environment can be assumed to have already passed (it may be
done by a separate component, which can be made safe using existing
work on bytecode validation~\cite{klein2003, stark2001, coglio2000,
  xavier2003}). 
Instead, we include instructions that handle values as object
references, since many of the instructions behave the same for
different types.
We would introduce a lot of duplication in the model if, for example,
both the \texttt{areturn} and \texttt{ireturn} instructions were to be
included.

We also include a few arithmetic instructions as an example of how
integers would be handled.
Specifically, we include the integer addition operation,
\texttt{iadd}, as an example of a binary operation, and the integer
negation operation, \texttt{ineg}, as an example of an unary
operation.
We do not include operations for floating point values since the
operations upon them are not substantially different from those on
integers at the level of modelling and compilation.
The model can be easily extended to include more integer operations.

We also do not consider static methods and fields.
That would add some complexity to our model and most of the
considerations are covered by non-static methods and fields.

Because we are considering bytecode arising from an SCJ program, some
requirements of SCJ permit further simplifications to our bytecode
subset.
The \texttt{invokedynamic} instruction performs method invocation with
runtime typechecking, mainly for the purpose of implementing
dynamically-typed languages targeting the JVM (though it is also used
to implement the lambda expressions introduced in Java 8).
It is not included in our subset as it does not allow static
typechecking and so should not be used for SCJ.

The requirement for all classes to be loaded at startup greatly
simplifies the semantics of several instructions since dynamic class
loading does not need to be considered.
It also means that method lookup tables can be precomputed, which
simplifies method lookup.
This means that the semantics of the \texttt{invokevirtual} and
\texttt{invokeinterface} instructions are the same, since they both
invoke a method on an object, using the object's class as the class
for method lookup.
They, therefore, do not both need to be included and so we have not
included the \texttt{invokeinterface} instruction, since it exists
only to optimise method lookup.

In terms of concurrency considerations, we are assuming our SCJVM to
be single processor, and so we do not need to have more than one
interpreter.
We also assume that thread switches can only occur between bytecode
instructions in the interpreter.
This is justified since bytecode instructions should be atomic.
Execution occurring in other parts of the core execution environment
can also be made atomic via disabling of interrupts.
This is advisable since such execution often involves manipulation of
shared state.

We also do not consider the SCJ mission termination protocol since it
is complex and is not relevant to the central focus of the model,
which is the handling of bytecode instructions.

Having described our bytecode subset and the assumptions we are
making, we now present our model of the core execution environment,
beginning with an explanation of the class structure in the next
section.

\subsection{Classes}
\label{cee-classes-subsection}

This section discusses the representation in our model of the
information in Java class files.
We identify the information that is relevant to our bytecode subset
and present a Z schema to represent the class information needed by
the SCJVM at runtime.
The class type is used in the definition of the class information that
is passed to the object manager and the interpreter.

\input{../../SCJ-VM/James/classes.zed}

\subsection{Object Manager}
\label{cee-memory-subsection}

The SCJVM memory manager deals with memory solely in terms of sets of
memory addresses, meaning that it the core execution environment needs
to manage objects itself.
As objects are used throughout the core execution environment, in both
the interpreter and launcher, the management of objects is handled in
a separate \Circus{} process, which is described in this section.

\input{../../SCJ-VM/James/memory.zed}

\subsection{Stack Frames}
\label{cee-stack-frames-subsection}

The JVM has a stack composed of a series of stack frames, which
contain information about the invoked methods.
The representation of stack frames is described in this section as
stack frames are, like classes, a large data type of interest as a
significant part of the JVM state.
The stack frames are used to form the frame stack used by the
interpreter in the next section.

\input{../../SCJ-VM/James/stack_frames.zed}

\subsection{Interpreter}
\label{cee-interpreter-subsection}

The interpreter manages the execution of the bytecode instructions of
methods.
This includes handling the frame stack and program counter, as well as
processing the bytecode instructions themselves according to their
semantics.
The interpreter must also handle thread switches, maintaining an
interpreter state for each thread, since thread switches may occur
between bytecode instructions.

\input{../../SCJ-VM/James/interpreter_thread.zed}

\input{../../SCJ-VM/James/interpreter.zed}

\subsection{Complete Core Execution Environment Model}
\label{complete-cee-subsection}

We now combine the four \Circus{} processes representing the different
components of the core execution environment into a single \Circus{}
process representing the entire core execution environment.

\input{../../SCJ-VM/James/complete_cee.zed}

\section{C Code Model}
\label{cee-c-code-section}

\subsection{Struct Manager}

$StructMan_{cs}$ manages objects represented by C structs that
incorporate the class information from $cs$, refining the process
$ObjMan$, which handles abstract objects.
$StructMan_{cs}$ has Z schemas representing struct types for objects
of each class.
%
% \begin{zed}
%   InputHandlerObj == [classid : ClassID; input, buffer : ObjectID]
% \end{zed}
%
These schemas contain the identifier $classid$ of the object's class, so
that polymorphic method calls can be made by choice over the object's
class. 
There are also components for each of the fields of the
object.

The schema types for each type of object are combined into a single
free type $ObjectStruct$.
% \begin{zed}
%   ObjectStruct ::= \dots | InputHandlerCon \ldata InputHandlerObj \rdata \dots
% \end{zed}
% We also define functions for casting between objects of different
% classes and for obtaining the class identifier of any object. 
% This matches the casting of object pointers in the C code that the
% icecap HVM generates.
$StructMan_{cs}$ contains a map from memory addresses managed by the
SCJVM to the $ObjectStruct$ type, representing the C structs in
memory, and provides access to the individual values in that map.

\subsection{Shallow Embedding of C in \Circus{}}

In our approach, compilation generates a C program represented by a
\Circus{} process.
The particular definition of this process depends on the Java bytecode
program, as defined by our constants $bc$ and $cs$, that it
implements. 
So, we refer to the \Circus{} process as $CProg_{bc,cs}$, but note
that it does not include any reference to these constants, since this
is the process that represents the compiled program. 
For all values of $bc$ and $cs$, $CProg_{bc,cs}$ has the structure
defined below. 
% For particular constants $bc$ and $cs$ defining bytecode and classes,
% we refer to that process as $CProg_{bc,cs}$. 
% Its definition depends on the values of $bc$ and $cs$, as indicated by
% the subscripts, but it always has the structure shown below.
\begin{circus}
  \circprocess CProg_{bc,cs} \circdef \Parallel t : TID \setminus \{idle\} \circspot CThr_{bc,cs}(t)
\end{circus}
% In a deep embedding we would use a representation of the program
% counter to handle thread switches. 
% A shallow embedding does not have an explicit program counter, and so
% it is natural to use parallel processes to represent C threads.
The parallelism of C threads is represented by a \Circus{}
parallelism, like the parallelism of Java threads in the
$Interpreter$.
In $CProg_{bc,cs}$ there is a process $CThr_{bc,cs}$ for each
identifier $t$ in the set $TID$, except for the $idle$ thread
identifier.
% We abbreviate the set of thread identifiers excluding $main$ and
% $idle$ as $TID_{\setminus\{i,m\}}$ here and in what follows. 
% For simplicity, the definition of $TID$ does not depend on $bc$ and
% $cs$; we assume that it has enough thread identifiers for any program.

% TODO: rewrite to reflect changes to CThr $CThr_{bc,cs}$ represents a
% thread that initially has not started and awaits a request from the
% scheduler to start running a method.
% The $main$ thread has a special behaviour at program startup, and is
% modelled by $MCThr_{bc,cs}$, which is initially ready to run a
% method at the request of $Launcher$.
% The $idle$ thread, modelled by $IThr$, does not execute any code.
% but may be switched to and from.
% so it is modelled by a special process $IThr$ that only accepts a
% request to switch to the $idle$ thread followed by a request to
% switch from the $idle$ thread.
% $MCThr_{bc,cs}$ must synchronise with the $CThr_{bc,cs}$ processes
% on thread starts, signalled by the channel $CEEstartthread$, so that
% it can cease executing methods once the first thread starts.

The $CThr_{bc,cs}$ process has a similar structure to the $Thr$
process presented in the previous section, except that the $Running$
action is replaced with an $ExecuteMethod$ action that executes the C
function corresponding to a given method identifier.
Within the body of $CThr_{bc,cs}$, each function of the generated C
code is represented by a \Circus{} action of the same name.
The constructs within the C function are represented using \Circus{}
constructs.

The constructs we allow within a C function are conditionals, while
loops, assignment statements, and function calls.
These are comparable with those allowed in MISRA-C~\cite{MISRA} and
present in the code generated by icecap.
These constructs can be represented by the corresponding constructs in
\Circus{}.
% For example, assignment statements are represented by \Circus{}
% assignment actions, and conditionals are represented using \Circus{}
% conditional constructs.
% Loops are represented using recursion.

As each function in the C code is a \Circus{} action, function calls
are represented as references to those actions.
Function arguments in C are passed by value, although those values may
be pointers to other values.
Accordingly, since our SCJVM model represents pointers explicitly, we
represent function arguments using value parameters of the \Circus{}
action.
Local variables of the function are represented using \Circus{}
variable blocks.

If a function has a return value, it is represented with a result
parameter of the \Circus{} action, with an assignment to that
parameter at the end of the action representing return statements. 
It is not necessary to cater for return statements in the middle of a
function as we have control over the structure of the functions.
% is this how icecap does it? I don't think it is...
We follow guidelines for safety-critical uses of C variants, such as
MISRA-C~\cite{MISRA}, and use a single return statement at the end of
a function.
A function with both a return value and arguments has its value
parameters (representing the arguments) followed by the result
parameter (representing the return value).

% \begin{table}[t]
% \centering
% \caption{Various constructs in C in our shallow embedding in
%   \Circus{}}
% \label{embedding-table}
% \scriptsize
% \setlength{\zedindent}{0pt}
% \setlength{\zedleftsep}{2mm}
% \setlength{\zedtab}{1em}
% \setlength{\abovedisplayskip}{-2mm}
% \setlength{\belowdisplayskip}{-2mm}
% \setlength{\abovedisplayshortskip}{-2mm}
% \setlength{\belowdisplayshortskip}{-2mm}
% \renewcommand{\arraystretch}{1.5}
% \rowcolors{2}{white}{lightgray}
% \begin{tabular}{p{4.7cm}p{3.6cm}p{2.8cm}}
% \hline
% Construct & C code & \Circus{} equivalent \\
% \hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \raggedright Function definition &
% \begin{lstlisting}
% void foo() {...}
% \end{lstlisting}
% &
% \[
% Foo \circdef \cdots
% \] \\
% %\hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \raggedright Function definition with argument &
% \begin{lstlisting}
% void bar(int x) {...}
% \end{lstlisting}
% &
% \[
%   Bar \circdef \\
%   \t1 \circval x : \num @ \cdots
% \] \\
% %\hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \raggedright Function definition with return value &
% \begin{lstlisting}
% int baz() {...}
% \end{lstlisting}
% &
% \[
%   Baz \circdef \\
%   \t1 \circres retVal : \num @ \cdots
% \] \\
% % \hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \raggedright Function definition with parameter and return value &
% \begin{lstlisting}
% int baz(int x) {...}
% \end{lstlisting}
% &
% \[
%   Baz \circdef \\
%   \t1 \circval x : \num; \\
%   \t1 \circres retVal : \num @ \\
%   \t1 \cdots
% \] \\
% % \hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \raggedright Function call &
% \begin{lstlisting}
% foo();
% \end{lstlisting}
% &
% \[
% Foo
% \] \\
% %\hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \raggedright Function call with argument &
% \begin{lstlisting}
% bar(x);
% \end{lstlisting}
% &
% \[
% Bar(x)
% \] \\
% %\hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \raggedright Function call with return value &
% \begin{lstlisting}
% x = baz();
% \end{lstlisting}
% &
% \[
% Baz(x)
% \] \\
% %\hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Assignment &
% \begin{lstlisting}
% x = e;
% \end{lstlisting}
% &
% \begin{circus}
% x := e
% \end{circus} \\
% %\hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \raggedright Variable declaration &
% \begin{lstlisting}
% int x;
% \end{lstlisting}
% & \[\circvar x : \num @ \] \\
% %\hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \raggedright Variable declaration and initialisation &
% \begin{lstlisting}
% int x = e;
% \end{lstlisting}
% & \[\circvar x : \num @ x := e\] \\
% %\hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \raggedright If statement &
% \begin{lstlisting}
% if (b) {...}
% \end{lstlisting}
% &
% \[
% \circif b \circthen \cdots \\
% {} \circelse \lnot b \circthen \Skip \\
% \circfi
% \] \\
% %\hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \raggedright While loop &
% \begin{lstlisting}
% while (b) {...}
% \end{lstlisting}
% &
% {
% \def\arraystretch{1.1}
% \[
% \circmu X @ \\
%   \t1 \circif b \circthen \cdots \circseq X \\
%   \t1 {} \circelse \lnot b \circthen \Skip \\
%   \t1 \circfi
% \]}\\
% \hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \end{tabular}
% \end{table}

\section{Final Considerations}
\label{cee-final-considerations-section}

In this chapter we have presented our model of the core execution
environment (CEE) of an SCJVM and specified the subset of Java
bytecode covered in our model.
Our bytecode subset consists of 14 instructions, which focus on method
invocation and the manipulation of objects, since those are core
concepts of Java.
We have omitted instructions for exception handling, since that would
compilicate the model while adding little power.
Our subset is sufficiently small to permit reasoning, but large enough
to express a variety of SCJ programs.

Our CEE model is divided in three components, with a \Circus{} process
representing each component.
The first component is the memory, which manages objects and the
entering of backing stores, since the memory manager discussed in the
previous chapter has no knowledge of the structure of objects.
The second component of the CEE model is the interpreter, which
describes the semantics of each of the bytecode instructions in our
subset and provides for executing methods.
The third and final component is the interpreter, which manages the
SCJ mission model and coordinates execution.

One interesting point about our model is the handling of special
methods in the interpreter and launcher.
This is necessary for several reasons: to allow methods running in the
interpreter to access the SCJVM services defined in the previous
chapter, to allow mission setup methods to interact with the launcher,
and to permit entering of memory areas by interaction with the CEE
memory component.
The handling of special methods works by having the interpreter check
upon invocation of a method whether it requires special handling.
If it does require special handling, it is passed to the launcher to
be handled.
The launcher then performs the required handling of the method,
communicating with the SCJVM services and the memory as required.

This model forms the first part of our compilation strategy, which is
the specification of the source language.
That is mostly included in the interpreter section as the semantics of
the bytecode instructions, though handling of special methods passed
to the launcher and the representation of classes and objects must
also be considered in the compilation strategy.
There are also other possible uses for the model presented in this
chapter.
Since it is a model of an interpreting SCJVM, it could be used as a
specification for an implementation of an interpreting SCJVM.
Such an SCJVM could also incorporate the compilation strategy to
provide a choice between interpreted and complied code, as in the
icecap HVM.
Additionally, since error handling in our model is done via aborting
execution, an identification of the conditions required for the model
to be divergence-free would produce requirements that can be used for
bytecode verification.

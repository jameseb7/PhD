%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{crproof}[\nameref{pc-expansion-rule}]
  \begin{argue}
    \begin{array}{l}
      HandleInstruction_{bc}
    \end{array} \\
    = & Law [\nameref{alt-intro-law}] \\
    \begin{array}{l}
      \circif {} \circelse_{i \in ProgramAddress} pc = i \circthen HandleInstruction_{bc} \circfi
    \end{array} \\
    = & separate alternation branches \\
    \begin{array}{l}
      \circif \\
      {} \circelse_{i \in \dom bc} pc = i \circthen HandleInstruction_{bc} \\
      {} \circelse_{i \in ProgramAddress \setminus \dom bc} pc = i \circthen HandleInstruction_{bc} \\
      \circfi
    \end{array} \\
    = & Law [\nameref{alt-assump-intro-law}] \\
    \begin{array}{l}
      \circif \\
      {} \circelse_{i \in \dom bc} pc = i \circthen \{ pc = i\} \circseq HandleInstruction_{bc} \\
      {} \circelse_{i \in ProgramAddress \setminus \dom bc} pc = i \circthen \{ pc = i\} \circseq HandleInstruction_{bc} \\
      \circfi
    \end{array} \\
    = & Law [\nameref{copy-rule-law}] and definition of $HandleInstruction$ \\
    \begin{array}{l}
      \circif \\
      {} \circelse_{i \in \dom bc} pc = i \circthen \{ pc = i\} \circseq HandleInstruction_{bc} \\
      {} \circelse_{i \in ProgramAddress \setminus \dom bc} pc = i \circthen {} \\
      \t1 \{ pc = i\} \circseq (HandleAconst\_null \extchoice HandleDup \extchoice HandleAload \extchoice HandleAstore \\
      \t1 {} \extchoice HandleIadd \extchoice HandleIconst \extchoice HandleIneg \extchoice HandleGoto \extchoice HandleIf\_icmple \\
      \t1 {} \extchoice HandleAreturn \extchoice HandleReturn \extchoice HandleGetfield \extchoice HandlePutfield \\
      \t1 {} \extchoice HandleGetstatic \extchoice HandlePutstatic \extchoice HandleInvokevirtual \\
      \t1 {} \extchoice HandleInvokespecial \extchoice HandleInvokestatic \\
        \t1 {} \extchoice \lcircguard pc \notin \dom bc \rcircguard \circguard \Chaos) \\
      \circfi
    \end{array} \\
    = & Law [\nameref{assump-extchoice-distr-law}] \\
    \begin{array}{l}
      \circif \\
      {} \circelse_{i \in \dom bc} pc = i \circthen \{ pc = i\} \circseq HandleInstruction_{bc} \\
      {} \circelse_{i \in ProgramAddress \setminus \dom bc} pc = i \circthen {} \\
      \t1 (\{ pc = i\} \circseq HandleAconst\_null) \extchoice (\{ pc = i\} \circseq HandleDup) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq HandleAload) \extchoice (\{ pc = i\} \circseq HandleAstore) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq HandleIadd) \extchoice (\{ pc = i\} \circseq HandleIconst) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq HandleIneg) \extchoice (\{ pc = i\} \circseq HandleGoto) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq HandleIf\_icmple) \extchoice (\{ pc = i\} \circseq HandleAreturn) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq HandleReturn) \extchoice (\{ pc = i\} \circseq HandleGetfield) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq HandlePutfield) \extchoice (\{ pc = i\} \circseq HandleGetstatic) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq HandlePutstatic) \extchoice (\{ pc = i\} \circseq HandleInvokevirtual) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq HandleInvokespecial) \extchoice (\{ pc = i\} \circseq HandleInvokestatic) \\
        \t1 {} \extchoice (\{ pc = i\} \circseq (\lcircguard pc \notin \dom bc \rcircguard \circguard \Chaos)) \\
      \circfi
    \end{array} \\
    = & Law~[\nameref{copy-rule-law}], definitions of $Handle*$ actions, and Law~[\nameref{assump-guard-elim2-law}] \\
    \begin{array}{l}
      \circif \\
      {} \circelse_{i \in \dom bc} pc = i \circthen \{ pc = i\} \circseq HandleInstruction_{bc} \\
      {} \circelse_{i \in ProgramAddress \setminus \dom bc} pc = i \circthen {} \\
      \t1 (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq (\lcircguard pc \notin \dom bc \rcircguard \circguard \Chaos)) \\
      \circfi
    \end{array} \\
    = & Law~[\nameref{assump-guard-elim1-law}] \\
    \begin{array}{l}
      \circif \\
      {} \circelse_{i \in \dom bc} pc = i \circthen \{ pc = i\} \circseq HandleInstruction_{bc} \\
      {} \circelse_{i \in ProgramAddress \setminus \dom bc} pc = i \circthen {} \\
      \t1 (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \\
      \t1 {} \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \extchoice (\{ pc = i\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc = i\} \circseq \Chaos) \\
      \circfi
    \end{array} \\
    \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
    \begin{array}{l}
      \circif \\
      {} \circelse_{i \in \dom bc} pc = i \circthen HandleInstruction_{bc} \\
      {} \circelse_{i \in ProgramAddress \setminus \dom bc} pc = i \circthen {} \\
      \t1 \Stop \extchoice \Stop \extchoice \Stop \extchoice \Stop \extchoice \Stop \extchoice \Stop \extchoice \Stop \extchoice \Stop \\
      \t1 {} \extchoice \Stop \extchoice \Stop \extchoice \Stop \extchoice \Stop \extchoice \Stop \extchoice \Stop \extchoice \Stop \extchoice \Stop \\
      \t1 {} \extchoice \Stop \extchoice \Stop \extchoice \Chaos \\
      \circfi
    \end{array} \\
    = & Law~[\nameref{extchoice-unit-law}] \\
    \begin{array}{l}
      \circif \\
      {} \circelse_{i \in \dom bc} pc = i \circthen HandleInstruction_{bc} \\
      {} \circelse_{i \in ProgramAddress \setminus \dom bc} pc = i \circthen \Chaos \\
      \circfi
    \end{array} \\
    = & Law~[\nameref{alt-branch-elim-law}] \\
    \begin{array}{l}
      \circif {} \circelse_{i \in \dom bc} pc = i \circthen HandleInstruction_{bc} \circfi
    \end{array}
  \end{argue}
\end{crproof}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{crproof}[\nameref{HandleInstruction-refinement-rule}]
  \begin{argue}
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen HandleInstruction_{bc} \\
      {} \cdots {} \\
      \circfi
    \end{array} \\
    = & Law~[\nameref{alt-assump-intro-law}] \\
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen \{ pc = i \} \circseq HandleInstruction_{bc} \\
      {} \cdots {} \\
      \circfi
    \end{array}
  \end{argue}
  From the assumption of the rule ($i \in \dom bc$), we know that
  $bc~i$ is a well-defined expression and its value is in $Bytecode$. 
  There are thus 19 cases for the value of $bc~i$. 
  We consider each separately:
  \begin{enumerate}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 1: aconst_null
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \item Suppose $bc~i = aconst\_null$ then,
    \begin{argue}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}\\
      = & Law~[\nameref{assump-assump-intro-law}], and rule and case assumptions \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq
        HandleInstruction_{bc}
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and definition of $HandleInstruction$ \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \\
        \t1 (HandleAconst\_null
        \extchoice HandleDup
        \extchoice HandleAload
        \extchoice HandleAstore \\
        \t1 {} \extchoice HandleIadd
        \extchoice HandleIconst
        \extchoice HandleIneg
        \extchoice HandleGoto \\
        \t1 {} \extchoice HandleIf\_icmple
        \extchoice HandleAreturn
        \extchoice HandleReturn
        \extchoice HandleNew \\
        \t1 {} \extchoice HandleGetfield
        \extchoice HandlePutfield
        \extchoice HandleGetstatic
	\extchoice HandlePutstatic \\
        \t1 {} \extchoice HandleInvokevirtual
        \extchoice HandleInvokespecial
        \extchoice HandleInvokestatic \\
        \t1 {} \extchoice \lcircguard pc \notin \dom bc \rcircguard \circguard \Chaos) \\
      \end{array}\\
      = & Law~[\nameref{assump-extchoice-distr-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        ((\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleAconst\_null) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleDup) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleAload) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleAstore) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleIadd) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleIconst) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleIneg) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleGoto) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleIf\_icmple) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleAreturn) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleReturn) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleNew) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleGetfield) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandlePutfield) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleGetstatic) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandlePutstatic) \\
	\t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleInvokevirtual) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleInvokespecial) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleInvokestatic) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \lcircguard pc \notin \dom bc \rcircguard \circguard \Chaos))
      \end{array} \\
      = & Law~[\nameref{copy-rule-law}], the definitions of the $Handle{*}$ actions, and Law~[\nameref{assump-guard-elim2-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        ((\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleAconst\_null) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
	\t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop) \\
        \t1 {} \extchoice (\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \Stop)
      \end{array} \\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        ((\{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq HandleAconst\_null) \\
        \t1 {} \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop \\
        \t1 {} \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop
        \extchoice \Stop \\
        \t1 {} \extchoice \Stop)
      \end{array} \\
      = & Law~[\nameref{extchoice-comm-law}] and Law~[\nameref{extchoice-unit-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq
        HandleAconst\_null
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and definition of $HandleAconst\_null$ \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \\
        \t1 (\lcircguard pc \in \dom bc \land bc~pc = aconst\_null \rcircguard \circguard
        \lschexpract InterpreterAconst\_null \rschexpract)
      \end{array}\\
      = & Law~[\nameref{assump-guard-elim1-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq
        \lschexpract InterpreterAconst\_null \rschexpract
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and defintion of $InterpreterAconst\_null$ \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aconst\_null\} \circseq \\
        \t1 \lschexpract \exists \Delta StackFrame @ \\
        \t2 StackFrameACONST\_NULL \land PromoteStackFrameOp \rschexpract
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq \\
        \t1 \lschexpract \exists \Delta StackFrame @ \\
        \t2 StackFrameACONST\_NULL \land PromoteStackFrameOp \rschexpract
      \end{array}\\
      = & Lemma~\ref{Handle-schema-refinement-lemma} \\
      \begin{array}{l}
        \lschexpract \exists \Delta StackFrame @ \\
        \t1 StackFrameACONST\_NULL \land PromoteStackFrameOpEPC \rschexpract \circseq \\
        \t1 pc := i + 1
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and defintion of $InterpreterAconst\_nullEPC$ \\
      \begin{array}{l}
        \lschexpract InterpreterAconst\_nullEPC \rschexpract \circseq pc := i + 1
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and defintion of $HandleAconst\_nullEPC$ \\
      \begin{array}{l}
        HandleAconst\_nullEPC \circseq pc := i + 1
      \end{array}\\
      = & Definition of $handleAction$ and case assumption $bc~i = aconst\_null$ \\
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}\\
    \end{argue}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 2: dup
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \item Suppose $bc~i = dup$ then, by similar reasoning to the
    previous case,
    \begin{circus}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}
      \circrefines_A
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}
    \end{circus}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 3: aload
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item Suppose $bc~i = aload~lvi$ for some $lvi \in \nat$ then,
    \begin{argue}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}\\
      \circrefines_A & Similarly to the proofs of the previous cases \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aload~lvi\} \circseq \\        
	\t1 (\circvar variableIndex : \nat \circspot \\
        \t2 variableIndex := (aload\inv)~(bc~pc) \circseq
        \lschexpract InterpreterAload \rschexpract)
      \end{array}\\
      = & Law~{\nameref{var-seq-extl-law}} \\
      \begin{array}{l}
        \{ pc = i \} \circseq (\circvar variableIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = aload~lvi\} \circseq \\
        \t1 variableIndex := (aload\inv)~(bc~pc) \circseq
        \lschexpract InterpreterAload \rschexpract)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      %and $(pc \in \dom bc \land bc~pc = aload~lvi) \implies (aload\inv)~(bc~pc) = lvi$ \\
      \begin{array}{l}
        \{ pc = i \} \circseq (\circvar variableIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = aload~lvi\} \circseq        
        variableIndex := (aload\inv)~(bc~pc) \circseq \\
        \t1 \{variableIndex = lvi\} \circseq
        \lschexpract InterpreterAload \rschexpract)
      \end{array}\\
      = & Law~{\nameref{var-seq-extl-law}} \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aload~lvi\} \circseq \\
        \t1 (\circvar variableIndex : \nat \circspot        
        variableIndex := (aload\inv)~(bc~pc) \circseq \\
        \t2 \{variableIndex = lvi\} \circseq
        \lschexpract InterpreterAload \rschexpract)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-seq-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aload~lvi\} \circseq \\
        \t1 (\circvar variableIndex : \nat \circspot        
        variableIndex := (aload\inv)~(bc~pc) \circseq \\
        \t2 \{variableIndex = lvi\} \circseq
        \lschexpract InterpreterAload[lvi/variableIndex?] \rschexpract)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aload~lvi\} \circseq \\
        \t1 (\circvar variableIndex : \nat \circspot        
        variableIndex := (aload\inv)~(bc~pc) \circseq \\
        \t2 \lschexpract InterpreterAload[lvi/variableIndex?] \rschexpract)
      \end{array}\\
      = & Law~[\nameref{var-assign-intro-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aload~lvi\} \circseq \\
        \t1 \lschexpract InterpreterAload[lvi/variableIndex?] \rschexpract
      \end{array}\\
      = & Law~[\nameref{var-assign-intro-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aload~lvi\} \circseq \\
        \t1 (\circvar variableIndex : \nat \circspot \\       
        \t2 variableIndex := lvi \circseq
        \lschexpract InterpreterAload[lvi/variableIndex?] \rschexpract)
      \end{array}\\
      = & Law~[\nameref{assign-seq-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aload~lvi\} \circseq \\
        \t1 (\circvar variableIndex : \nat \circspot        
        variableIndex := lvi \circseq \lschexpract InterpreterAload \rschexpract)
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and defintion of $InterpreterAload$ \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = aload~lvi\} \circseq \\
        \t1 (\circvar variableIndex : \nat \circspot        
        variableIndex := lvi \circseq \\
        \t2 \lschexpract \exists \Delta StackFrame @
        StackFrameALOAD \land PromoteStackFrameOp \rschexpract)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        (\circvar variableIndex : \nat \circspot        
        variableIndex := lvi \circseq \\
        \t1 \lschexpract \exists \Delta StackFrame @
        StackFrameALOAD \land PromoteStackFrameOp \rschexpract)
      \end{array}\\
      = & Lemma~\ref{Handle-schema-refinement-lemma} \\
      \begin{array}{l}
        (\circvar variableIndex : \nat \circspot        
        variableIndex := lvi \circseq \\
        \t1 \lschexpract \exists \Delta StackFrame @
        StackFrameALOAD \land PromoteStackFrameOpEPC \rschexpract \circseq \\
        \t1 pc := i + 1)
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and definition of $InterpreterAloadEPC$ \\
      \begin{array}{l}
        (\circvar variableIndex : \nat \circspot \\       
        \t1 variableIndex := lvi \circseq
        \lschexpract InterpreterAloadEPC \rschexpract \circseq
        pc := i + 1)
      \end{array}\\
      = & Law~[\nameref{var-seq-extr-law}] \\
      \begin{array}{l}
        (\circvar variableIndex : \nat \circspot \\        
        \t1 variableIndex := lvi \circseq
        \lschexpract InterpreterAloadEPC \rschexpract) \circseq
        pc := i + 1
      \end{array}\\
      = & Law~[\nameref{val-def-law}] \\
      \begin{array}{l}
        (\circval variableIndex : \nat \circspot
        \lschexpract InterpreterAloadEPC \rschexpract)(lvi) \circseq
        pc := i + 1
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and definition of $HandleAloadEPC$ \\
      \begin{array}{l}
        HandleAloadEPC(lvi) \circseq
        pc := i + 1
      \end{array}\\
      = & Definition of $handleAction$ and case assumption $bc~i = aload~lvi$ \\
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}\\
    \end{argue}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 4: astore
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \item Suppose $bc~i = astore~lvi$ for some $lvi \in \nat$ then, by
    similar reasoning to the previous case,
    \begin{circus}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}
      \circrefines_A
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}
    \end{circus}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 5: iadd
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item Suppose $bc~i = iadd$ then, by similar reasoning to case 1,
    \begin{circus}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}
      \circrefines_A
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}
    \end{circus}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 6: iconst
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \item Suppose $bc~i = iconst~n$ for some $n \in \nat$ then, by
    similar reasoning to case 3,
    \begin{circus}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}
      \circrefines_A
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}
    \end{circus}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 7: ineg
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item Suppose $bc~i = ineg$ then, by similar reasoning to case 1
    \begin{circus}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}
      \circrefines_A
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}
    \end{circus}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 8: goto
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item Suppose $bc~i = goto~ofst$ for some $ofst \in ProgramAddress$ then,
    \begin{argue}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}\\
      \circrefines_A & Similarly to case 3 \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = goto~ofst\} \circseq \\
        \t1 \lschexpract InterpreterGoto[ofst/branchOffset?] \rschexpract
      \end{array} \\
      = &  Schema calculus \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = goto~ofst\} \circseq
        \lschexpract [\Delta InterpreterState | \\
	\t1 pc' = pc + ofst \land \\
	\t1 frameStack' = frameStack \land \\
	\t1 currentClass' = currentClass \land \\
	\t1 frameStackID' = frameStackID] \rschexpract
      \end{array} \\
      = & Law~[\nameref{assign-schema-conv-law}] and general assumption of passing JVM verification \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = goto~ofst\} \circseq \\
        \{inv(InterpreterState)\} \circseq
        pc := pc + ofst
      \end{array} \\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}]  \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        pc := pc + ofst
      \end{array} \\
      \circrefines_A & Law~[\nameref{assump-assign-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        pc := i + ofst
      \end{array} \\
      = & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}]  \\
      \begin{array}{l}
        pc := i + ofst
      \end{array} \\
      = & Definition of $handleAction$ and case assumption $bc~i = goto~ofst$ \\
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}\\
    \end{argue}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 9: if_icmple
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \item Suppose $bc~i = if\_icmple~ofst$ for some $ofst \in ProgramAddress$ then,
    {\setlength{\zedtab}{0.5cm}
    \begin{argue}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}\\
      \circrefines_A & Similarly to previous case \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = if\_icmple~ofst\} \circseq \\
        \t1 \lschexpract InterpreterIf\_Icmple[ofst/branchOffset?] \rschexpract
      \end{array} \\
      = & Law~[\nameref{copy-rule-law}] and definition of $InterpreterIf\_icmple$  \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = if\_icmple~ofst\} \circseq
        \lschexpract [\Delta InterpreterState | \\
	\t1 (\exists value1!, value2! : Word @  \\
        \t2 \exists \Delta StackFrame | \\
        \t3 StackFramePop[value2!/value!] \semi \\
        \t3 StackFramePop[value1!/value!] @ \\
	\t2 \theta StackFrame = last~frameStack \land \\
	\t2 frameStack' = (front~frameStack) \cat \langle \theta StackFrame~' \rangle \land \\
	\t2 pc' = pc + \IF (value1! \leq value2!) \THEN ofst \ELSE 1) \land \\
	\t1 currentClass' = currentClass \land \\
	\t1 frameStackID' = frameStackID] \rschexpract
      \end{array} \\
      = & Law~[\nameref{schema-var-intro-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = if\_icmple~ofst\} \circseq \\
        \t1 \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract [\Delta InterpreterState; value1, value2 : Word; value1', value2' : Word | \\
        \t2 \exists value1!, value2! : Word @  \exists \Delta StackFrame | \\
        \t3 StackFramePop[value2!/value!] \semi \\
        \t3 StackFramePop[value1!/value!] @ \\
	\t4 \theta StackFrame = last~frameStack \land \\
	\t4 frameStack' = (front~frameStack) \cat \langle \theta StackFrame~' \rangle \land \\
	\t4 pc' = pc + \IF (value1! \leq value2!) \THEN ofst \ELSE 1) \land \\
	\t2 currentClass' = currentClass \land \\
	\t2 frameStackID' = frameStackID] \rschexpract
      \end{array} \\
      \circrefines_A & Law~[\nameref{schema-refinement-law}] and existential quantifier introduction \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = if\_icmple~ofst\} \circseq \\
        \t1 \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract [\Delta InterpreterState; value1, value2 : Word; value1', value2' : Word | \\
        \t2 \exists \Delta StackFrame | \\
        \t3 StackFramePop[value2'/value!] \semi \\
        \t3 StackFramePop[value1'/value!] @ \\
	\t4 \theta StackFrame = last~frameStack \land \\
	\t4 frameStack' = (front~frameStack) \cat \langle \theta StackFrame~' \rangle \land \\
	\t4 pc' = pc + \IF (value1' \leq value2') \THEN ofst \ELSE 1) \land \\
	\t2 currentClass' = currentClass \land \\
	\t2 frameStackID' = frameStackID] \rschexpract
      \end{array} \\
      = & Schema calculus \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = if\_icmple~ofst\} \circseq \\
        \t1 \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract \exists value1mid, value2mid : Word @\\
        \t2 [\Delta InterpreterState; value1, value2 : Word; value1', value2' : Word | \\
        \t2 \exists \Delta StackFrame | \\
        \t3 StackFramePop[value2'/value!] \semi \\
        \t3 StackFramePop[value1'/value!] @ \\
	\t4 \theta StackFrame = last~frameStack \land \\
	\t4 frameStack' = (front~frameStack) \cat \langle \theta StackFrame~' \rangle \land \\
	\t4 pc' = pc \land \\
	\t2 currentClass' = currentClass \land \\
	\t2 frameStackID' = frameStackID][value1mid/value1', \\
        \t3 value2mid/value2'] \land \\
        \t1 [\Delta InterpreterState; value1, value2 : Word; value1', value2' : Word | \\
        \t2 pc' = pc + \IF (value1 \leq value2) \THEN ofst \ELSE 1) \land \\
        \t2 value1' = value1 \land value2' = value2 \land \\
        \t2 frameStack' = frameStack \land \\
        \t2 currentClass' = currentClass \land \\
	\t2 frameStackID' = frameStackID][value1mid/value1, value2mid/value2] \rschexpract
      \end{array} \\
      = & Definition of schema composition \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = if\_icmple~ofst\} \circseq \\
        \t1 \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract [\Delta InterpreterState; value1, value2 : Word; value1', value2' : Word | \\
        \t2 \exists \Delta StackFrame | \\
        \t3 StackFramePop[value2'/value!] \semi \\
        \t3 StackFramePop[value1'/value!] @ \\
	\t4 \theta StackFrame = last~frameStack \land \\
	\t4 frameStack' = (front~frameStack) \cat \langle \theta StackFrame~' \rangle \land \\
	\t4 pc' = pc \land \\
	\t2 currentClass' = currentClass \land \\
	\t2 frameStackID' = frameStackID] \comp \\
        \t1 [\Delta InterpreterState; value1, value2 : Word; value1', value2' : Word | \\
        \t2 pc' = pc + \IF (value1 \leq value2) \THEN ofst \ELSE 1) \land \\
        \t2 value1' = value1 \land value2' = value2 \land \\
        \t2 frameStack' = frameStack \land \\
        \t2 currentClass' = currentClass \land \\
	\t2 frameStackID' = frameStackID] \rschexpract
      \end{array} \\
      = & Law~[\nameref{schema-comp-seq-conv-law}]\\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = if\_icmple~ofst\} \circseq \\
        \t1 \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract [\Delta InterpreterState; value1, value2 : Word; value1', value2' : Word | \\
        \t2 \exists \Delta StackFrame | \\
        \t3 StackFramePop[value2'/value!] \semi \\
        \t3 StackFramePop[value1'/value!] @ \\
	\t4 \theta StackFrame = last~frameStack \land \\
	\t4 frameStack' = (front~frameStack) \cat \langle \theta StackFrame~' \rangle \land \\
	\t4 pc' = pc \land \\
	\t2 currentClass' = currentClass \land \\
	\t2 frameStackID' = frameStackID] \rschexpract \circseq \\
        \t1 \lschexpract [\Delta InterpreterState; value1, value2 : Word; value1', value2' : Word | \\
        \t2 pc' = pc + \IF (value1 \leq value2) \THEN ofst \ELSE 1) \land \\
        \t2 value1' = value1 \land value2' = value2 \land \\
        \t2 frameStack' = frameStack \land \\
        \t2 currentClass' = currentClass \land \\
	\t2 frameStackID' = frameStackID] \rschexpract
      \end{array} \\
      = & Law~[\nameref{assign-schema-conv-law}]\\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = if\_icmple~ofst\} \circseq \\
        \t1 \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract [\Delta InterpreterState; value1, value2 : Word; value1', value2' : Word | \\
        \t2 \exists \Delta StackFrame | \\
        \t3 StackFramePop[value2'/value!] \semi \\
        \t3 StackFramePop[value1'/value!] @ \\
	\t3 \theta StackFrame = last~frameStack \land \\
	\t3 frameStack' = (front~frameStack) \cat \langle \theta StackFrame~' \rangle \land \\
	\t3 pc' = pc \land \\
	\t2 currentClass' = currentClass \land \\
	\t2 frameStackID' = frameStackID] \rschexpract \circseq \\
        \t1 pc := pc + \IF (value1 \leq value2) \THEN ofst \ELSE 1
      \end{array} \\
      = & Schema calculus \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = if\_icmple~ofst\} \circseq \\
        \t1 \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract \exists \Delta StackFrame @ \\
        \t2 StackFramePop[value2'/value!] \semi StackFramePop[value1'/value!] \land \\
        \t2 [\Delta InterpreterState; \Delta StackFrame | \\
	\t2 \theta StackFrame = last~frameStack \land \\
	\t2 frameStack' = (front~frameStack) \cat \langle \theta StackFrame~' \rangle \land \\
	\t2 pc' = pc \land \\
	\t2 currentClass' = currentClass \land \\
	\t2 frameStackID' = frameStackID] \rschexpract \circseq \\
        \t1 pc := pc + \IF (value1 \leq value2) \THEN ofst \ELSE 1
      \end{array}\\
      = & Definition of $PromoteStackFrameOpEPC$ \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = if\_icmple~ofst\} \circseq \\
        \t1 \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract \exists \Delta StackFrame @ \\
        \t2 StackFramePop[value2'/value!] \semi StackFramePop[value1'/value!] \\
        \t2 {} \land PromoteStackFrameOpEPC \rschexpract \circseq \\
        \t1 pc := pc + \IF (value1 \leq value2) \THEN branchOffset? \ELSE 1
      \end{array}\\
      = & schema calculus \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = if\_icmple~ofst\} \circseq \\
        \t1 \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract (\exists \Delta StackFrame @ \\
        \t2 StackFramePop[value2'/value!] \land PromoteStackFrameOpEPC) \semi \\
        \t1 (\exists \Delta StackFrame @ \\
        \t2 StackFramePop[value1'/value!] \land PromoteStackFrameOpEPC)  \rschexpract \circseq \\
        \t1 pc := pc + \IF (value1 \leq value2) \THEN branchOffset? \ELSE 1
      \end{array}\\
      = & Law~[\nameref{schema-comp-seq-conv-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = if\_icmple~ofst\} \circseq \\
        \t1 \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract \exists \Delta StackFrame @ \\
        \t2 StackFramePop[value2'/value!] \land PromoteStackFrameOpEPC \rschexpract \circseq \\
        \t1 \lschexpract \exists \Delta StackFrame @ \\
        \t2 StackFramePop[value1'/value!] \land PromoteStackFrameOpEPC  \rschexpract \circseq \\
        \t1 pc := pc + \IF (value1 \leq value2) \THEN branchOffset? \ELSE 1
      \end{array}\\
      = & Definition of $InterpreterPopEPC$ \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = if\_icmple~ofst\} \circseq \\
        \t1 \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract InterpreterPopEPC[value2'/value!] \rschexpract \circseq \\
        \t1 \lschexpract InterpreterPopEPC[value1'/value!] \rschexpract \circseq \\
        \t1 pc := pc + \IF (value1 \leq value2) \THEN ofst \ELSE 1 
      \end{array}\\
      = & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}]  \\
      \begin{array}{l}
        \{ pc = i \} \circseq \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract InterpreterPopEPC[value2'/value!] \rschexpract \circseq \\
        \t1 \lschexpract InterpreterPopEPC[value1'/value!] \rschexpract \circseq \\
        \t1 pc := pc + \IF (value1! \leq value2!) \THEN ofst \ELSE 1 
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        \circvar value1, value2 : Word \circspot \{ pc = i \} \circseq \\
        \t1 \lschexpract InterpreterPopEPC[value2'/value!] \rschexpract \circseq \\
        \t1 \lschexpract InterpreterPopEPC[value1'/value!] \rschexpract \circseq \\
        \t1 pc := pc + \IF (value1 \leq value2) \THEN ofst \ELSE 1 
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-schema-dist-law}] \\
      \begin{array}{l}
        \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract InterpreterPopEPC[value2'/value!] \rschexpract \circseq \{ pc = i \} \circseq \\
        \t1 \lschexpract InterpreterPopEPC[value1'/value!] \rschexpract \circseq \\
        \t1 pc := pc + \IF (value1 \leq value2) \THEN ofst \ELSE 1 
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-schema-dist-law}] \\
      \begin{array}{l}
        \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract InterpreterPopEPC[value2'/value!] \rschexpract \circseq \\
        \t1 \lschexpract InterpreterPopEPC[value1'/value!] \rschexpract \circseq \{ pc = i \} \circseq \\
        \t1 pc := pc + \IF (value1 \leq value2) \THEN ofst \ELSE 1 
      \end{array}\\
      = & Law~[\nameref{assump-assign-subst-law}] \\
      \begin{array}{l}
        \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract InterpreterPopEPC[value2'/value!] \rschexpract \circseq \\
        \t1 \lschexpract InterpreterPopEPC[value1'/value!] \rschexpract \circseq \{ pc = i \} \circseq \\
        \t1 pc := i + \IF (value1 \leq value2) \THEN ofst \ELSE 1 
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}]  \\
      \begin{array}{l}
        \circvar value1, value2 : Word \circspot \\
        \t1 \lschexpract InterpreterPopEPC[value2'/value!] \rschexpract \circseq \\
        \t1 \lschexpract InterpreterPopEPC[value1'/value!] \rschexpract \circseq \\
        \t1 pc := i + \IF (value1 \leq value2) \THEN ofst \ELSE 1 
      \end{array}\\
      = & Definition of $handleAction$ and case assumption $bc~i = if\_icmple~ofst$ \\
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}\\
    \end{argue}}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 10: areturn
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \item Suppose $bc~i = areturn$ then,
    \begin{argue}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}\\
      \circrefines_A & Similar to previous cases \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = areturn\} \circseq
        HandleAreturn
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and defintion of $HandleAreturn$ \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = areturn\} \circseq
        (\circvar returnValue : Word \circspot \\
        \t1 \lcircguard pc \in \dom bc \land bc~pc = areturn \rcircguard \circguard {} \\ 
        \t1 CheckSynchronizedReturn \circseq \lschexpract InterpreterAreturn \rschexpract \circseq \\
        \t1 CheckLauncherReturn(returnValue))
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}]\\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar returnValue : Word \circspot \{ pc \in \dom bc \land bc~pc = areturn\} \circseq \\
        \t1 \lcircguard pc \in \dom bc \land bc~pc = areturn \rcircguard \circguard {} \\ 
        \t1 CheckSynchronizedReturn \circseq \lschexpract InterpreterAreturn \rschexpract \circseq \\
        \t1 CheckLauncherReturn(returnValue))
      \end{array}\\
      = & Law~[\nameref{assump-guard-elim1-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar returnValue : Word \circspot \{ pc \in \dom bc \land bc~pc = areturn\} \circseq \\ 
        \t1 CheckSynchronizedReturn \circseq \lschexpract InterpreterAreturn \rschexpract \circseq \\
        \t1 CheckLauncherReturn(returnValue))
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        (\circvar returnValue : Word \circspot CheckSynchronizedReturn \circseq \lschexpract InterpreterAreturn \rschexpract \circseq \\
        \t1 CheckLauncherReturn(returnValue))
      \end{array}\\
      = & Law~[\nameref{var-seq-extl}] \\
      \begin{array}{l}
        CheckSynchronizedReturn \circseq (\circvar returnValue : Word \circspot \lschexpract InterpreterAreturn \rschexpract \circseq \\
        \t1 CheckLauncherReturn(returnValue))
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and definition of $HandleAreturnEPC$ \\
      \begin{array}{l}
        CheckSynchronizedReturn \circseq HandleAreturnEPC
      \end{array}\\
      = & Definition of $handleAction$ and case assumption $bc~i = areturn$ \\
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}\\
    \end{argue}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 11: return
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \item Suppose $bc~i = return$ then, by similar reasoning to the
    previous case,
    \begin{circus}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}
      \circrefines_A
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}
    \end{circus}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 12: new
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item Suppose $bc~i = new~cpi$ then,
    \begin{argue}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}\\
      \circrefines_A & Similar to previous cases \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = new~cpi\} \circseq \\
        \t1 (\circif (new\inv)~(bc~pc) \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~currentClass~((new\inv)~(bc~pc))) \\
        \t2 {} \then newObjectRet?oid \then \lschexpract InterpreterPush[oid/value?] \rschexpract \\
        \t1 {} \circelse (new\inv)~(bc~pc) \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-assign-intro-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = new~cpi\} \circseq \\
        \t1 (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif (new\inv)~(bc~pc) \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~currentClass~((new\inv)~(bc~pc))) \\
        \t2 {} \then newObjectRet?oid \then \lschexpract InterpreterPush[oid/value?] \rschexpract \\
        \t1 {} \circelse (new\inv)~(bc~pc) \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = new~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \circif (new\inv)~(bc~pc) \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~currentClass~((new\inv)~(bc~pc))) \\
        \t2 {} \then newObjectRet?oid \then \lschexpract InterpreterPush[oid/value?] \rschexpract \\
        \t1 {} \circelse (new\inv)~(bc~pc) \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = new~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = new~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif (new\inv)~(bc~pc) \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~currentClass~((new\inv)~(bc~pc))) \\
        \t2 {} \then newObjectRet?oid \then \lschexpract InterpreterPush[oid/value?] \rschexpract \\
        \t1 {} \circelse (new\inv)~(bc~pc) \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-alt-guard-replace-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = new~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = new~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~currentClass~((new\inv)~(bc~pc))) \\
        \t2 {} \then newObjectRet?oid \then \lschexpract InterpreterPush[oid/value?] \rschexpract \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-alt-dist-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = new~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = new~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = new~cpi \land cpIndex = cpi \} \circseq \\
        \t2 newObject!thread!(classOf~currentClass~((new\inv)~(bc~pc))) \\
        \t2 {} \then newObjectRet?oid \then \lschexpract InterpreterPush[oid/value?] \rschexpract \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = new~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-seq-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = new~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = new~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = new~cpi \land cpIndex = cpi \} \circseq \\
        \t2 newObject!thread!(classOf~cpIndex) \\
        \t2 {} \then newObjectRet?oid \then \lschexpract InterpreterPush[oid/value?] \rschexpract \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = new~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~cpIndex) \\
        \t2 {} \then newObjectRet?oid \then \lschexpract InterpreterPush[oid/value?] \rschexpract \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~cpIndex) \\
        \t2 {} \then newObjectRet?oid \then \lschexpract InterpreterPush[oid/value?] \rschexpract \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~cpIndex) \\
        \t2 {} \then newObjectRet?oid \then \lschexpract InterpreterPush[oid/value?] \rschexpract \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-alt-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 newObject!thread!(classOf~cpIndex) \\
        \t2 {} \then newObjectRet?oid \then \lschexpract InterpreterPush[oid/value?] \rschexpract \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-output-prefix-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 newObject!thread!(classOf~cpIndex) \\
        \t2 {} \then (\{ pc = i \} \circseq newObjectRet?oid \\
        \t2 {} \then \lschexpract InterpreterPush[oid/value?] \rschexpract) \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-input-prefix-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 newObject!thread!(classOf~cpIndex) \\
        \t2 {} \then (\{ pc = i \} \circseq newObjectRet?oid \\
        \t2 {} \then (\{ pc = i \} \circseq \lschexpract InterpreterPush[oid/value?] \rschexpract)) \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and definition of $InterpreterPush$ \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 newObject!thread!(classOf~cpIndex) \\
        \t2 {} \then (\{ pc = i \} \circseq newObjectRet?oid \\
        \t2 {} \then (\{ pc = i \} \circseq \lschexpract \exists \Delta StackFrame @ \\
        \t3 StackFramePush[oid/value?] \land PromoteStackFrameOp \rschexpract)) \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Lemma~\ref{Handle-schema-refinement-lemma} \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 newObject!thread!(classOf~cpIndex) \\
        \t2 {} \then (\{ pc = i \} \circseq newObjectRet?oid \\
        \t2 {} \then (\lschexpract \exists \Delta StackFrame @ \\
        \t3 StackFramePush[oid/value?] \land PromoteStackFrameOpEPC \rschexpract) \circseq \\
        \t3 pc := i + 1) \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~cpIndex) \then newObjectRet?oid \then {} \\
        \t2 \lschexpract \exists \Delta StackFrame @ \\
        \t3 StackFramePush[oid/value?] \land PromoteStackFrameOpEPC \rschexpract \circseq \\
        \t3 pc := i + 1 \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{seq-zerol-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~cpIndex) \then newObjectRet?oid \then {} \\
        \t2 \lschexpract \exists \Delta StackFrame @ \\
        \t3 StackFramePush[oid/value?] \land PromoteStackFrameOpEPC \rschexpract \circseq \\
        \t3 pc := i + 1 \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \circseq pc := i + 1 \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{alt-seq-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~cpIndex) \then newObjectRet?oid \then {} \\
        \t2 \lschexpract \exists \Delta StackFrame @ \\
        \t3 StackFramePush[oid/value?] \land PromoteStackFrameOpEPC \rschexpract \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi \circseq pc := i + 1)
      \end{array}\\
      = & Law~[\nameref{var-seq-extr-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~cpIndex) \then newObjectRet?oid \then {} \\
        \t2 \lschexpract \exists \Delta StackFrame @ \\
        \t3 StackFramePush[oid/value?] \land PromoteStackFrameOpEPC \rschexpract \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi) \circseq pc := i + 1
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and definition of $InterpreterPushEPC$ \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~cpIndex) \then newObjectRet?oid \then {} \\
        \t2 \lschexpract InterpreterPushEPC[oid/value?] \rschexpract) \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi) \circseq pc := i + 1
      \end{array}\\
      = & Law~[\nameref{val-def-law}] \\
      \begin{array}{l}
        (\circval cpIndex : \nat \circspot \\
        \t1 \circif cpIndex \in classRefIndices~currentClass \circthen {} \\
        \t2 newObject!thread!(classOf~cpIndex) \then newObjectRet?oid \then {} \\
        \t2 \lschexpract InterpreterPushEPC[oid/value?] \rschexpract \\
        \t1 {} \circelse cpIndex \notin classRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)(cpi) \circseq pc := i + 1
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and definition of $HandleNewEPC$ \\
      \begin{array}{l}
        HandleNewEPC(cpi) \circseq pc := i + 1
      \end{array}\\
      = & Definition of $handleAction$ and case assumption $bc~i = new~cpi$ \\
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}\\
    \end{argue}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 13: getfield
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item Suppose $bc~i = getfield~cpi$ then,
    \begin{argue}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}\\
      \circrefines_A & Similar to previous cases \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = getfield~cpi\} \circseq \\
        \t1 (\circif (getfield\inv)~(bc~pc) \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~((getfield\inv)~(bc~pc)) \circseq \\
        \t2 \circvar cid : ClassID \circspot cid := (classOf~currentClass~((getfield\inv)~(bc~pc))) \circseq \\
        \t2 getField!oid!cid!fid \then getFieldRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse (getfield\inv)~(bc~pc) \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Similar to previous case \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = getfield~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = getfield~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = getfield~cpi \land cpIndex = cpi \} \circseq \\
        \t2 \circvar oid : ObjectID \circspot \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~((getfield\inv)~(bc~pc)) \circseq \\
        \t2 \circvar cid : ClassID \circspot cid := (classOf~currentClass~((getfield\inv)~(bc~pc))) \circseq \\
        \t2 getField!oid!cid!fid \then getFieldRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = getfield~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = getfield~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = getfield~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \\
        \t2 \{ pc \in \dom bc \land bc~pc = getfield~cpi \land cpIndex = cpi \} \circseq \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~((getfield\inv)~(bc~pc)) \circseq \\
        \t2 \circvar cid : ClassID \circspot cid := (classOf~currentClass~((getfield\inv)~(bc~pc))) \circseq \\
        \t2 getField!oid!cid!fid \then getFieldRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = getfield~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-seq-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = getfield~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = getfield~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \\
        \t2 \{ pc \in \dom bc \land bc~pc = getfield~cpi \land cpIndex = cpi \} \circseq \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 getField!oid!cid!fid \then getFieldRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = getfield~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 getField!oid!cid!fid \then getFieldRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 getField!oid!cid!fid \then getFieldRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 getField!oid!cid!fid \then getFieldRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-alt-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 \circvar oid : ObjectID \circspot \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 getField!oid!cid!fid \then getFieldRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \{ pc = i \} \circseq \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 getField!oid!cid!fid \then getFieldRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-schema-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq
        \{ pc = i \} \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 getField!oid!cid!fid \then getFieldRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 getField!oid!cid!fid \then getFieldRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq \\
        \t2 fid := fieldOf~currentClass~cpIndex \circseq \{ pc = i \} \circseq \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 getField!oid!cid!fid \then getFieldRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq \\
        \t2 fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq cid := classOf~currentClass~cpIndex \circseq \\
        \t2 getField!oid!cid!fid \then getFieldRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq \\
        \t2 fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq \\
        \t2 cid := classOf~currentClass~cpIndex \circseq \{ pc = i \} \circseq \\
        \t2 getField!oid!cid!fid \then getFieldRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      
      
      = & Law~[\nameref{assump-output-prefix-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq \\
        \t2 fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq \\
        \t2 cid := classOf~currentClass~cpIndex \circseq \{ pc = i \} \circseq \\
        \t2 getField!oid!fid \then ( \{ pc = i \} \circseq getFieldRet?value \\
        \t2 {} \then \lschexpract InterpreterPush \rschexpract) \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-input-prefix-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq \\
        \t2 fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq \\
        \t2 cid := classOf~currentClass~cpIndex \circseq \{ pc = i \} \circseq \\
        \t2 getField!oid!fid \then ( \{ pc = i \} \circseq getFieldRet?value \\
        \t2 {} \then (\{ pc = i \} \circseq \lschexpract InterpreterPush \rschexpract)) \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Definition of $InterpreterPush$ \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq \\
        \t2 fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq \\
        \t2 cid := classOf~currentClass~cpIndex \circseq \{ pc = i \} \circseq \\
        \t2 getField!oid!fid \then ( \{ pc = i \} \circseq getFieldRet?value \then {} \\
        \t2 (\{ pc = i \} \circseq
        \lschexpract \exists \Delta StackFrame @ \\
        \t3 StackFramePush \land PromoteStackFrameOp \rschexpract)) \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Lemma~\ref{Handle-schema-refinement-lemma} \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \\
        \t2 \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq \\
        \t2 fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq \\
        \t2 cid := classOf~currentClass~cpIndex \circseq \{ pc = i \} \circseq \\
        \t2 getField!oid!fid \then ( \{ pc = i \} \circseq getFieldRet?value \then {} \\
        \t2 (\lschexpract \exists \Delta StackFrame @ \\
        \t3 StackFramePush \land PromoteStackFrameOpEPC \rschexpract) \circseq \\
        \t3 pc := i + 1) \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar oid : ObjectID \circspot \lschexpract InterpreterPop[oid!/value!] \hide (pc, pc') \rschexpract \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 getField!oid!fid \then getFieldRet?value \then {} \\
        \t2 \lschexpract \exists \Delta StackFrame @ \\
        \t3 StackFramePush \land PromoteStackFrameOpEPC \rschexpract \circseq \\
        \t3 pc := i + 1 \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Similar to previous case \\
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}\\
    \end{argue}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 14: putfield
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item Suppose $bc~i = putfield~cpi$ then,
    \begin{argue}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}\\
      \circrefines_A & Similar to previous case \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = putfield~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~((putfield\inv)~(bc~pc)) \circseq \\
        \t2 \circvar cid : ClassID \circspot cid := (classOf~currentClass~((putfield\inv)~(bc~pc))) \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract InterpreterPop \hide (pc,pc') \rschexpract \circseq \lschexpract InterpreterPop[oid!/value!] \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = putfield~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar fid : FieldID \circspot \\
        \t2 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \\
        \t2 fid := fieldOf~currentClass~((putfield\inv)~(bc~pc)) \circseq \\
        \t2 \circvar cid : ClassID \circspot cid := (classOf~currentClass~((putfield\inv)~(bc~pc))) \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract InterpreterPop \hide (pc,pc') \rschexpract \circseq \lschexpract InterpreterPop[oid!/value!] \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = putfield~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar fid : FieldID \circspot \\
        \t2 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \\
        \t2 fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot cid := (classOf~currentClass~((putfield\inv)~(bc~pc))) \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract InterpreterPop \hide (pc,pc') \rschexpract \circseq \lschexpract InterpreterPop[oid!/value!] \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = putfield~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \\
        \t2 \circvar cid : ClassID \circspot cid := (classOf~currentClass~((putfield\inv)~(bc~pc))) \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract InterpreterPop \hide (pc,pc') \rschexpract \circseq \lschexpract InterpreterPop[oid!/value!] \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = putfield~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \\
        \t2 cid := (classOf~currentClass~((putfield\inv)~(bc~pc))) \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract InterpreterPop \hide (pc,pc') \rschexpract \circseq \lschexpract InterpreterPop[oid!/value!] \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = putfield~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \\
        \t2 cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract InterpreterPop \hide (pc,pc') \rschexpract \circseq \lschexpract InterpreterPop[oid!/value!] \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putfield~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \circseq cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar fid : FieldID \circspot
        fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot
        cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract InterpreterPop \hide (pc,pc') \rschexpract \circseq \lschexpract InterpreterPop[oid!/value!] \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar fid : FieldID \circspot
        fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot
        cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract InterpreterPop \hide (pc,pc') \rschexpract \circseq \lschexpract InterpreterPop[oid!/value!] \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar fid : FieldID \circspot
        fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot
        cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract InterpreterPop \hide (pc,pc') \rschexpract \circseq \lschexpract InterpreterPop[oid!/value!] \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-alt-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot
        cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract InterpreterPop \hide (pc,pc') \rschexpract \circseq \lschexpract InterpreterPop[oid!/value!] \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar fid : FieldID \circspot \\
        \t2 \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot
        cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract InterpreterPop \hide (pc,pc') \rschexpract \circseq \lschexpract InterpreterPop[oid!/value!] \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar fid : FieldID \circspot \\
        \t2 \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq \{ pc = i \} \circseq \\
        \t2 \circvar cid : ClassID \circspot
        cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract InterpreterPop \hide (pc,pc') \rschexpract \circseq \lschexpract InterpreterPop[oid!/value!] \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar fid : FieldID \circspot \\
        \t2 \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq
        cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract InterpreterPop \hide (pc,pc') \rschexpract \circseq \lschexpract InterpreterPop[oid!/value!] \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar fid : FieldID \circspot \\
        \t2 \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq
        cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \{ pc = i \} \circseq \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract InterpreterPop \hide (pc,pc') \rschexpract \circseq \lschexpract InterpreterPop[oid!/value!] \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar fid : FieldID \circspot \\
        \t2 \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq  \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq
        cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \{ pc = i \} \circseq \\
        \t2 \lschexpract InterpreterPop \hide (pc,pc') \rschexpract \circseq \lschexpract InterpreterPop[oid!/value!] \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Definition of $InterpreterPop$ \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar fid : FieldID \circspot \\
        \t2 \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq  \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq
        cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \{ pc = i \} \circseq \\
        \t2 \lschexpract (\exists \Delta StackFrame @ \\
        \t3 StackFramePop \land PromoteStackFrameOp) \hide (pc,pc') \rschexpract \circseq \\
        \t2 \lschexpract (\exists \Delta StackFrame @ \\
        \t3 StackFramePop \land PromoteStackFrameOp)[oid!/value!] \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & schema calculus \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar fid : FieldID \circspot \\
        \t2 \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq  \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq
        cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \{ pc = i \} \circseq \\
        \t2 \lschexpract \exists \Delta StackFrame @ \\
        \t3 StackFramePop \land (PromoteStackFrameOp \hide (pc,pc')) \rschexpract \circseq \\
        \t2 \lschexpract \exists \Delta StackFrame @ \\
        \t3 StackFramePop[oid!/value!] \land PromoteStackFrameOp \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Lemma~\ref{Handle-schema-refinement-lemma} \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar fid : FieldID \circspot \\
        \t2 \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq  \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq
        cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract \exists \Delta StackFrame @ \\
        \t3 StackFramePop \land (PromoteStackFrameOp \hide (pc,pc')) \rschexpract \circseq \\
        \t2 \lschexpract \exists \Delta StackFrame @ \\
        \t3 StackFramePop[oid!/value!] \land PromoteStackFrameOpEPC \rschexpract \circseq \\
        \t2 pc := i + 1 \circseq putField!oid!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assign-seq-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar fid : FieldID \circspot \\
        \t2 \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq  \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq
        cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract \exists \Delta StackFrame @ \\
        \t3 StackFramePop \land (PromoteStackFrameOp \hide (pc,pc')) \rschexpract \circseq \\
        \t2 \lschexpract \exists \Delta StackFrame @ \\
        \t3 StackFramePop[oid!/value!] \land PromoteStackFrameOpEPC \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \circseq pc := i + 1 \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{schema-action-fixed-var-intro-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar fid : FieldID \circspot \\
        \t2 \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq  \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq
        cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract \exists \Delta StackFrame @ \\
        \t3 StackFramePop \land (PromoteStackFrameOp \hide (pc,pc')) \land pc' = pc \rschexpract \circseq \\
        \t2 \lschexpract \exists \Delta StackFrame @ \\
        \t3 StackFramePop[oid!/value!] \land PromoteStackFrameOpEPC \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \circseq pc := i + 1 \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & schema calculus \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar fid : FieldID \circspot \\
        \t2 \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq  \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq
        cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract \exists \Delta StackFrame @ \\
        \t3 StackFramePop \land PromoteStackFrameOpEPC \rschexpract \circseq \\
        \t2 \lschexpract \exists \Delta StackFrame @ \\
        \t3 StackFramePop[oid!/value!] \land PromoteStackFrameOpEPC \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \circseq pc := i + 1 \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Defintion of $InterpreterPopEPC$ \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar fid : FieldID \circspot \\
        \t2 \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq  \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq
        cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract IntepreterPopEPC \rschexpract \circseq
        \lschexpract IntepreterPopEPC[oid!/value!] \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \circseq pc := i + 1 \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq  \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract IntepreterPopEPC \rschexpract \circseq
        \lschexpract IntepreterPopEPC[oid!/value!] \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \circseq pc := i + 1 \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{seq-zerol-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq  \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract IntepreterPopEPC \rschexpract \circseq
        \lschexpract IntepreterPopEPC[oid!/value!] \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \circseq pc := i + 1 \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \circseq pc := i + 1 \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{alt-seq-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq  \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract InterpreterPushEPC[value!/value1!,oid!/value2!] \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi \circseq pc := i + 1)
      \end{array}\\
      = & Law~[\nameref{var-seq-extr-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq  \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract IntepreterPopEPC \rschexpract \circseq
        \lschexpract IntepreterPopEPC[oid!/value!] \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi) \circseq pc := i + 1
      \end{array}\\
      = & Law~[\nameref{val-def-law}] \\
      \begin{array}{l}
        (\circval cpIndex : \nat \circspot \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq  \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar oid : ObjectID; value : Word \circspot \\
        \t2 \lschexpract IntepreterPopEPC \rschexpract \circseq
        \lschexpract IntepreterPopEPC[oid!/value!] \rschexpract \circseq \\
        \t2 putField!oid!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)(cpi) \circseq pc := i + 1
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and definition of $HandlePutfieldEPC$ \\
      \begin{array}{l}
        HandlePutfieldEPC(cpi) \circseq pc := i + 1
      \end{array}\\
      = & Definition of $handleAction$ and case assumption $bc~i = putfield~cpi$ \\
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}\\
    \end{argue}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 15: getstatic
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item Suppose $bc~i = getstatic~cpi$ then,
    \begin{argue}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}\\
      \circrefines_A & Similar to previous case \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = getstatic~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = getstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = getstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~((getstatic\inv)~(bc~pc)) \circseq \\
  \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~((getstatic\inv)~(bc~pc)) \circseq \\
  \t2 getStatic!cid!fid \then getStaticRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = getstatic~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-seq-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = getstatic~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = getstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = getstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 getStatic!cid!fid \then getStaticRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = getstatic~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \circseq cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 getStatic!cid!fid \then getStaticRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 getStatic!cid!fid \then getStaticRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 getStatic!cid!fid \then getStaticRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-alt-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 getStatic!cid!fid \then getStaticRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 getStatic!cid!fid \then getStaticRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq \\
        \t2 cid := classOf~currentClass~cpIndex \circseq \{ pc = i \} \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 getStatic!cid!fid \then getStaticRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq \\
        \t2 cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 getStatic!cid!fid \then getStaticRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq \\
        \t2 cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq \\
        \t2 fid := fieldOf~currentClass~cpIndex \circseq \{ pc = i \} \circseq \\
        \t2 getStatic!cid!fid \then getStaticRet?value \then \lschexpract InterpreterPush \rschexpract \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-output-prefix-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq \\
        \t2 cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq \\
        \t2 fid := fieldOf~currentClass~cpIndex \circseq \{ pc = i \} \circseq \\
        \t2 getStatic!cid!fid \then (\{ pc = i \} \circseq getStaticRet?value \\
        \t2 {} \then \lschexpract InterpreterPush \rschexpract) \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-input-prefix-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq \\
        \t2 cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq \\
        \t2 fid := fieldOf~currentClass~cpIndex \circseq \{ pc = i \} \circseq \\
        \t2 getStatic!cid!fid \then (\{ pc = i \} \circseq getStaticRet?value \\
        \t2 {} \then (\{ pc = i \} \circseq \lschexpract InterpreterPush \rschexpract)) \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Definition of $InterpreterPush$ \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq \\
        \t2 cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq \\
        \t2 fid := fieldOf~currentClass~cpIndex \circseq \{ pc = i \} \circseq \\
        \t2 getStatic!cid!fid \then (\{ pc = i \} \circseq getStaticRet?value \then (\{ pc = i \} \circseq \\
        \t2 \lschexpract \exists \Delta StackFrame @
        StackFramePush \land PromoteStackFrameOp \rschexpract)) \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Lemma~\ref{Handle-schema-refinement-lemma} \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq \\
        \t2 cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq \\
        \t2 fid := fieldOf~currentClass~cpIndex \circseq \{ pc = i \} \circseq \\
        \t2 getStatic!cid!fid \then (\{ pc = i \} \circseq getStaticRet?value \then {} \\
        \t2 (\lschexpract \exists \Delta StackFrame @ \\
        \t3 StackFramePush \land PromoteStackFrameOpEPC \rschexpract \circseq \\
        \t2 pc := i + 1)) \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Similar to case 12 \\
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}\\
    \end{argue}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 16: putstatic
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item Suppose $bc~i = putstatic~cpi$ then,
    \begin{argue}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}\\
      \circrefines_A & Similar to previous case \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = putstatic~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~((putstatic\inv)~(bc~pc)) \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~((putstatic\inv)~(bc~pc)) \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = putstatic~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar cid : ClassID \circspot \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t2 cid := classOf~currentClass~((putstatic\inv)~(bc~pc)) \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~((putstatic\inv)~(bc~pc)) \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = putstatic~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar cid : ClassID \circspot \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t2 cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~((putstatic\inv)~(bc~pc)) \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = putstatic~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar cid : ClassID \circspot \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t2 cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~((putstatic\inv)~(bc~pc)) \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = putstatic~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar cid : ClassID \circspot \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t2 cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t2 fid := fieldOf~currentClass~((putstatic\inv)~(bc~pc)) \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = putstatic~cpi\} \circseq cpIndex := cpi \circseq \\
        \t1 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \circvar cid : ClassID \circspot \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t2 cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \\
        \t2 fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen {} \\
        \t2 \{ pc \in \dom bc \land bc~pc = putstatic~cpi \land cpIndex = cpi \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-alt-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \{ pc = i \} \circseq \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{assump-assign-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \{ pc = i \} \circseq \circvar value : Word \circspot \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \{ pc = i \} \circseq \lschexpract InterpreterPop \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Definition of $InterpreterPop$ \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \{ pc = i \} \circseq \\
        \t2 \lschexpract \exists \Delta StackFrame @ StackFramePop \land PromoteStackFrameOp \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Lemma~\ref{Handle-schema-refinement-lemma} \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \\
        \t2 \lschexpract \exists \Delta StackFrame @ StackFramePop \land PromoteStackFrameOpEPC \rschexpract \circseq \\
        \t2 pc := i + 1 \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assign-seq-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \\
        \t2 \lschexpract \exists \Delta StackFrame @ StackFramePop \land PromoteStackFrameOpEPC \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \circseq pc := i + 1 \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Defintion of $InterpreterPopEPC$ \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot \{ pc = i \} \circseq cpIndex := cpi \circseq \{ pc = i \} \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot \{ pc = i \} \circseq cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot \{ pc = i \} \circseq fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPopEPC \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \circseq pc := i + 1 \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \{ pc = i \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPopEPC \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \circseq pc := i + 1 \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{seq-zerol-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPopEPC \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \circseq pc := i + 1 \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \circseq pc := i + 1 \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{alt-seq-dist-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPopEPC \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi \circseq pc := i + 1)
      \end{array}\\
      = & Law~[\nameref{var-seq-extr-law}] \\
      \begin{array}{l}
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPopEPC \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi) \circseq pc := i + 1
      \end{array}\\
      = & Law~[\nameref{val-def-law}] \\
      \begin{array}{l}
        (\circval cpIndex : \nat \circspot \\
        \t1 \circif cpIndex \in fieldRefIndices~currentClass \circthen {} \\
        \t2 \circvar cid : ClassID \circspot cid := classOf~currentClass~cpIndex \circseq \\
        \t2 \circvar fid : FieldID \circspot fid := fieldOf~currentClass~cpIndex \circseq \\
        \t2 \circvar value : Word \circspot \lschexpract InterpreterPopEPC \rschexpract \circseq \\
        \t2 putStatic!cid!fid!value \then \Skip \\
        \t1 {} \circelse cpIndex \notin fieldRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)(cpi) \circseq pc := i + 1
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and definition of $HandlePutstaticEPC$ \\
      \begin{array}{l}
        HandlePutstaticEPC(cpi) \circseq pc := i + 1
      \end{array}\\
      = & Definition of $handleAction$ and case assumption $bc~i = putstatic~cpi$ \\
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}\\
    \end{argue}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 17: invokevirtual
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \item Suppose $bc~i = invokevirtual~cpi$ for some $cpi \in \nat$ then,
    \begin{argue}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}\\
      \circrefines_A & Similar to previous cases \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = invokevirtual~cpi \} \circseq \\
        \t1 (\circvar cid : ClassID; mid : MethodID; poppedArgs : \seq Word \circspot \\
        \t1 \circif ((invokevirtual\inv)~(bc~pc)) \in methodRefIndices~currentClass \circthen {} \\
        \t2 mid := methodOf~currentClass~((invokevirtual\inv)~(bc~pc)) \circseq \\
        \t2 \lschexpract \exists argsToPop? == methodArguments~mid + 1 @\\
        \t3 InterpreterStackFrameInvoke \rschexpract \circseq \\
        \t2 getClassIDOf!(head~poppedArgs)?cid \\
        \t2 {} \then Invoke(cid, mid, poppedArgs, \false) \\
        \t1 {} \circelse ((invokevirtual\inv)~(bc~pc)) \notin methodRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-assign-intro-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = invokevirtual~cpi \} \circseq \\
        \t1 (\circvar cpIndex : \nat \circspot cpIndex := (invokevirtual\inv)~(bc~pc) \circseq \\
        \t1 \circvar cid : ClassID; mid : MethodID; poppedArgs : \seq Word \circspot \\
        \t1 \circif ((invokevirtual\inv)~(bc~pc)) \in methodRefIndices~currentClass \circthen {} \\
        \t2 mid := methodOf~currentClass~((invokevirtual\inv)~(bc~pc)) \circseq \\
        \t2 \lschexpract \exists argsToPop? == methodArguments~mid + 1 @ \\
        \t3 InterpreterStackFrameInvoke \rschexpract \circseq \\
        \t2 getClassIDOf!(head~poppedArgs)?cid \\
        \t2 {} \then Invoke(cid, mid, poppedArgs, \false) \\
        \t1 {} \circelse ((invokevirtual\inv)~(bc~pc)) \notin methodRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        \{ pc \in \dom bc \land bc~pc = invokevirtual~cpi \} \circseq  (\circvar cpIndex : \nat \circspot \\
        \t1 \circvar cid : ClassID; mid : MethodID; poppedArgs : \seq Word \circspot \\
        \t1 cpIndex := (invokevirtual\inv)~(bc~pc) \circseq \\
        \t1 \circif ((invokevirtual\inv)~(bc~pc)) \in methodRefIndices~currentClass \circthen {} \\
        \t2 mid := methodOf~currentClass~((invokevirtual\inv)~(bc~pc)) \circseq \\
        \t2 \lschexpract \exists argsToPop? == methodArguments~mid + 1 @ \\
        \t3 InterpreterStackFrameInvoke \rschexpract \circseq \\
        \t2 getClassIDOf!(head~poppedArgs)?cid \\
        \t2 {} \then Invoke(cid, mid, poppedArgs, \false) \\
        \t1 {} \circelse ((invokevirtual\inv)~(bc~pc)) \notin methodRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \circvar cid : ClassID; mid : MethodID; poppedArgs : \seq Word \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = invokevirtual~cpi \} \circseq \\
        \t1 cpIndex := (invokevirtual\inv)~(bc~pc) \circseq \\
        \t1 \circif ((invokevirtual\inv)~(bc~pc)) \in methodRefIndices~currentClass \circthen {} \\
        \t2 mid := methodOf~currentClass~((invokevirtual\inv)~(bc~pc)) \circseq \\
        \t2 \lschexpract \exists argsToPop? == methodArguments~mid + 1 @ \\
        \t3 InterpreterStackFrameInvoke \rschexpract \circseq \\
        \t2 getClassIDOf!(head~poppedArgs)?cid \\
        \t2 {} \then Invoke(cid, mid, poppedArgs, \false) \\
        \t1 {} \circelse ((invokevirtual\inv)~(bc~pc)) \notin methodRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
       = & Law~[\nameref{assign-seq-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \circvar cid : ClassID; mid : MethodID; poppedArgs : \seq Word \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = invokevirtual~cpi \} \circseq \\
        \t1 cpIndex := (invokevirtual\inv)~(bc~pc) \circseq \\
        \t1 \{ ((invokevirtual\inv)~(bc~pc)) = cpIndex \} \circseq \\
        \t1 \circif ((invokevirtual\inv)~(bc~pc)) \in methodRefIndices~currentClass \circthen {} \\
        \t2 mid := methodOf~currentClass~((invokevirtual\inv)~(bc~pc)) \circseq \\
        \t2 \lschexpract \exists argsToPop? == methodArguments~mid + 1 @ \\
        \t3 InterpreterStackFrameInvoke \rschexpract \circseq \\
        \t2 getClassIDOf!(head~poppedArgs)?cid \\
        \t2 {} \then Invoke(cid, mid, poppedArgs, \false) \\
        \t1 {} \circelse ((invokevirtual\inv)~(bc~pc)) \notin methodRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
       = & Law~[\nameref{assump-alt-guard-replace-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \circvar cid : ClassID; mid : MethodID; poppedArgs : \seq Word \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = invokevirtual~cpi \} \circseq \\
        \t1 cpIndex := (invokevirtual\inv)~(bc~pc) \circseq \\
        \t1 \{ ((invokevirtual\inv)~(bc~pc)) = cpIndex \} \circseq \\
        \t1 \circif cpIndex \in methodRefIndices~currentClass \circthen {} \\
        \t2 mid := methodOf~currentClass~((invokevirtual\inv)~(bc~pc)) \circseq \\
        \t2 \lschexpract \exists argsToPop? == methodArguments~mid + 1 @ \\
        \t3 InterpreterStackFrameInvoke \rschexpract \circseq \\
        \t2 getClassIDOf!(head~poppedArgs)?cid \\
        \t2 {} \then Invoke(cid, mid, poppedArgs, \false) \\
        \t1 {} \circelse cpIndex \notin methodRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
       = & Law~[\nameref{assump-alt-dist-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \circvar cid : ClassID; mid : MethodID; poppedArgs : \seq Word \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = invokevirtual~cpi \} \circseq \\
        \t1 cpIndex := (invokevirtual\inv)~(bc~pc) \circseq \\
        \t1 \{ ((invokevirtual\inv)~(bc~pc)) = cpIndex \} \circseq \\
        \t1 \circif cpIndex \in methodRefIndices~currentClass \circthen {} \\
        \t2 \{ ((invokevirtual\inv)~(bc~pc)) = cpIndex \} \circseq \\
        \t2 mid := methodOf~currentClass~((invokevirtual\inv)~(bc~pc)) \circseq \\
        \t2 \lschexpract \exists argsToPop? == methodArguments~mid + 1 @ \\
        \t3 InterpreterStackFrameInvoke \rschexpract \circseq \\
        \t2 getClassIDOf!(head~poppedArgs)?cid \\
        \t2 {} \then Invoke(cid, mid, poppedArgs, \false) \\
        \t1 {} \circelse cpIndex \notin methodRefIndices~currentClass \circthen {} \\
        \t2 \{ ((invokevirtual\inv)~(bc~pc)) = cpIndex \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
       = & Law~[\nameref{assump-seq-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \circvar cid : ClassID; mid : MethodID; poppedArgs : \seq Word \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = invokevirtual~cpi \} \circseq \\
        \t1 cpIndex := (invokevirtual\inv)~(bc~pc) \circseq \\
        \t1 \{ ((invokevirtual\inv)~(bc~pc)) = cpIndex \} \circseq \\
        \t1 \circif cpIndex \in methodRefIndices~currentClass \circthen {} \\
        \t2 \{ ((invokevirtual\inv)~(bc~pc)) = cpIndex \} \circseq \\
        \t2 mid := methodOf~currentClass~cpIndex \circseq \\
        \t2 \lschexpract \exists argsToPop? == methodArguments~mid + 1 @ \\
        \t3 InterpreterStackFrameInvoke \rschexpract \circseq \\
        \t2 getClassIDOf!(head~poppedArgs)?cid \\
        \t2 {} \then Invoke(cid, mid, poppedArgs, \false) \\
        \t1 {} \circelse cpIndex \notin methodRefIndices~currentClass \circthen {} \\
        \t2 \{ ((invokevirtual\inv)~(bc~pc)) = cpIndex \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
       = & Law~[\nameref{assump-seq-subst-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \circvar cid : ClassID; mid : MethodID; poppedArgs : \seq Word \circspot \\
        \t1 \{ pc \in \dom bc \land bc~pc = invokevirtual~cpi \} \circseq \\
        \t1 cpIndex := cpi \circseq \\
        \t1 \{ ((invokevirtual\inv)~(bc~pc)) = cpIndex \} \circseq \\
        \t1 \circif cpIndex \in methodRefIndices~currentClass \circthen {} \\
        \t2 \{ ((invokevirtual\inv)~(bc~pc)) = cpIndex \} \circseq \\
        \t2 mid := methodOf~currentClass~cpIndex \circseq \\
        \t2 \lschexpract \exists argsToPop? == methodArguments~mid + 1 @ \\
        \t3 InterpreterStackFrameInvoke \rschexpract \circseq \\
        \t2 getClassIDOf!(head~poppedArgs)?cid \\
        \t2 {} \then Invoke(cid, mid, poppedArgs, \false) \\
        \t1 {} \circelse cpIndex \notin methodRefIndices~currentClass \circthen {} \\
        \t2 \{ ((invokevirtual\inv)~(bc~pc)) = cpIndex \} \circseq \Chaos \\
        \t1 \circfi)
      \end{array}\\
      \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot \\
        \t1 \circvar cid : ClassID; mid : MethodID; poppedArgs : \seq Word \circspot \\
        \t1 cpIndex := cpi \circseq \\
        \t1 \circif (cpIndex \in methodRefIndices~currentClass \circthen {} \\
        \t2 mid := methodOf~currentClass~cpIndex \circseq \\
        \t2 \lschexpract \exists argsToPop? == methodArguments~mid + 1 @ \\
        \t3 InterpreterStackFrameInvoke \rschexpract \circseq \\
        \t2 getClassIDOf!(head~poppedArgs)?cid \\
        \t2 {} \then Invoke(cid, mid, poppedArgs, \false) \\
        \t1 {} \circelse (cpIndex \notin methodRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{var-seq-extl-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circvar cpIndex : \nat \circspot cpIndex := cpi \circseq \\
        \t1 \circvar cid : ClassID; mid : MethodID; poppedArgs : \seq Word \circspot \\
        \t1 \circif (cpIndex \in methodRefIndices~currentClass \circthen {} \\
        \t2 mid := methodOf~currentClass~cpIndex \circseq \\
        \t2 \lschexpract \exists argsToPop? == methodArguments~mid + 1 @ \\
        \t3 InterpreterStackFrameInvoke \rschexpract \circseq \\
        \t2 getClassIDOf!(head~poppedArgs)?cid \\
        \t2 {} \then Invoke(cid, mid, poppedArgs, \false) \\
        \t1 {} \circelse (cpIndex \notin methodRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)
      \end{array}\\
      = & Law~[\nameref{val-def-law}] \\
      \begin{array}{l}
        \{ pc = i \} \circseq
        (\circval cpIndex : \nat \circspot \\
        \t1 \circvar cid : ClassID; mid : MethodID; poppedArgs : \seq Word \circspot \\
        \t1 \circif (cpIndex \in methodRefIndices~currentClass \circthen {} \\
        \t2 mid := methodOf~currentClass~cpIndex \circseq \\
        \t2 \lschexpract \exists argsToPop? == methodArguments~mid + 1 @ \\
        \t3 InterpreterStackFrameInvoke \rschexpract \circseq \\
        \t2 getClassIDOf!(head~poppedArgs)?cid \\
        \t2 {} \then Invoke(cid, mid, poppedArgs, \false) \\
        \t1 {} \circelse (cpIndex \notin methodRefIndices~currentClass \circthen \Chaos \\
        \t1 \circfi)(cpi)
      \end{array}\\
      = & Law~[\nameref{copy-rule-law}] and definition of $HandleInvokevirtualEPC$ \\
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInvokevirtualEPC(cpi)
      \end{array}\\
      = & Definition of $handleAction$ and case assumption $bc~i = invokevirtual~cpi$ \\
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}\\
    \end{argue}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % Case 18: invokespecial
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \item Suppose $bc~i = invokespecial~cpi$ for some $cpi \in \nat$
    then, by similar reasoning to the previous case,
    % TODO: check if this needs modification to account for adding the
    % superclass check
    \begin{circus}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}
      \circrefines_A 
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}
    \end{circus}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
    % Case 19: invokestatic
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  \item Suppose $bc~i = invokestatic~cpi$ for some $cpi \in \nat$
    then, by similar reasoning to the previous case,
    \begin{circus}
      \begin{array}{l}
        \{ pc = i \} \circseq HandleInstruction_{bc}
      \end{array}
      \circrefines_A
      \begin{array}{l}
        handleAction~(bc~i)
      \end{array}
    \end{circus}
  \end{enumerate}
  Thus
  $\{ pc = i \} \circseq HandleInstruction \circrefines_A
  handleAction~(bc~i)$ so the rule holds.
\end{crproof}

\begin{crproof}[\nameref{CheckSynchronizedReturn-synchronized-refinement-rule}]
  \begin{argue}
    \begin{array}{l}
      \circif {} \cdots {} \\
        {} \circelse pc = i \circthen CheckSynchronizedReturn \circseq A \\
        {} \cdots {} \\
        \circfi
    \end{array}\\
    = & Law~[\nameref{alt-assump-intro-law}] \\
    \begin{array}{l}
      \circif {} \cdots {} \\
        {} \circelse pc = i \circthen \{ pc = i \} \circseq CheckSynchronizedReturn \circseq A \\
        {} \cdots {} \\
        \circfi
    \end{array}\\
    = & Law~[\nameref{assump-assump-intro-law} and assumption of rule] \\
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen \{ pc = i \} \circseq \\
      \t1 \{ \exists c : Class; m : MethodID | \\
      \t2 c \in \ran cs \land m \in \dom c.methodEntry @ \\
      \t2 p \in c.methodEntry~m \upto c.methodEnd~m \land \\
      \t2 m \in c.synchronisedMethods \land m \notin c.staticMethods \} \circseq \\
      \t1 CheckSynchronizedReturn \circseq A \\
        {} \cdots {} \\
        \circfi
    \end{array}\\
    = & Law~[\nameref{copy-rule-law} and definition of $CheckSynchronizedReturn$] \\
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen \{ pc = i \} \circseq \\
      \t1 \{ \exists c : Class; m : MethodID | \\
      \t2 c \in \ran cs \land m \in \dom c.methodEntry @ \\
      \t2 p \in c.methodEntry~m \upto c.methodEnd~m \land \\
      \t2 m \in c.synchronisedMethods \land m \notin c.staticMethods \} \circseq \\
      \t1 (\circvar methodID : MethodID \circspot \lschexpract GetCurrentMethod \rschexpract \circseq \\
      \t2 \circif methodID \in currentClass.synchronizedMethods \\
      \t3 {} \land methodID \notin currentClass.staticMethods \circthen {} \\
      \t3 releaseLock!((last~frameStack).localVariables~1) \\
      \t3 {} \then releaseLockRet \then \Skip \\
      \t2 {} \circelse methodID \notin currentClass.synchronizedMethods \\
      \t3 {} \lor methodID \in currentClass.staticMethods \circthen \Skip \\
      \t2 \circfi) \circseq A \\
      {} \cdots {} \\
      \circfi
    \end{array}\\
    = & Law~[\nameref{var-seq-extl-law}] \\
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen \{ pc = i \} \circseq \\
      \t1 (\circvar methodID : MethodID \circspot \\
      \t2 \{ \exists c : Class; m : MethodID | \\
      \t3 c \in \ran cs \land m \in \dom c.methodEntry @ \\
      \t3 p \in c.methodEntry~m \upto c.methodEnd~m \land \\
      \t3 m \in c.synchronisedMethods \land m \notin c.staticMethods \} \circseq \\
      \t2 \lschexpract GetCurrentMethod \rschexpract \circseq \\
      \t2 \circif methodID \in currentClass.synchronizedMethods \\
      \t3 {} \land methodID \notin currentClass.staticMethods \circthen {} \\
      \t3 releaseLock!((last~frameStack).localVariables~1) \\
      \t3 {} \then releaseLockRet \then \Skip \\
      \t2 {} \circelse methodID \notin currentClass.synchronizedMethods \\
      \t3 {} \lor methodID \in currentClass.staticMethods \circthen \Skip \\
      \t2 \circfi) \circseq A \\
      {} \cdots {} \\
      \circfi
    \end{array}\\
    = & Law~[Definition of $GetCurrentMethod$] \\
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen \{ pc = i \} \circseq \\
      \t1 (\circvar methodID : MethodID \circspot \\
      \t2 \{ \exists c : Class; m : MethodID | \\
      \t3 c \in \ran cs \land m \in \dom c.methodEntry @ \\
      \t3 p \in c.methodEntry~m \upto c.methodEnd~m \land \\
      \t3 m \in c.synchronisedMethods \land m \notin c.staticMethods \} \circseq \\
      \t2 \lschexpract [\Xi InterpreterState; methodID! : MethodID | \\
      \t3 methodID! = (\mu m : \dom currentClass.methodEntry | \\
      \t4 pc \in currentClass.methodEntry~m \upto currentClass.methodEnd~m)] \rschexpract \circseq \\
      \t2 \circif methodID \in currentClass.synchronizedMethods \\
      \t3 {} \land methodID \notin currentClass.staticMethods \circthen {} \\
      \t3 releaseLock!((last~frameStack).localVariables~1) \\
      \t3 {} \then releaseLockRet \then \Skip \\
      \t2 {} \circelse methodID \notin currentClass.synchronizedMethods \\
      \t3 {} \lor methodID \in currentClass.staticMethods \circthen \Skip \\
      \t2 \circfi) \circseq A \\
      {} \cdots {} \\
      \circfi
    \end{array}\\
    \circrefines_A & Law~[\nameref{assump-schema-dist-law}] and schema calculus \\
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen \{ pc = i \} \circseq \\
      \t1 (\circvar methodID : MethodID \circspot \\
      \t2 \lschexpract [\Xi InterpreterState; methodID! : MethodID | \\
      \t3 methodID! = (\mu m : \dom currentClass.methodEntry | \\
      \t4 pc \in currentClass.methodEntry~m \upto currentClass.methodEnd~m)] \rschexpract \circseq \\
      \t2 \{methodID \in currentClass.synchronisedMethods \\
      \t3 {} \land methodID \notin currentClass.staticMethods \} \circseq \\
      \t2 \circif methodID \in currentClass.synchronizedMethods \\
      \t3 {} \land methodID \notin currentClass.staticMethods \circthen {} \\
      \t3 releaseLock!((last~frameStack).localVariables~1) \\
      \t3 {} \then releaseLockRet \then \Skip \\
      \t2 {} \circelse methodID \notin currentClass.synchronizedMethods \\
      \t3 {} \lor methodID \in currentClass.staticMethods \circthen \Skip \\
      \t2 \circfi) \circseq A \\
      {} \cdots {} \\
      \circfi
    \end{array}\\
    = & Definition of $GetCurrentMethod$ \\
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen \{ pc = i \} \circseq \\
      \t1 (\circvar methodID : MethodID \circspot \\
      \t2 \lschexpract GetCurrentMethod \rschexpract \circseq \\
      \t2 \{methodID \in currentClass.synchronisedMethods \\
      \t3 {} \land methodID \notin currentClass.staticMethods \} \circseq \\
      \t2 \circif methodID \in currentClass.synchronizedMethods \\
      \t3 {} \land methodID \notin currentClass.staticMethods \circthen {} \\
      \t3 releaseLock!((last~frameStack).localVariables~1) \\
      \t3 {} \then releaseLockRet \then \Skip \\
      \t2 {} \circelse methodID \notin currentClass.synchronizedMethods \\
      \t3 {} \lor methodID \in currentClass.staticMethods \circthen \Skip \\
      \t2 \circfi) \circseq A \\
      {} \cdots {} \\
      \circfi
    \end{array}\\
    = & Law~[\nameref{assump-alt-collapse1-law}] \\
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen \{ pc = i \} \circseq \\
      \t1 (\circvar methodID : MethodID \circspot \\
      \t2 \lschexpract GetCurrentMethod \rschexpract \circseq \\
      \t2 \{methodID \in currentClass.synchronisedMethods \\
      \t3 {} \land methodID \notin currentClass.staticMethods \} \circseq \\
      \t2 releaseLock!((last~frameStack).localVariables~1) \\
      \t2 {} \then releaseLockRet \then \Skip) \circseq A \\
      {} \cdots {} \\
      \circfi
    \end{array}\\
    \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen (\circvar methodID : MethodID \circspot \lschexpract GetCurrentMethod \rschexpract \circseq \\
      \t1 releaseLock!((last~frameStack).localVariables~1) \\
      \t1 {} \then releaseLockRet \then \Skip) \circseq A \\
      {} \cdots {} \\
      \circfi
    \end{array}\\
    = & Law~[\nameref{var-schema-intro-law}] and definition of $GetCurrentMethod$ \\
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen releaseLock!((last~frameStack).localVariables~1) \\
      \t1 {} \then releaseLockRet \then \Skip) \circseq A \\
      {} \cdots {} \\
      \circfi
    \end{array}
  \end{argue}
\end{crproof}


\begin{crproof}[\nameref{CheckSynchronizedReturn-nonsynchronized-refinement-rule}]
  \begin{argue}
    \begin{array}{l}
      \circif {} \cdots {} \\
        {} \circelse pc = i \circthen CheckSynchronizedReturn \circseq A \\
        {} \cdots {} \\
        \circfi
    \end{array}\\
    = & Law~[\nameref{alt-assump-intro-law}] \\
    \begin{array}{l}
      \circif {} \cdots {} \\
        {} \circelse pc = i \circthen \{ pc = i \} \circseq CheckSynchronizedReturn \circseq A \\
        {} \cdots {} \\
        \circfi
    \end{array}\\
    = & Law~[\nameref{assump-assump-intro-law} and assumption of rule] \\
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen \{ pc = i \} \circseq \\
      \t1 \{ \exists c : Class; m : MethodID | \\
      \t2 c \in \ran cs \land m \in \dom c.methodEntry @ \\
      \t2 p \in c.methodEntry~m \upto c.methodEnd~m \land \\
      \t2 m \notin c.synchronisedMethods \lor m \in c.staticMethods \} \circseq \\
      \t1 CheckSynchronizedReturn \circseq A \\
        {} \cdots {} \\
        \circfi
    \end{array}\\
    = & Law~[\nameref{copy-rule-law} and definition of $CheckSynchronizedReturn$] \\
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen \{ pc = i \} \circseq \\
      \t1 \{ \exists c : Class; m : MethodID | \\
      \t2 c \in \ran cs \land m \in \dom c.methodEntry @ \\
      \t2 p \in c.methodEntry~m \upto c.methodEnd~m \land \\
      \t2 m \notin c.synchronisedMethods \lor m \in c.staticMethods \} \circseq \\
      \t1 (\circvar methodID : MethodID \circspot \lschexpract GetCurrentMethod \rschexpract \circseq \\
      \t2 \circif methodID \in currentClass.synchronizedMethods \\
      \t3 {} \land methodID \notin currentClass.staticMethods \circthen {} \\
      \t3 releaseLock!((last~frameStack).localVariables~1) \\
      \t3 {} \then releaseLockRet \then \Skip \\
      \t2 {} \circelse methodID \notin currentClass.synchronizedMethods \\
      \t3 {} \lor methodID \in currentClass.staticMethods \circthen \Skip \\
      \t2 \circfi) \circseq A \\
      {} \cdots {} \\
      \circfi
    \end{array}\\
    = & Law~[\nameref{var-seq-extl-law}] \\
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen \{ pc = i \} \circseq \\
      \t1 (\circvar methodID : MethodID \circspot \\
      \t2 \{ \exists c : Class; m : MethodID | \\
      \t3 c \in \ran cs \land m \in \dom c.methodEntry @ \\
      \t3 p \in c.methodEntry~m \upto c.methodEnd~m \land \\
      \t3 m \notin c.synchronisedMethods \lor m \in c.staticMethods \} \circseq \\
      \t2 \lschexpract GetCurrentMethod \rschexpract \circseq \\
      \t2 \circif methodID \in currentClass.synchronizedMethods \\
      \t3 {} \land methodID \notin currentClass.staticMethods \circthen {} \\
      \t3 releaseLock!((last~frameStack).localVariables~1) \\
      \t3 {} \then releaseLockRet \then \Skip \\
      \t2 {} \circelse methodID \notin currentClass.synchronizedMethods \\
      \t3 {} \lor methodID \in currentClass.staticMethods \circthen \Skip \\
      \t2 \circfi) \circseq A \\
      {} \cdots {} \\
      \circfi
    \end{array}\\
    = & Law~[Definition of $GetCurrentMethod$] \\
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen \{ pc = i \} \circseq \\
      \t1 (\circvar methodID : MethodID \circspot \\
      \t2 \{ \exists c : Class; m : MethodID | \\
      \t3 c \in \ran cs \land m \in \dom c.methodEntry @ \\
      \t3 p \in c.methodEntry~m \upto c.methodEnd~m \land \\
      \t3 m \notin c.synchronisedMethods \lor m \in c.staticMethods \} \circseq \\
      \t2 \lschexpract [\Xi InterpreterState; methodID! : MethodID | \\
      \t3 methodID! = (\mu m : \dom currentClass.methodEntry | \\
      \t4 pc \in currentClass.methodEntry~m \upto currentClass.methodEnd~m)] \rschexpract \circseq \\
      \t2 \circif methodID \in currentClass.synchronizedMethods \\
      \t3 {} \land methodID \notin currentClass.staticMethods \circthen {} \\
      \t3 releaseLock!((last~frameStack).localVariables~1) \\
      \t3 {} \then releaseLockRet \then \Skip \\
      \t2 {} \circelse methodID \notin currentClass.synchronizedMethods \\
      \t3 {} \lor methodID \in currentClass.staticMethods \circthen \Skip \\
      \t2 \circfi) \circseq A \\
      {} \cdots {} \\
      \circfi
    \end{array}\\
    \circrefines_A & Law~[\nameref{assump-schema-dist-law}] and schema calculus \\
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen \{ pc = i \} \circseq \\
      \t1 (\circvar methodID : MethodID \circspot \\
      \t2 \lschexpract [\Xi InterpreterState; methodID! : MethodID | \\
      \t3 methodID! = (\mu m : \dom currentClass.methodEntry | \\
      \t4 pc \in currentClass.methodEntry~m \upto currentClass.methodEnd~m)] \rschexpract \circseq \\
      \t2 \{methodID \notin currentClass.synchronisedMethods \\
      \t3 {} \lor methodID \in currentClass.staticMethods \} \circseq \\
      \t2 \circif methodID \in currentClass.synchronizedMethods \\
      \t3 {} \land methodID \notin currentClass.staticMethods \circthen {} \\
      \t3 releaseLock!((last~frameStack).localVariables~1) \\
      \t3 {} \then releaseLockRet \then \Skip \\
      \t2 {} \circelse methodID \notin currentClass.synchronizedMethods \\
      \t3 {} \lor methodID \in currentClass.staticMethods \circthen \Skip \\
      \t2 \circfi) \circseq A \\
      {} \cdots {} \\
      \circfi
    \end{array}\\
    = & Definition of $GetCurrentMethod$ \\
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen \{ pc = i \} \circseq \\
      \t1 (\circvar methodID : MethodID \circspot \\
      \t2 \lschexpract GetCurrentMethod \rschexpract \circseq \\
      \t2 \{methodID \notin currentClass.synchronisedMethods \\
      \t3 {} \lor methodID \in currentClass.staticMethods \} \circseq \\
      \t2 \circif methodID \in currentClass.synchronizedMethods \\
      \t3 {} \land methodID \notin currentClass.staticMethods \circthen {} \\
      \t3 releaseLock!((last~frameStack).localVariables~1) \\
      \t3 {} \then releaseLockRet \then \Skip \\
      \t2 {} \circelse methodID \notin currentClass.synchronizedMethods \\
      \t3 {} \lor methodID \in currentClass.staticMethods \circthen \Skip \\
      \t2 \circfi) \circseq A \\
      {} \cdots {} \\
      \circfi
    \end{array}\\
    = & Law~[\nameref{assump-alt-collapse1-law}] \\
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen \{ pc = i \} \circseq \\
      \t1 (\circvar methodID : MethodID \circspot \\
      \t2 \lschexpract GetCurrentMethod \rschexpract \circseq \\
      \t2 \{methodID \notin currentClass.synchronisedMethods \\
      \t3 {} \lor methodID \in currentClass.staticMethods \} \circseq \\
      \t2 \Skip) \circseq A \\
      {} \cdots {} \\
      \circfi
    \end{array}\\
    \circrefines_A & Law~[\nameref{assump-elim-law}] and Law~[\nameref{seq-unitl-law}] \\
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen (\circvar methodID : MethodID \circspot \lschexpract GetCurrentMethod \rschexpract \circseq \\
      \t1 \Skip) \circseq A \\
      {} \cdots {} \\
      \circfi
    \end{array}\\
    = & Law~[\nameref{var-schema-intro-law}] and definition of $GetCurrentMethod$ \\
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen \Skip \circseq A \\
      {} \cdots {} \\
      \circfi
    \end{array}
    = & Law~[\nameref{seq-unitl-law}] \\
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \circthen A \\
      {} \cdots {} \\
      \circfi
    \end{array}
  \end{argue}
\end{crproof}
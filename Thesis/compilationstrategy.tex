\chapter{Compilation Strategy}
\label{strategy-chapter}

In this chapter we describe our compilation strategy for refining SCJ
bytecode to C code.
We begin in Section~\ref{compilation-overview-section} with an
overview of our compilation strategy.
Then, in Section~\ref{compilation-assumptions-section} we describe the
requirements on the source program for the compilation strategy to be
applied.
Afterwards, we describe each stage of the strategy in a separate
section.
The first stage, which we call \emph{Elimination of Program Counter},
is described in Section~\ref{elimination-of-program-counter-section}.
The second stage, called \emph{Elimination of Frame Stack}, is
described in Section~\ref{elimination-of-frame-stack-section}.
Finally, the third stage of the strategy, which is called \emph{Data
  Refinement of Objects}, is described in
Section~\ref{data-refinement-of-objects-section}.
We then conclude with some final considerations in
Section~\ref{compilation-final-considerations-section}.

\section{Overview}
\label{compilation-overview-section}

Our compilation strategy refines the $CEE(bc,cs,sid, initOrder)$
process defined in Section~\ref{cee-interpreter-section} to obtain the
$CCEE_{bc,cs}(sid, initOrder)$ process in
Section~\ref{cee-c-code-section}.
The overall theorem for the strategy, and, therefore, the main result
presented in this chapter, is as follows.
\begin{thm}[Compilation Strategy]\label{main-theorem}
  Given $bc$, $cs$ and $sid$, there are processes $StructMan_{cs}$ and
  $CProg_{bc,cs}$ such that,
  \begin{circus}
    CEE(bc,cs,sid,initOrder) \circrefines StructMan_{cs} \parallel
    CProg_{bc,cs} \parallel Launcher(sid, initOrder).
  \end{circus}
\end{thm}
$StructMan_{cs}$ manages objects represented by C structs that
incorporate the class information from $cs$, refining the process
$ObjMan$, which handles abstract objects.
$CProg_{bc,cs}$ refines the $Interpreter$, with the $Thr$ processes
refined into the $CThr_{bc,cs}$ processes described in
Section~\ref{cee-c-program-subsection}.
This means that the threads from SCJ are mapped onto threads in C,
since we do not dictate a particular thread switch mechanism in either
the source or target models.

The compilation strategy is split into three stages.
Each stage has a theorem describing it, for which the strategy acts as
a proof.
The proof of Theorem~\ref{main-theorem}, presented in
Section~\ref{main-theorem-proof-section}, is obtained by an
application of the theorems for each stage.
Each stage of the compilation strategy handles a different part of the
$Interpreter$ state:~the $pc$, the $frameStack$, and objects.
They operate over each of the $Thr$ processes, managed by the SCJVM
services.

The first stage, \emph{Elimination of Program Counter}, introduces the
control constructs of the C code.
This removes the use of $pc$ to determine the control flow of the
program.
The choice over $pc$ values is replaced with a choice over method
identifiers pointing to sequences of operations representing method
bodies.

In the second stage, \emph{Elimination of Frame Stack}, the
information contained on the $frameStack$, which is the local variable
array and operand stack for each method, is introduced in the C code.
This is done by introducing variables and parameters to represent each
method's local variables and operand stack slots.
A data refinement is then used to transform each operation over the
$frameStack$ to operate on the new variables.
The $frameStack$ is then eliminated from the state.

In the final stage, \emph{Data Refinement of Objects}, the class
information from $cs$ is used to create a representation of C structs.
This means that $ObjMan$, which has a very abstract representation of
objects, is transformed into $StructMan$.
The process for each thread is then changed to access the structs for
the objects in a more concrete way that represents the way struct
fields are accessed in C code.

% This yields final method actions of a form similar to that of the
% example shown below, which is taken from the \texttt{InputHandler}
% presented in Section~\ref{model-section}.
% \begin{circusaction}
%   InputHandler\_HandleAsyncEvent \circdef \\
%   \t1 \circval var0 \circspot \circvar var1, stack0, stack1 : Word \circspot \\
%   \t1 stack0 := var0 \circseq Poll \circseq getObject!stack0 \then getObjectRet?struct \\
%   \t1 {} \then stack0 := (castInputHandler~struct).input \circseq \dots
% \end{circusaction}
% The \texttt{handleAsyncEvent()} method of \texttt{InputHandler} is
% compiled to the action $InputHandler\_HandleAsyncEvent$, with the
% implicit \texttt{this} parameter represented as a value parameter
% $var0$.
% The local variable ($var1$) and stack slots ($stack0$ and $stack1$)
% are represented as \Circus{} variables.
% The operations of the C code are composed in sequence, with an action
% named $Poll$ that polls for thread switches present at the points
% where thread switches may occur. 
% Stack operations are represented as assignments. 
% For instance, $stack0 := var0$ arises from the compilation to load a
% local variable into a stack slot.
% Access to objects is performed by communicating with $StructMan_{cs}$
% to obtain the struct for the object, then casting it to the correct
% type, and accessing the required value.
% Above, we obtain the value of the $input$ field from an $InputHandler$
% object.
% The communication with $StructMan_{cs}$ is performed via the
% $getObject$ channel and the function $castInputHandler$ is used to map
% the $ObjectStruct$ returned from the communication to a type
% representing an object of \texttt{InputHandler}.

\section{Assumptions about source bytecode}
\label{compilation-assumptions-section}

For our strategy to be successfully applied to bytecodes corresponding
to an SCJ program, it must meet some basic requirements that ensure it
is well-formed.
Firstly, the program must pass JVM bytecode verification.
This means it must be type-correct and that execution remains inside
the array of bytecode instructions for each method.
This can be checked before execution of the program and there has
already been much work on formal verification of bytecode
verifiers~\cite{coglio2000,klein2003,xavier2003}.

Secondly, since SCJ does not allow dynamic class loading, all required
classes and methods must be present before execution of the program.
This means that the $cs$ map provided as input to the CEE must contain
all the classes referenced by any other class in $cs$.
All the bytecode instructions required for these classes must also be
present in the $bc$ map.
Our CEE model diverges if any of these requirements is not met, so
these requirements hold for any SCJ program that executes correctly in
our SCJVM interpreter.

Thirdly, due to the nature of the applications that SCJ is aimed at,
it is important that they have a structure that is readable and
facilitates verification.
MISRA-C includes such a restriction on structure and, since we are
generating C code for a safety-critical application, we aim to produce
code that is compatible with MISRA-C.
This means that the SCJ bytecode program used as input to the strategy
must also have a control structure compatible with the requirements of
MISRA-C.

\begin{figure}
  \begin{subfigure}{0.26\textwidth}
    \begin{center}
      \begin{tikzpicture}
        \useasboundingbox (-0.5,-1) rectangle (0.5,2);
        \node at (0,1.7) (start) {};
        \node at (0,1)  (A) {$\bullet$};
        \node at (0,-1) (B) {$\bullet$};
        \draw[-latex] (start) -- (A);
        \draw[-latex] (A) -- (B);
      \end{tikzpicture}
    \end{center}
    \caption{sequential composition}
    \label{sequence-figure}
  \end{subfigure}
  \begin{subfigure}{0.23\textwidth}
    \begin{center}
      \begin{tikzpicture}
        \useasboundingbox (-1,-1) rectangle (0,2);
        \node at (0,1.7) (start) {};
        \node at (0,1)  (A) {$\bullet$};
        \node at (-1,0) (B) {$\bullet$};
        \node at (0,-1) (C) {$\bullet$};
        \draw[-latex] (start) -- (A);
        \draw[-latex] (A) -- (B);
        \draw[-latex] (A) -- (C);
        \draw[-latex] (B) -- (C);
      \end{tikzpicture}
    \end{center}
    \caption{\texttt{if} conditional}
    \label{if-figure}
  \end{subfigure}
  \begin{subfigure}{0.23\textwidth}
    \begin{center}
      \begin{tikzpicture}
        \useasboundingbox (-1,-1) rectangle (1,2);
        \node at (0,1.7) (start) {};
        \node at (0,1)  (A) {$\bullet$};
        \node at (1,0)  (B) {$\bullet$};
        \node at (-1,0) (C) {$\bullet$};
        \node at (0,-1) (D) {$\bullet$};
        \draw[-latex] (start) -- (A);
        \draw[-latex] (A) -- (B);
        \draw[-latex] (A) -- (C);
        \draw[-latex] (B) -- (D);
        \draw[-latex] (C) -- (D);
      \end{tikzpicture}
    \end{center}
    \caption{\texttt{if}-\texttt{else} conditional}
    \label{if-else-figure}
  \end{subfigure}
  \begin{subfigure}{0.23\textwidth}
    \begin{center}
      \begin{tikzpicture}
        \useasboundingbox (-1,0) rectangle (1,3);
        \node at (0,1.7) (start) {};
        \node at (0,1)  (A) {$\bullet$};
        \node at (1,0)  (B) {$\bullet$};
        \node at (-1,0) (C) {$\bullet$};
        \draw[-latex] (start) -- (A);
        \draw[-latex] (A) -- (B);
        \draw[-latex] (A) -- (C);
      \end{tikzpicture}
    \end{center}
    \caption{divergent conditional}
    \label{divergent-figure}
  \end{subfigure} 
  \\
  \begin{subfigure}{0.33\textwidth}
    \begin{center}
      \begin{tikzpicture}
        \useasboundingbox (-1,-1) rectangle (1,2);
        \node at (0,1.7) (start) {};
        \node at (0,1) (A) {$\bullet$};
        \node at (0,-1) (B) {$\bullet$};
        \node at (1,-1) (C) {$\bullet$};
        \draw[-latex] (start) -- (A);
        \draw[-latex] (A) to (B);
        \draw[-latex] (A) to (C);
        \draw[-latex] (B) to[in=200,out=150] (A);
      \end{tikzpicture}
    \end{center}
    \caption{\texttt{while} loop}
    \label{while-figure}
  \end{subfigure}
  \begin{subfigure}{0.33\textwidth}
    \begin{center}
      \begin{tikzpicture}
        \useasboundingbox (-1,0) rectangle (1,3);
        \node at (0,1.7) (start) {};
        \node at (0,1)  (A) {$\bullet$};
        \node at (1,0)  (B) {$\bullet$};
        \draw[-latex] (start) -- (A);
        \draw[-latex] (A) to (B);
        \draw[-latex] (A) to[out=235,in=180,looseness=10] (A);
      \end{tikzpicture}
    \end{center}
    \caption{\texttt{do}-\texttt{while} loop}
    \label{do-while-figure}
  \end{subfigure}
  \begin{subfigure}{0.33\textwidth}
    \begin{center}
      \begin{tikzpicture}
        \useasboundingbox (-1,0) rectangle (1,3);
        \node at (0,1.7) (start) {};
        \node at (0,1)  (A) {$\bullet$};
        \draw[-latex] (start) -- (A);
        \draw[-latex] (A) to[out=270,in=180,looseness=10] (A);
      \end{tikzpicture}
    \end{center}
    \caption{infinite loop}
    \label{infinite-loop-figure}
  \end{subfigure}
  \caption{Control flow graphs of program structures}
  \label{structured-cfg-figures}
\end{figure}

Precisely, we require the control flow graph of each method in the
input program to have a structure based on Dijkstra's notion of
program structure found in~\cite{dijkstra1972}.
In our definition of a structured program, the control flow graph must
be composed of the structures shown in
Figure~\ref{structured-cfg-figures}. 
The first structure (Figure~\ref{sequence-figure}) is that of simple
sequential composition, with an edge going from the root node to a
single end node.
The next three structures
(Figure~\ref{if-figure}--\subref{divergent-figure}) are conditional
structures. 
Figure~\ref{if-figure} shows an \texttt{if} statement with no
\texttt{else} clause. 
Figure~\ref{if-else-figure} shows an \texttt{if} statement with an
\texttt{else} clause. 
Figure~\ref{divergent-figure} shows a conditional in which both
branches end with a (infinite) loop or a return so that there is
nothing following the conditional; we refer to such conditionals as
divergent conditionals since the branches do not come back together.
The remaining three structures
(Figure~\ref{while-figure}--\subref{infinite-loop-figure}) are all
loops.
Figure~\ref{while-figure} shows a loop in which the loop condition is
checked at the beginning (a \texttt{while} loop).
Figure~\ref{do-while-figure} show a loop in which the loop condition
is checked at the end (a \texttt{do}-\texttt{while} loop).
Figure~\ref{infinite-loop-figure} shows an infinite loop.

We provide below a formal definition of what it means for a control
flow graph to be structured. 
This definition is based on that in~\cite{bento2017}, which provides
an algorithm for recognising structured graphs.
We first define a rooted directed graph below. 
The definition is standard, but we include it here to introduce the
terminology for the subsequent definition.
\begin{defn}[Rooted Directed Graph] A \emph{rooted directed graph},
$G$, is a triple $(V,E,r)$, where
  \begin{itemize}
  \item $V$ is a set of \emph{nodes},
  \item $E$ is a set of ordered pairs of nodes in $V$, called
\emph{edges}, and
  \item $r$ is a node in $V$, called the \emph{root} of the graph.
  \end{itemize}
  The first component of an edge is its \emph{source}
  and the second component is its \emph{target}. 
  We say that an edge goes from its source to its target. 
  For every node $n \in V$, the pair $(r,n)$ must be in the reflexive
  transitive closure of $E$, that is, there must be a path of edges
  from the root to any node in the graph.
  For a graph $G$, we refer to the set
  $T(G) = \{ n \in V | \forall m \in V.\; (n,m) \notin E\}$ of nodes
  with no edges coming from them as the set of \emph{end nodes} of the
  graph.
\end{defn}
In diagrams we represent the nodes as points or as the names of the
nodes, the edges as arrows, and the root node as a node with an arrow
pointing to it that does not come from another node.
Additionally, we refer to the source of an edge going to a given node
as a \emph{predecessor} of that node; similarly, the target of an edge
from a given node is a \emph{successor} of that node.

We now define what it means to replace a node in a graph by another
graph.
We use this concept to construct more complex structured graphs from
those shown in Figure~\ref{structured-cfg-figures}.
Node replacement may occur in four different ways, depending on which
node is being replaced in a graph.
We illustrate the different cases of node replacement using the
example graphs $G$ and $H$ shown in Figure~\ref{G-H-examples-figure}.
The $G$ graph has the form of a conditional with two branches, and the
$H$ graph has the form of a \texttt{while} loop.
We label the nodes of the graphs separately for ease of reference.

\begin{figure}
  \begin{center}
    \begin{tikzpicture}
      \useasboundingbox (-3,-2) rectangle (2,2);
      \node at (-1,2) {$G$};
      \node at (0,1.7) (start) {};
      \node at (0,1)  (A) {$1$};
      \node at (1,0)  (B) {$2$};
      \node at (-1,0) (C) {$3$};
      \node at (0,-1) (D) {$4$};
      \draw[-latex] (start) -- (A);
      \draw[-latex] (A) -- (B);
      \draw[-latex] (A) -- (C);
      \draw[-latex] (B) -- (D);
      \draw[-latex] (C) -- (D);
    \end{tikzpicture}
    \begin{tikzpicture}
      \useasboundingbox (-3,-2) rectangle (2,2);
      \node at (-1,2) {$H$};
      \node at (0,1.7) (start) {};
      \node at (0,1) (A) {$a$};
      \node at (0,-1) (B) {$b$};
      \node at (1,-1) (C) {$c$};
      \draw[-latex] (start) -- (A);
      \draw[-latex] (A) to (B);
      \draw[-latex] (A) to (C);
      \draw[-latex] (B) to[in=200,out=150] (A);
    \end{tikzpicture}
    \caption{Example control flow graphs to illustrate node
      replacement}
    \label{G-H-examples-figure}
  \end{center}
\end{figure}

The first case is that of placing a graph at the start of another
graph, i.e.\ replacing the root node of a graph that does not have a
loop to its root node.
An example of this can be seen in
Figure~\ref{root-replacement-figure}, where the root node (node $1$)
of graph $G$ is replaced with graph $H$.
The unique end node of graph $H$, node $c$, takes the place of node
$1$.
The other nodes of $H$ are connected to it by the same edges as in
$H$.

The second case is that of replacing one of the end nodes of a graph.
This is shown in Figure~\ref{end-replacement-figure}, where node $4$
of graph $G$ is replaced with graph $H$.
Node $a$, the root node of graph $H$, takes the place of node $4$.
As in the previous case, the remaining nodes of $H$ are included,
connected to $a$ by the same edges as in $H$.

The third case (Figure~\ref{internal-replacement-figure}) is that of
replacing an internal node of the graph.
In our example, node $2$ of graph $G$ is replaced with graph $H$.
There is an edge from the predecessor of node $2$, which is node $1$
in this case, to the root node of $H$ (node $a$).
There is another edge from the end node of $H$ (node $c$), which is
required to be unique, to the successor of node $3$, which is node $4$
in this case.

The final case, an example of which is shown in
Figure~\ref{branch-end-replacement-figure}, is where control flow
constructs occur at the end of one branch of a conditional.
In our example, node $2$ of graph $G$ is replaced with graph $H$, as
in the previous case, but the end node of $H$ (node $c$) is identified
with the successor of node $2$ (node $4$), and so it is not included
in the graph.
Thus, this represents the case in which no instructions occur inside
the conditional branch after the while loop.
Such instructions are represented by node $c$ in
Figure~\ref{internal-replacement-figure}, which is excluded in
Figure~\ref{branch-end-replacement-figure}.

\begin{figure}
  \begin{subfigure}{0.24\textwidth}
    \begin{center}
      \begin{tikzpicture}
        \useasboundingbox (-1.5,-2.5) rectangle (1.5,2);
        \node at (0,2) (start) {};
        \node at ( 0, 1)  (A) {$a$};
        \node at (-1, 0)  (B) {$b$};
        \node at ( 0,0)   (D) {$c$};
        \node at (-1,-1)  (E) {$2$};
        \node at ( 1,-1)  (F) {$3$};
        \node at ( 0,-2)  (G) {$4$};
        \draw[-latex] (start) -- (A);
        \draw[-latex] (A) to (B);
        \draw[-latex] (A) to (D);
        \draw[-latex] (B) to[in=180,out=90] (A);
        \draw[-latex] (D) -- (E);
        \draw[-latex] (D) -- (F);
        \draw[-latex] (E) -- (G);
        \draw[-latex] (F) -- (G);
      \end{tikzpicture}
    \caption{\centering root node\newline replacement}
    \label{root-replacement-figure}
  \end{center}
  \end{subfigure}
  \begin{subfigure}{0.24\textwidth}
    \begin{center}
      \begin{tikzpicture}
        \useasboundingbox (-1.5,-2.5) rectangle (1.5,2);
        \node at (0,2) (start) {};
        \node at ( 0, 1)  (A) {$1$};
        \node at (-1, 0)  (B) {$2$};
        \node at ( 1, 0)  (C) {$3$};
        \node at ( 0,-1)  (D) {$a$};
        \node at ( 0,-2)  (E) {$b$};
        \node at ( 1,-2)  (F) {$c$};
        \draw[-latex] (start) -- (A);
        \draw[-latex] (A) -- (B);
        \draw[-latex] (A) -- (C);
        \draw[-latex] (B) -- (D);
        \draw[-latex] (C) -- (D);
        \draw[-latex] (D) to (E);
        \draw[-latex] (D) to (F);
        \draw[-latex] (E) to[in=200,out=150] (D);
      \end{tikzpicture}
    \caption{\centering end node\newline replacement}
    \label{end-replacement-figure}
    \end{center}
  \end{subfigure}
  \begin{subfigure}{0.24\textwidth}
    \begin{center}
      \begin{tikzpicture}
        \useasboundingbox (-1.5,-2.5) rectangle (1.5,2);
        \node at (0,2) (start) {};
        \node at ( 0, 1)    (A) {$1$};
        \node at (-1, 0)    (B) {$a$};
        \node at ( 1,-0.5)  (C) {$3$};
        \node at (-2,-1)    (D) {$b$};
        \node at (-1,-1)    (F) {$c$};
        \node at ( 0,-2)    (G) {$4$};
        \draw[-latex] (start) -- (A);
        \draw[-latex] (A) -- (B);
        \draw[-latex] (A) -- (C);
        \draw[-latex] (B) to (D);
        \draw[-latex] (B) to (F);
        \draw[-latex] (D) to[in=180,out=90] (B);
        \draw[-latex] (F) -- (G);
        \draw[-latex] (C) -- (G);
      \end{tikzpicture}
      \caption{\centering internal node\newline replacement}
      \label{internal-replacement-figure}
    \end{center}
  \end{subfigure}
  \begin{subfigure}{0.24\textwidth}
    \begin{center}
      \begin{tikzpicture}
        \useasboundingbox (-1.5,-2.5) rectangle (1.5,2);
        \node at (0,2) (start) {};
        \node at ( 0, 1)    (A) {$1$};
        \node at (-1,-0.5)  (B) {$a$};
        \node at ( 1,-0.5)  (C) {$3$};
        \node at (-2,-1.5)  (D) {$b$};
        \node at ( 0,-2)    (G) {$4$};
        \draw[-latex] (start) -- (A);
        \draw[-latex] (A) -- (B);
        \draw[-latex] (A) -- (C);
        \draw[-latex] (B) to (D);
        \draw[-latex] (B) to (G);
        \draw[-latex] (D) to[in=180,out=90] (B);
        \draw[-latex] (C) -- (G);
      \end{tikzpicture}
    \caption{\centering branch end\newline replacement}
    \label{branch-end-replacement-figure}
  \end{center}
  \end{subfigure}
  \caption{Examples of the different cases of node replacement}
  \label{node-replacement-example-figures}
\end{figure}

In general, we define node replacement using the formal definition
below.
This covers each of the four cases shown above.
\begin{defn}[Node Replacement]
  Given two rooted directed graphs $G$ and $H$, we say $G'$ is the
  graph formed by \emph{replacing} a node $n$ of $G$ with $H$ if one
  of the following cases holds:
  \begin{itemize}
  \item $n$ has no predecessors in $G$, $H$ has only one end node, and
    \begin{itemize}
    \item $G'$ contains all the nodes of $H$ and $G$, except $n$,
    \item $G'$ contains the edges of $G$ except those going to or from
      $n$,
    \item $G'$ contains edges from the end node of $H$ to the
      successors of $n$ in $G$, and
    \item the root node of $G'$ is the root node of $H$;
    \end{itemize}
  \item $n$ has no successors in $G$, and
    \begin{itemize}
    \item $G'$ contains all the nodes of $H$ and $G$, except $n$,
    \item $G'$ contains the edges of $G$ except those going to or from
      $n$,
    \item $G'$ contains edges from the predecessors $n$ in $G$ to the
      root node of $H$, and
    \item the root node of $G'$ is the root node of $G$, or, if $n$ is
      the root node of $G$, the root node of $H$;
    \end{itemize}
  \item $H$ has a single end node and
    \begin{itemize}
    \item $G'$ contains all the nodes of $H$ and $G$, except $n$,
    \item $G'$ contains the edges of $G$ and the edges of $H$ except
      those going to or from $n$,
    \item $G'$ contains edges from the predecessors of $n$ in $G$ to
      the root node of $H$,
    \item $G'$ contains edges from the end node of $H$ to the
      successors of $n$ in $G$, and
    \item the root node of $G'$ is the root node of $G$, or, if $n$ is
      the root node of $G$, the root node of $H$;
    \end{itemize}
  \item $n$ has a single successor in $G$, $H$ has a single end
    node, and
    \begin{itemize}
    \item $G'$ contains all the nodes of $H$ and $G$, except $n$ and
      the end node of $H$,
    \item $G'$ contains the edges of $G$ except those going to or from
      $n$,
    \item $G'$ contains edges from the predecessors of the end node of
      $H$ to the successor of $n$ in $G$
    \item $G'$ contains edges from the predecessors of $n$ in $G$ to
      the root node of $H$, and
    \item the root node of $G'$ is the root node of $G$, or, if $n$ is
      the root node of $G$, the root node of $H$.
    \end{itemize}
  \end{itemize}
\end{defn}

With node replacement defined, we can now finally define what we mean
by a structure control flow graph in terms of node replacement and the
structured graphs shown in Figure~\ref{structured-cfg-figures}

\begin{defn}[Structured Control Flow Graph]
  If $G$ is a rooted directed graph, we say $G$ is a \emph{structured
    control flow graph} if $G$ is the trivial graph (the graph with a
  single node, which is also the root, and no edges) or if $G$ can be
  created by starting with the trivial graph and performing a finite
  number of node replacements to replace nodes with graphs of the
  forms shown in Figure~\ref{structured-cfg-figures}.
\end{defn}

Before applying the strategy, it must be ensured that the control flow
graph for each method is well-structured according to this definition.

Finally, we require that no method in the program recurses, either
directly or indirectly.
This is because recursion is not recommended in safety-critical
applications because of the potential for unpredictable failure due to
stack overflow, and it is not allowed in MISRA-C for that reason.
Imposing this requirement allows us to handle methods individually
when introducing their control flow, without considering circular
dependencies between them.


We now proceed to describe each of the stages of the strategy in
detail, beginning with the \emph{Elimination of Program Counter} stage
in the next section.

\section{Elimination of Program Counter}
\label{elimination-of-program-counter-section}

The first stage eliminates $pc$ from the state of each thread's
process, $Thr(bc,cs,t)$, introducing the control flow constructs of C
as a result. 
It is summarised by the following theorem.
%
\begin{thm}[Elimination of Program Counter]\label{thread-splitting-thm}
  \begin{circus}
    Thr(bc,cs,t) \circrefines ThrCF_{bc,cs}(cs,t)
  \end{circus}%
\end{thm}
%
We act mainly upon the $Running$ action of $Thr$; its loop is unrolled
to introduce the control flow that follows each bytecode instruction.
The aim is to get each method's bytecode instructions into a form in
which the control flow, but not the data operations, are described
using C constructs and, moreover, each path of execution (including
every branch of the conditionals) ends in a return instruction or a
loop.
We refer to a method in this form as a \emph{complete} method.

It is important to observe that it is possible to transform the
bytecode instructions of every method so that they become complete.
If we consider the control flow of a method beginning from that
method's entry point, each bytecode instruction reached must either be
a return instruction, or followed by another bytecode.
If another bytecode follows the bytecode's execution, then it must be
either a bytecode already considered, resulting in a loop, or one not
already considered.
Since there are finitely many bytecode instructions in a method, a
loop or return must eventually be reached.
Failure to do so would lead to an instruction beyond the end of the
method, which is forbidden by the structural restrictions on Java
bytecode that are checked during bytecode verification. 
% We assume bytecode input to our strategy will have undergone bytecode
% verification so this cannot happen.

When a method is complete, it can be defined by a separate \Circus{}
action.
When the code for all the methods has been separated out in this way,
the choice of bytecode instruction using the program counter value can
be removed and replaced with a choice over method identifiers.
Thus dependency on the program counter can be completely removed,
allowing it to be eliminated from the state of $Thr$.

The detailed description of the strategy for transforming $Thr$ in
this stage and achieving this elimination is provided by
Algorithm~\ref{epc-algorithm}.
It begins at line~\ref{algorithm-expand-bytecode} by expanding the
\Circus{} definitions of the bytecode instructions from the $bc$ map
into the $Running$ action, pulling out the program counter updates so
that they can be more easily manipulated.
In line~\ref{algorithm-introduce-forward-sequence}, simple sequential
compositions, that is, those that do not involve handling loops or
conditionals, are introduced.
% instructions that
% are followed by the execution of a bytecode instruction that is not
% part of the start or end of a conditional or loop are sequenced with
% the instructions following them.
After that, for each method, its loops and conditionals are introduced
in line~\ref{algorithm-introduce-loops-and-conditionals}. 
Afterwards, any complete methods are separated out, in
line~\ref{algorithm-separate-complete-methods}, and any method calls
involving completed methods are resolved by sequencing the method call
with the \Circus{} action representing the method, in
line~\ref{algorithm-resolve-method-calls}.

This is repeated until all methods have been separated out, as
indicated by the while loop in line~\ref{algorithm-method-loop}.
The $MainThread$ and $NotStarted$ actions are then refined in
line~\ref{algorithm-refine-main-actions} to provide a choice over
method identifiers, rather than $pc$ values, thus removing all uses of
$pc$ from the interpreter.
The $pc$ component is then removed from the state in
line~\ref{algorithm-remove-pc-from-state} of the algorithm.

\begin{algorithm}[t]
  \begin{algorithmic}[1]
    \State \Call{ExpandBytecode}{} \label{algorithm-expand-bytecode}
    \State \Call{IntroduceSequentialComposition}{} \label{algorithm-introduce-forward-sequence}
    \While{$\lnot$\Call{AllMethodsSeparated}{}} \label{algorithm-method-loop}
    \State \Call{IntroduceLoopsAndConditionals}{} \label{algorithm-introduce-loops-and-conditionals}
    \State \Call{SeparateCompleteMethods}{} \label{algorithm-separate-complete-methods}
    \State \Call{ResolveMethodCalls}{} \label{algorithm-resolve-method-calls}
    \EndWhile
    \State \Call{RefineMainActions}{} \label{algorithm-refine-main-actions}
    \State \Call{RemovePCFromState}{} \label{algorithm-remove-pc-from-state}
  \end{algorithmic}
  \caption{Elimination of Program Counter}
  \label{epc-algorithm}
\end{algorithm}

Each of the procedures used in Algorithm~\ref{epc-algorithm} is
defined in a separate section in the sequel.
Beforehand, we give a more detailed overview of the strategy using an
example.

\subsection{Running Example}
\label{overview-subsection}

We explain the strategy in detail with an example, the Java code for
which is shown in Figure~\ref{example-code-figure}.
\begin{figure}[t!]
  \begin{center}
  \begin{minipage}{12cm}
  \begin{lstlisting}[basicstyle=\ttfamily\footnotesize,keywordstyle=\bf\footnotesize,language=Java,numbers=left,numberstyle=\tiny,stepnumber=1, numbersep=5pt,escapeinside={(*@}{@*)}]
public class TPK extends AperiodicEventHandler {

  public TPK(PriorityParameters priority,
             AperiodicParameters release,
             StorageParameters storage,
             ConfigurationParameters config) {
    super(priority, release, storage, config);
  }
      
  public void handleAsyncEvent() {
    ConsoleConnection console = new ConsoleConnection(null); (*@\label{example-ConsoleConnection-line}@*)
        
    InputStream input = console.openInputStream(); (*@\label{example-InputStream-line}@*)
    OutputStream output = console.openOutputStream(); (*@\label{example-OutputStream-line}@*)
        
    for(int i = 0; i <= 10; i = i + 1) { (*@\label{example-for-loop-line}@*)
      int y = f(input.read());
          
      if (y > 400) {
        output.write(0);
      } else {
        output.write(y);
      }
    }
  }
      
  public static int f(int x){
    return x + x + x + 5;
  }
      
}
\end{lstlisting}
\end{minipage}
\end{center}
  \caption{Our example program}
  \label{example-code-figure}
\end{figure}
\begin{figure}[p]
  \begin{center}
  \setlength{\linewidth}{12cm}
  \begin{tabular}{p{9cm}p{4.5cm}}
    \scriptsize
    \setlength{\zedindent}{0cm}
    \setlength{\zedtab}{0.3cm}
    \setlength{\zedleftsep}{0cm}
    \begin{axdef}
      TPK : Class
    \where
      TPK = \lblot \\
      \t1 constantPool == \{ \\
      \t2 1 \mapsto ClassRef~TPKClassID, \\
      \t2 3 \mapsto ClassRef~AperiodicEventHandlerClassID, \\
      \t2 8 \mapsto MethodRef~AperiodicEventHandlerClassID~APEHinit, \\
      \t2 27 \mapsto ClassRef~ConsoleConnectionClassID, \\
      \t2 29 \mapsto  MethodRef~ConsoleConnectionClassID~CCinit, \\
      \t2 32 \mapsto MethodRef~ConsoleConnectionClassID~openInputStream, \\
      \t2 36 \mapsto MethodRef~ConsoleConnectionClassID~openOutputStream, \\
      \t2 40 \mapsto MethodRef~InputStreamClassID~read, \\
      \t2 41 \mapsto ClassRef~InputStreamClassID, \\
      \t2 46 \mapsto MethodRef~TPKClassID~f, \\
      \t2 50 \mapsto MethodRef~OutputStreamClassID~write, \\
      \t2 51 \mapsto ClassRef~OutputStreamClassID \\
      \t1 \}, \\
      \t1 this == 1, \\
      \t1 super == 3, \\
      \t1 interfaces == \{\}, \\
      \t1 methodEntry == \{ \\
      \t2 f \mapsto 43, \\
      \t2 handleAsyncEvent \mapsto 7, \\
      \t2 APEHinit \mapsto 0, \\
      \t1 \}, \\
      \t1 methodEnd == \{ \\
      \t2 f \mapsto 50, \\
      \t2 handleAsyncEvent \mapsto 42, \\
      \t2 APEHinit \mapsto 6 \\
      \t1 \}, \\
      \t1 methodLocals == \{ \\
      \t2 f \mapsto 1, \\
      \t2 handleAsyncEvent \mapsto 6, \\
      \t2 APEHinit \mapsto 5, \\
      \t1 \}, \\
      \t1 methodStackSize == \{ \\
      \t2 f \mapsto 2, \\
      \t2 handleAsyncEvent \mapsto 3, \\
      \t2 APEHinit \mapsto 5, \\
      \t1 \}, \\
      \t1 staticMethods == \{ f \} \\
      \t1 fields == \{\}, \\
      \t1 staticFields == \{\} \\
      \rblot
    \end{axdef}
    \begin{axdef}
      cs : ClassID \pfun Class
      \where
      cs = \{ \\
      \t1 TPKClassID \mapsto TPK \\
      \t1 \cdots \\
      \}
    \end{axdef}
    &
    \scriptsize
    \setlength{\zedindent}{0cm}
    \setlength{\zedtab}{0.3cm}
    \setlength{\zedleftsep}{0cm}
    \begin{axdef}
      bc : ProgramAddress \pfun Bytecode
      \where
      bc = \{ \\
      	\t1 0 \mapsto aload~0, \\
        \t1 1 \mapsto aload~1, \\
        \t1 2 \mapsto aload~2, \\
        \t1 3 \mapsto aload~3, \\
        \t1 4 \mapsto aload~4, \\
        \t1 5 \mapsto invokespecial~8, \\
        \t1 6 \mapsto return, \\
        \t1 7 \mapsto new~27, \\
        \t1 8 \mapsto dup, \\
        \t1 9 \mapsto aconst\_null, \\
        \t1 10 \mapsto invokespecial~29, \\
        \t1 11 \mapsto astore~1, \\
        \t1 12 \mapsto aload~1, \\
        \t1 13 \mapsto invokevirtual~32, \\
        \t1 14 \mapsto astore~2, \\
        \t1 15 \mapsto aload~1, \\
        \t1 16 \mapsto invokevirtual~36, \\
        \t1 17 \mapsto astore~3, \\
        \t1 18 \mapsto iconst~0, \\
        \t1 19 \mapsto astore~4, \\
        \t1 20 \mapsto goto~19, \\
        \t1 21 \mapsto aload~2, \\
        \t1 22 \mapsto invokevirtual~40, \\
        \t1 23 \mapsto invokestatic~46, \\
        \t1 24 \mapsto astore~5, \\
        \t1 25 \mapsto aload~5, \\
        \t1 26 \mapsto iconst~400, \\
        \t1 27 \mapsto if\_icmple~5, \\
        \t1 28 \mapsto aload~3, \\
        \t1 29 \mapsto iconst~0, \\
        \t1 30 \mapsto invokevirtual~50, \\
        \t1 31 \mapsto goto~4, \\
        \t1 32 \mapsto aload~3, \\
        \t1 33 \mapsto aload~5, \\
        \t1 34 \mapsto invokevirtual~50, \\
        \t1 35 \mapsto aload~4, \\
        \t1 36 \mapsto iconst~1, \\
        \t1 37 \mapsto iadd, \\
        \t1 38 \mapsto astore~4, \\
        \t1 39 \mapsto aload~4, \\
        \t1 40 \mapsto iconst~10, \\
        \t1 41 \mapsto if\_icmple~(\negate 20), \\
        \t1 42 \mapsto return, \\
        \t1 43 \mapsto aload~0, \\
        \t1 44 \mapsto aload~0, \\
        \t1 45 \mapsto iadd, \\
        \t1 46 \mapsto aload~0, \\
        \t1 47 \mapsto iadd, \\
        \t1 48 \mapsto iconst~5, \\
        \t1 49 \mapsto iadd, \\
        \t1 50 \mapsto areturn, \\
        \t1 {} \cdots {} \\
        \}
      \end{axdef}
  \end{tabular}
  \end{center}
  \caption{The \Circus{} code corresponding to our example program}
  \label{example-model-figure}
\end{figure}%
Our example is based on the Trabb Pardo-Knuth
algorithm~\cite{knuth1980}, used for comparison of programming
languages, since it includes a variety of programming constructs that
provide a good test of the strategy.
We have simplified the algorithm by removing the reading into an
array, since our bytecode subset does not include array operations.
Adding arrays makes the example much longer, while not giving any
interesting insight into our compilation strategy.

We have also written the example as an SCJ program, with the algorithm
as the body of an aperiodic event handler, \texttt{TPK}, one or more
instances of which can be registered as part of a mission and released
during mission execution.
As already mentioned, each release of the handler causes its
\texttt{handleAsyncEvent()} method to be executed.
This method creates an instance of a \texttt{ConsoleConnection}
(line~\ref{example-ConsoleConnection-line}), which is the only
standard input/output connection required by SCJ.
Instances of \texttt{InputStream} and \texttt{OutputStream} are then
obtained from the \texttt{ConsoleConnection} (lines~\ref{example-InputStream-line} and~\ref{example-OutputStream-line}).

After the input and output streams have been obtained, we enter a for
loop (line~\ref{example-for-loop-line}) in which an integer is read from the
\texttt{InputStream}, a static method \texttt{f()} is applied to it,
and the result is output if it is less than 400, otherwise 0 is
output.
The method \texttt{f()} takes an integer as input, multiplies it by 3
and adds 5 to it.

The \texttt{TPK} class is part of a larger program that includes many
other classes, including a \texttt{Safelet}, a
\texttt{MissionSequencer}, a \texttt{Mission}, and the classes that
make up the SCJ API.
% Considering these classes in our example would make the example much
% larger and more complex, while not introducing any more interesting
% aspects for the strategy to consider.
We omit a presentation of these classes, though it should be noted
that they are part of the complete example.
They need to go through similar refinement to that we illustrate for
the $TPK$ class.
This adds little complexity to the strategy since the bytecode array
is acted upon consistently for all classes, and the current class of a
given bytecode instruction can always be determined from its address
in the array.

The Java code must be run through a Java compiler to generate the
corresponding bytecode, which then defines the $bc$ and $cs$ constants
of our model.
The $bc$ and $cs$ values for our example are shown in
Figure~\ref{example-model-figure}.


Applying the bytecode expansion on
line~\ref{algorithm-expand-bytecode} of Algorithm~\ref{epc-algorithm}
yields the $Running$ action shown in
Figure~\ref{bytecode-expansion-example-figure}.
\begin{figure}[t]
  \setlength{\zedindent}{0cm}
  \setlength{\zedtab}{0.3cm}
  \setlength{\zedleftsep}{0.1cm}
  \begin{circus}
    Running \circdef \\
    \t1 \circif frameStack = \emptyset \circthen \Skip \\
    \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
    \t2 \circif pc = 0 \circthen HandleAloadEPC(0) \circseq pc := 1 \\
    \t2 {} \circelse pc = 1 \circthen HandleAloadEPC(1) \circseq pc := 2 \\
    \t2 {} \circelse pc = 2 \circthen HandleAloadEPC(2) \circseq pc := 3 \\
    \t2 {} \circelse pc = 3 \circthen HandleAloadEPC(3) \circseq pc := 4 \\
    \t2 {} \circelse pc = 4 \circthen HandleAloadEPC(4) \circseq pc := 5 \\
    \t2 {} \circelse pc = 5 \circthen \{pc = 5\} \circseq HandleInvokespecialEPC(8) \\
    \t2 {} \circelse pc = 6 \circthen HandleReturnEPC \\
    \t2 {} \circelse pc = 7 \circthen HandleNewEPC(27) \circseq pc := 8 \\
    \t2 {} \circelse pc = 8 \circthen HandleDupEPC \circseq pc := 9 \\
    \t2 {} \circelse pc = 9 \circthen HandleAconst\_nullEPC \circseq pc := 10 \\
    \t2 {} \circelse pc = 10 \circthen \{pc = 10\} \circseq HandleInvokespecialEPC(29) \\
    \t2 {} \circelse pc = 11 \circthen HandleAstoreEPC(1) \circseq pc := 12 \\
    % \t2 {} \circelse pc = 12 \circthen HandleAloadEPC(1) \circseq pc := 13 \\
    % \t2 {} \circelse pc = 13 \circthen HandleInvokevirtualEPC(32) \\
    % \t2 {} \circelse pc = 14 \circthen HandleAstoreEPC(2) \circseq pc := 15 \\
    % \t2 {} \circelse pc = 15 \circthen HandleAloadEPC(1) \circseq pc := 16 \\
    % \t2 {} \circelse pc = 16 \circthen HandleInvokevirtualEPC(36) \\
    % \t2 {} \circelse pc = 17 \circthen HandleAstoreEPC(3) \circseq pc := 18 \\
    % \t2 {} \circelse pc = 18 \circthen HandleIconstEPC(0) \circseq pc := 19 \\
    % \t2 {} \circelse pc = 19 \circthen HandleAstoreEPC(4) \circseq pc := 20 \\
    % \t2 {} \circelse pc = 20 \circthen pc := 39 \\
    \t2 {} \cdots {} \\
    % \t2 {} \circelse pc = 21 \circthen HandleAloadEPC(2) \circseq pc := 22 \\
    % \t2 {} \circelse pc = 22 \circthen HandleInvokevirtualEPC(40) \\
    % \t2 {} \circelse pc = 23 \circthen HandleInvokestaticEPC(46) \\
    % \t2 {} \circelse pc = 24 \circthen HandleAstoreEPC(5) \circseq pc := 25 \\
    % \t2 {} \circelse pc = 25 \circthen HandleAloadEPC(5) \circseq pc := 26 \\
    % \t2 {} \circelse pc = 26 \circthen HandleIconstEPC(400) \circseq pc := 27 \\
    % \t2 {} \circelse pc = 27 \circthen \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 32 \ELSE 28 \\
    % \t2 {} \circelse pc = 28 \circthen HandleAloadEPC(3) \circseq pc := 29 \\
    % \t2 {} \circelse pc = 29 \circthen HandleIconstEPC(0) \circseq pc := 30 \\
    % \t2 {} \circelse pc = 30 \circthen HandleInvokevirtualEPC(50) \\
    % \t2 {} \circelse pc = 31 \circthen pc := 35 \\
    % \t2 {} \circelse pc = 32 \circthen HandleAloadEPC(3) \circseq pc := 33 \\
    % \t2 {} \circelse pc = 33 \circthen HandleAloadEPC(5) \circseq pc := 34 \\
    % \t2 {} \circelse pc = 34 \circthen HandleInvokevirtualEPC(50) \\
    % \t2 {} \circelse pc = 35 \circthen HandleAloadEPC(4) \circseq pc := 36 \\
    % \t2 {} \circelse pc = 36 \circthen HandleIconstEPC(1) \circseq pc := 37 \\
    % \t2 {} \circelse pc = 37 \circthen HandleIaddEPC \circseq pc := 38 \\
    % \t2 {} \circelse pc = 38 \circthen HandleAstoreEPC(4) \circseq pc := 39 \\
    % \t2 {} \circelse pc = 39 \circthen HandleAloadEPC(4) \circseq pc := 40 \\
    % \t2 {} \circelse pc = 40 \circthen HandleIconstEPC(10) \circseq pc := 41 \\
    % \t2 {} \circelse pc = 41 \circthen \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 42 \circthen HandleReturnEPC \\
    % \t2 {} \circelse pc = 43 \circthen HandleAloadEPC(0) \circseq pc := 44 \\
    % \t2 {} \circelse pc = 44 \circthen HandleAloadEPC(0) \circseq pc := 45 \\
    % \t2 {} \circelse pc = 45 \circthen HandleIaddEPC \circseq pc := 46 \\
    % \t2 {} \circelse pc = 46 \circthen HandleAloadEPC(0) \circseq pc := 47 \\
    % \t2 {} \circelse pc = 47 \circthen HandleIaddEPC \circseq pc := 48 \\
    % \t2 {} \circelse pc = 48 \circthen HandleIconstEPC(5) \circseq pc := 49 \\
    % \t2 {} \circelse pc = 49 \circthen HandleIaddEPC \circseq pc := 50 \\
    % \t2 {} \circelse pc = 50 \circthen HandleAreturnEPC \\
    \t2 \circfi \circseq Poll \circseq Running \\
    \t1 \circfi
  \end{circus}
  \caption{The $Running$ action after bytecode expansion}
  \label{bytecode-expansion-example-figure}
\end{figure}
This step copies $HandleInstruction$ into $Running$, and converts it
to a choice of actions based on the value of the program counter,
mirroring the contents of the $bc$ map for each value.

The actions that make up $HandleInstruction$ are also replaced with
actions that incorporate instruction parameters from the $bc$ map, and
have $pc$ updates separated from stack updates.
This can be seen in Figure~\ref{bytecode-expansion-example-figure},
where, for instance, in the $pc = 0$ case, $aload~0$ has been
converted to $HandleAloadEPC(0) \circseq pc := 1$, with the parameter,
$0$, to the bytecode instruction becoming a parameter of the new
instruction handling action $HandleAloadEPC$, and the update to $pc$
placed after the data operation.

The reason for making parameters of the bytecode instructions into
parameters of the handling actions is to remove the need to reference
the bytecode instructions in the $bc$ map, as that involves use of the
$pc$ value, which we seek to remove in this stage.
This also has the benefit of fully incorporating $bc$ into the $Thr$
process, ensuring all the information required to introduce C code
constructs is available directly in \Circus{}, which makes stating
compilation laws simpler.
This is described in more detail in
Section~\ref{expand-bytecode-subsection}, where we define the
\Call{ExpandBytecode}{} procedure.

\begin{figure}[t!]
  \setlength{\zedindent}{0cm}
  \setlength{\zedtab}{0.3cm}
  \setlength{\zedleftsep}{0.1cm}
  \begin{circus}
    Running \circdef \\
    \t1 \circif frameStack = \emptyset \circthen \Skip \\
    \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
    \t2 \circif pc = 0 \circthen HandleAloadEPC(0) \circseq pc := 1 \circseq Poll \circseq HandleAloadEPC(1) \circseq \\
    \t3 pc := 2 \circseq Poll \circseq HandleAloadEPC(2) \circseq pc := 3 \circseq Poll \circseq HandleAloadEPC(4) \circseq \\
    \t3 pc := 5 \circseq Poll \circseq \{pc = 5\} \circseq HandleInvokespecialEPC(8) \\
    \t2 {} \cdots {} \\
    % \t2 {} \circelse pc = 1 \circthen HandleAloadEPC(1) \circseq pc := 2 \\
    % \t2 {} \circelse pc = 2 \circthen HandleAloadEPC(2) \circseq pc := 3 \\
    % \t2 {} \circelse pc = 3 \circthen HandleAloadEPC(3) \circseq pc := 4 \\
    % \t2 {} \circelse pc = 4 \circthen HandleAloadEPC(4) \circseq pc := 5 \\
    % \t2 {} \circelse pc = 5 \circthen HandleInvokespecialEPC(8) \\
    \t2 {} \circelse pc = 6 \circthen HandleReturnEPC \\
    \t2 {} \circelse pc = 7 \circthen HandleNewEPC(27) \circseq pc := 8 \circseq Poll \circseq HandleDupEPC \circseq pc := 9 \circseq \\
    \t3 Poll \circseq HandleAconst\_nullEPC \circseq pc := 10 \circseq Poll \circseq \{pc = 10\} \circseq HandleInvokespecialEPC(29) \\
    \t2 {} \cdots {} \\
    % \t2 {} \circelse pc = 8 \circthen HandleDupEPC \circseq pc := 9 \\
    % \t2 {} \circelse pc = 9 \circthen HandleAconst\_nullEPC \circseq pc := 10 \\
    % \t2 {} \circelse pc = 10 \circthen HandleInvokespecialEPC(29) \\
    \t2 {} \circelse pc = 11 \circthen HandleAstoreEPC(1) \circseq pc := 12 \circseq Poll \circseq HandleAloadEPC(1) \circseq \\
    \t3 pc := 13 \circseq Poll \circseq \{pc = 13\} \circseq HandleInvokevirtualEPC(32) \\
    \t2 {} \cdots {} \\
    % \t2 {} \circelse pc = 12 \circthen HandleAloadEPC(1) \circseq pc := 13 \\
    % \t2 {} \circelse pc = 13 \circthen HandleInvokevirtualEPC(32) \\
    \t2 {} \circelse pc = 14 \circthen HandleAstoreEPC(2) \circseq pc := 15 \circseq Poll \circseq HandleAloadEPC(1) \circseq \\
    \t3 pc := 16 \circseq Poll \circseq \{pc = 16\} \circseq HandleInvokevirtualEPC(36) \\
    \t2 {} \cdots {} \\
    % \t2 {} \circelse pc = 15 \circthen HandleAloadEPC(1) \circseq pc := 16 \\
    % \t2 {} \circelse pc = 16 \circthen HandleInvokevirtualEPC(36) \\
    \t2 {} \circelse pc = 17 \circthen HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq \\
    \t3 pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \\
    \t2 {} \cdots {} \\
    % \t2 {} \circelse pc = 18 \circthen HandleIconstEPC(0) \circseq pc := 19 \\
    % \t2 {} \circelse pc = 19 \circthen HandleAstoreEPC(4) \circseq pc := 20 \\
    % \t2 {} \circelse pc = 20 \circthen pc := 39 \\
    % \t2 {} \circelse pc = 21 \circthen HandleAloadEPC(2) \circseq pc := 22 \circseq Poll \circseq HandleInvokevirtualEPC(40) \\
    % \t2 {} \circelse pc = 22 \circthen HandleInvokevirtualEPC(40) \\
    % \t2 {} \circelse pc = 23 \circthen HandleInvokestaticEPC(46) \\
    % \t2 {} \circelse pc = 24 \circthen HandleAstoreEPC(5) \circseq pc := 25 \circseq Poll \circseq HandleAloadEPC(5) \circseq \\
    % \t3 pc := 26 \circseq Poll \circseq HandleIconstEPC(400) \circseq pc := 27 \circseq Poll \circseq \\
    % \t3 \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 32 \ELSE 28 \\
    % \t2 {} \circelse pc = 25 \circthen HandleAloadEPC(5) \circseq pc := 26 \\
    % \t2 {} \circelse pc = 26 \circthen HandleIconstEPC(400) \circseq pc := 27 \\
    % \t2 {} \circelse pc = 27 \circthen \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 32 \ELSE 28 \\
    % \t2 {} \circelse pc = 28 \circthen HandleAloadEPC(3) \circseq pc := 29 \circseq Poll \circseq HandleIconstEPC(0) \circseq \\
    % \t3 pc := 30 \circseq Poll \circseq HandleInvokevirtualEPC(50) \\
    % \t2 {} \circelse pc = 29 \circthen HandleIconstEPC(0) \circseq pc := 30 \\
    % \t2 {} \circelse pc = 30 \circthen HandleInvokevirtualEPC(50) \\
    % \t2 {} \circelse pc = 31 \circthen pc := 35 \\
    % \t2 {} \circelse pc = 32 \circthen HandleAloadEPC(3) \circseq pc := 33 \circseq Poll \circseq HandleAloadEPC(5) \circseq \\
    % \t3 pc := 34 \circseq Poll \circseq HandleInvokevirtualEPC(50) \\
    % \t2 {} \circelse pc = 33 \circthen HandleAloadEPC(5) \circseq pc := 34 \\
    % \t2 {} \circelse pc = 34 \circthen HandleInvokevirtualEPC(50) \\
    % \t2 {} \circelse pc = 35 \circthen HandleAloadEPC(4) \circseq pc := 36 \circseq Poll \circseq HandleIconstEPC(1) \circseq \\
    % \t3 pc := 37 \circseq Poll \circseq HandleIaddEPC \circseq pc := 38 \circseq Poll \circseq HandleAstoreEPC(4) \circseq \\
    % \t3 pc := 39 \\
    % \t2 {} \circelse pc = 36 \circthen HandleIconstEPC(1) \circseq pc := 37 \\
    % \t2 {} \circelse pc = 37 \circthen HandleIaddEPC \circseq pc := 38 \\
    % \t2 {} \circelse pc = 38 \circthen HandleAstoreEPC(4) \circseq pc := 39 \\
    \t2 {} \circelse pc = 39 \circthen HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq \\
    \t3 pc := 41 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    \t2 {} \cdots {} \\
    % \t2 {} \circelse pc = 40 \circthen HandleIconstEPC(10) \circseq pc := 41 \\
    % \t2 {} \circelse pc = 41 \circthen \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    \t2 {} \circelse pc = 42 \circthen HandleReturnEPC \\
    \t2 {} \circelse pc = 43 \circthen HandleAloadEPC(0) \circseq pc := 44 \circseq Poll \circseq HandleAloadEPC(0) \circseq \\
    \t3 pc := 45 \circseq Poll \circseq HandleIaddEPC \circseq pc := 46 \circseq Poll \circseq HandleAloadEPC(0) \circseq \\
    \t3 pc := 47 \circseq Poll \circseq HandleIaddEPC \circseq pc := 48 \circseq Poll \circseq HandleIaddEPC \circseq \\
    \t3 pc := 50 \circseq Poll \circseq HandleAreturnEPC \\
    \t2 {} \cdots {} \\
    % \t2 {} \circelse pc = 44 \circthen HandleAloadEPC(0) \circseq pc := 45 \\
    % \t2 {} \circelse pc = 45 \circthen HandleIaddEPC \circseq pc := 46 \\
    % \t2 {} \circelse pc = 46 \circthen HandleAloadEPC(0) \circseq pc := 47 \\
    % \t2 {} \circelse pc = 47 \circthen HandleIaddEPC \circseq pc := 48 \\
    % \t2 {} \circelse pc = 48 \circthen HandleIconstEPC(5) \circseq pc := 49 \\
    % \t2 {} \circelse pc = 49 \circthen HandleIaddEPC \circseq pc := 50 \\
    % \t2 {} \circelse pc = 50 \circthen HandleAreturnEPC \\
    \t2 \circfi \circseq Poll \circseq Running \\
    \t1 \circfi
  \end{circus}
  \caption{The $Running$ action after forward sequence introduction}
  \label{forward-sequence-introduction-example-figure}
\end{figure}

On line~\ref{algorithm-introduce-forward-sequence} of the
Algorithm~\ref{epc-algorithm}, sequential composition is introduced
for instructions that do not affect the sequential flow of the
program.
Such instructions are identified by considering the control flow graph
of the program and locating nodes with a single outgoing edge going to
a target node with exactly one incoming edge.
The introduction of sequential composition is performed by unrolling
the loop in $Running$ to introduce the control flow following each of
these instructions.
This causes the instruction to be sequentially composed with the next
instruction, with $Poll$ inbetween to allow for thread switches
between instructions.
This is performed exhaustively to get the code in the form shown in
Figure~\ref{forward-sequence-introduction-example-figure}, where the
choice over $pc$ has sequences of instructions collected together at
the point where they start, up to the point at which a more complex
control flow (such as a method call, conditional or a loop) occurs.
The introduction of sequential composition is described in more detail
in Section~\ref{introduce-forward-sequence-subsection}, where we
define the \Call{IntroduceSequentialComposition}{} procedure.

Handling the remaining constructs requires consideration of
dependencies between methods to ensure method calls can be resolved
correctly.
We say a method call is \emph{resolved} when the method invocation
bytecode has been placed in sequential composition with a call to a
\Circus{} action containing the body of the method being invoked,
which is then followed by the sequence of instructions that occur
after the invocation bytecode instruction in the calling method.
After a method call has been resolved, it no longer breaks up the
sequence of instructions it occurs in.

Since we have the bytecode instructions of all the methods needed, we
can always resolve the call of a complete method, provided that method
has already been split into its own \Circus{} action.
To ensure a called method is complete, we first perform loop and
conditional introduction upon the method.
Since introducing loops and conditionals requires unbroken sequences
of instructions that form the bodies of loops and branches of
conditionals, introduction of loops and conditionals can only be
performed on methods that have no unresolved method calls.
In our example, \texttt{handleAsyncEvent()} is the only method that
needs loops and conditionals introducing but, since it also contains
method calls that break up the body of a loop, we must wait until its
method calls have been resolved before introducing loops and
conditionals.
For this reason, we perform method call resolution, and loop and
conditional introduction repeatedly until all method calls are
resolved and the resulting complete methods have all been separated
out.
This is expressed in Algorithm~\ref{epc-algorithm} by the while loop
on line~\ref{algorithm-method-loop}.

Introduction of loops and conditionals to the body of a method with no
unresolved method calls occurs on
line~\ref{algorithm-introduce-loops-and-conditionals} of the
algorithm.
To introduce loops and conditionals we consider the control flow graph
of the method again, though it is now much simpler than the control
flow graph used for sequence introduction since straight sequences of
instructions have already been combined together.
Patterns representing conditionals and loops are then identified using
the control flow graph and the corresponding constructs are
introduced.
As loops and conditionals are introduced, nodes in the control flow
graph are merged until the graph consists of a single node, which is
the starting point of the method, containing the complete method body.

The result of introducing loops and conditionals in
\texttt{handleAsyncEvent()} after method calls have been resolved is
shown in
Figure~\ref{loop-and-conditional-introduction-example-figure}.
The process of introducing loops and conditionals is described in more
detail in Section~\ref{introduce-loops-and-conditionals-subsection},
where we define the \Call{IntroduceLoopsAndConditionals}{} procedure.
\begin{figure}[t!]
  \setlength{\zedindent}{0cm}
  \setlength{\zedtab}{0.5cm}
  \setlength{\zedleftsep}{0.1cm}
  \begin{circus}
    Running \circdef \\
    \t1 \circif frameStack = \emptyset \circthen \Skip \\
    \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
    \t2 \circif pc = 0 \circthen HandleAloadEPC(0) \circseq pc := 1 \circseq Poll \circseq HandleAloadEPC(1) \circseq \\
    \t3 pc := 2 \circseq Poll \circseq HandleAloadEPC(2) \circseq pc := 3 \circseq Poll \circseq HandleAloadEPC(4) \circseq \\
    \t3 pc := 5 \circseq Poll \circseq HandleInvokespecialEPC(8) \circseq Poll \circseq AperiodicEventHandler\_APEHinit \circseq \\
    \t3 Poll \circseq HandleReturnEPC \\
    \t2 {} \circelse pc = 7 \circthen HandleNewEPC(27) \circseq pc := 8 \circseq Poll \circseq HandleDupEPC \circseq pc := 9 \circseq \\
    \t3 Poll \circseq HandleAconst\_nullEPC \circseq pc := 10 \circseq Poll \circseq HandleInvokespecialEPC(29) \circseq \\
    \t3 ConsoleConnection\_CCinit \circseq Poll \circseq HandleAstoreEPC(1) \circseq pc := 12 \circseq Poll \circseq \\
    \t3 HandleAloadEPC(1) \circseq pc := 13 \circseq Poll \circseq HandleInvokevirtualEPC(32) \circseq Poll \circseq \\
    \t3 ConsoleConnection\_openInputStream \circseq Poll \circseq  HandleAstoreEPC(2) \circseq pc := 15 \circseq Poll \circseq \\
    \t3 HandleAloadEPC(1) \circseq pc := 16 \circseq Poll \circseq HandleInvokevirtualEPC(36) \circseq Poll \circseq \\
    \t3 ConsoleConnection\_openOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq \\
    \t3 HandleIconstEPC(0) \circseq pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq \\
    \t3 Poll \circseq\circmu Y \circspot HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq \\
    \t3 pc := 41 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    \t3 \circif value1 \leq value2 \circthen pc := 21 \circseq Poll \circseq HandleAloadEPC(2) \circseq pc := 22 \circseq Poll \circseq \\
    \t4 HandleInvokevirtualEPC(40) \circseq Poll \circseq InputStream\_Read \circseq Poll \circseq \\
    \t4 HandleInvokestaticEPC(46) \circseq Poll \circseq TPK\_f  \circseq Poll \circseq \\
    \t4 HandleAstoreEPC(5) \circseq pc := 25 \circseq Poll \circseq HandleAloadEPC(5) \circseq pc := 26 \circseq Poll \circseq \\
    \t4 HandleIconstEPC(400) \circseq pc := 27 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    \t4 \circif value1 \leq value2 \circthen pc := 32 \circseq HandleAloadEPC(3) \circseq pc := 33 \circseq Poll \circseq \\
    \t5 HandleAloadEPC(5) \circseq pc := 34 \circseq Poll \circseq HandleInvokevirtualEPC(50) \circseq Poll \circseq \\
    \t5 OutputStream\_write \\
    \t4 {} \circelse value1 > value2 \circthen pc := 28 \circseq HandleAloadEPC(3) \circseq pc := 29 \circseq Poll \circseq \\
    \t5 HandleIconstEPC(0) \circseq pc := 30 \circseq Poll \circseq HandleInvokevirtualEPC(50) \circseq \\
    \t5 OutputStream\_write \\
    \t4 \circfi \circseq pc := 35 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 36 \circseq Poll \circseq HandleIconstEPC(1) \circseq \\
    \t4 pc := 37 \circseq Poll \circseq HandleIaddEPC \circseq pc := 38 \circseq Poll \circseq HandleAstoreEPC(4) \circseq \\
    \t4 pc := 39 \circseq Poll \circseq Y \\
    \t3 {} \circelse value1 > value2 \circthen \Skip \\
    \t3 \circfi \circseq pc := 42 \circseq Poll \circseq HandleReturnEPC \\
    \t2 {} \cdots {} \\
    \t2 {} \circelse pc = 43 \circthen TPK\_f \\
    % \t2 {} \circelse pc = 43 \circthen HandleAloadEPC(0) \circseq pc := 44 \circseq Poll \circseq HandleAloadEPC(0) \circseq \\
    % \t3 pc := 45 \circseq Poll \circseq HandleIaddEPC \circseq pc := 46 \circseq Poll \circseq HandleAloadEPC(0) \circseq \\
    % \t3 pc := 47 \circseq Poll \circseq HandleIaddEPC \circseq pc := 48 \circseq Poll \circseq HandleIaddEPC \circseq \\
    % \t3 pc := 50 \circseq Poll \circseq HandleAreturnEPC \\
    \t2 {} \cdots {} \\
    \t2 \circfi \circseq Poll \circseq Running \\
    \t1 \circfi
  \end{circus}
  \caption{The $Running$ action after loop and conditional introduction}
  \label{loop-and-conditional-introduction-example-figure}
\end{figure}

After loops and conditionals have been introduced, methods that are
then complete can be copied into separate actions.
This occurs in line~\ref{algorithm-separate-complete-methods} of this
algorithm.
It is done with a simple application of the copy rule, replacing the
actions at the entry points of the split methods with references to
newly created method actions.
This can be seen in
Figure~\ref{method-call-resolution-example-figure}, where the $TPK\_F$
action has been created by splitting the sequence of actions for the
\texttt{f()} method of \texttt{TPK} from the $pc = 43$ case.
As this step is relatively simple, we do not explain it in a separate
section.
\begin{figure}[t]
  \setlength{\zedindent}{0cm}
  \setlength{\zedtab}{0.3cm}
  \setlength{\zedleftsep}{0cm}
  \begin{circus}
    Running \circdef \\
    \t1 \circif frameStack = \emptyset \circthen \Skip \\
    \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
    \t2 {} \circif pc = 0 \circthen HandleAloadEPC(0) \circseq pc := 1 \circseq Poll \circseq HandleAloadEPC(1) \circseq \\
    \t3 pc := 2 \circseq Poll \circseq HandleAloadEPC(2) \circseq pc := 3 \circseq Poll \circseq HandleAloadEPC(3) \circseq \\
    \t3 pc := 4 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 5 \circseq Poll \circseq \\
    \t3 HandleInvokespecialEPC(8) \circseq Poll \circseq AperiodicEventHandler\_APEHinit \circseq \\
    \t3 Poll \circseq HandleReturnEPC \\
    \t2 {} \cdots {} \\
    % \t2 {} \circelse pc = 1 \circthen HandleAloadEPC(1) \circseq pc := 2 \circseq Poll \circseq HandleAloadEPC(2) \circseq pc := 3 \circseq \\
    % \t3 Poll \circseq HandleAloadEPC(3) \circseq pc := 4 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 5 \circseq \\
    % \t3 Poll \circseq HandleInvokespecialEPC(8) \circseq Poll \circseq APEHInit \circseq Poll \circseq HandleReturnEPC \\
    % \t2 {} \circelse pc = 2 \circthen HandleAloadEPC(2) \circseq pc := 3 \circseq Poll \circseq HandleAloadEPC(3) \circseq pc := 4 \circseq \\
    % \t3 Poll \circseq HandleAloadEPC(4) \circseq pc := 5 \circseq Poll \circseq HandleInvokespecialEPC(8) \circseq \\
    % \t3 Poll \circseq APEHInit \circseq Poll \circseq HandleReturnEPC \\
    % \t2 {} \circelse pc = 3 \circthen HandleAloadEPC(3) \circseq pc := 4 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 5 \circseq \\
    % \t3 Poll \circseq HandleInvokespecialEPC(8) \circseq Poll \circseq APEHInit \circseq Poll \circseq HandleReturnEPC \\
    % \t2 {} \circelse pc = 4 \circthen HandleAloadEPC(4) \circseq pc := 5 \circseq Poll \circseq HandleInvokespecialEPC(8) \circseq \\
    % \t3 Poll \circseq APEHInit \circseq Poll \circseq HandleReturnEPC \\
    % \t2 {} \circelse pc = 5 \circthen HandleInvokespecialEPC(8) \circseq Poll \circseq APEHInit \circseq Poll \circseq HandleReturnEPC \\
    % \t2 {} \circelse pc = 6 \circthen HandleReturnEPC \\
    % \t2 {} \circelse pc = 7 \circthen HandleNewEPC(27) \circseq pc := 8 \circseq Poll \circseq HandleDupEPC \circseq pc := 9 \circseq \\
    % \t3 Poll \circseq HandleAconst\_nullEPC \circseq pc := 10 \circseq Poll \circseq HandleInvokespecialEPC(29) \circseq \\
    % \t3 Poll \circseq ConsoleConnection\_CCInit \circseq Poll \circseq HandleAstoreEPC(1) \circseq pc := 12 \circseq Poll \circseq \\
    % \t3 HandleAloadEPC(1) \circseq pc := 13 \circseq Poll \circseq HandleInvokevirtualEPC(32) \circseq Poll \circseq \\
    % \t3 OpenInputStream \circseq Poll \circseq HandleAstoreEPC(2) \circseq pc := 15 \circseq Poll \circseq \\
    % \t3 HandleAloadEPC(1) \circseq pc := 16 \circseq Poll \circseq HandleInvokevirtualEPC(36) \circseq Poll \circseq \\
    % \t3 OpenOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq \\
    % \t3 HandleIconstEPC(0) \circseq pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq \\
    % \t3 Poll \circseq pc := 39 \\
    % \t2 {} \cdots {} \\
    % \t2 {} \circelse pc = 8 \circthen HandleDupEPC \circseq pc := 9 \circseq Poll \circseq HandleAconst\_nullEPC \circseq pc := 10 \circseq \\
    % \t3 Poll \circseq HandleInvokespecialEPC(29) \circseq Poll \circseq CCInit \circseq Poll \circseq HandleAstoreEPC(1) \circseq \\
    % \t3 pc := 12 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 13 \circseq Poll \circseq \\
    % \t3 HandleInvokevirtualEPC(32) \circseq Poll \circseq OpenInputStream \circseq Poll \circseq HandleAstoreEPC(2) \circseq \\
    % \t3 pc := 15 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 16 \circseq Poll \circseq HandleInvokevirtualEPC(36) \circseq Poll \circseq OpenOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq \\
    % \t3 pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq \\
    % \t3 HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq \\
    % \t3 Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 9 \circthen HandleAconst\_nullEPC \circseq pc := 10 \circseq Poll \circseq HandleInvokespecialEPC(29) \circseq Poll \circseq CCInit \circseq Poll \circseq HandleAstoreEPC(1) \circseq pc := 12 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 13 \circseq Poll \circseq HandleInvokevirtualEPC(32) \circseq Poll \circseq OpenInputStream \circseq Poll \circseq HandleAstoreEPC(2) \circseq pc := 15 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 16 \circseq Poll \circseq HandleInvokevirtualEPC(36) \circseq Poll \circseq OpenOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq \\
    % \t3 pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq \\
    % \t3 HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq \\
    % \t3 Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 10 \circthen HandleInvokespecialEPC(29) \circseq Poll \circseq CCInit \circseq Poll \circseq HandleAstoreEPC(1) \circseq pc := 12 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 13 \circseq Poll \circseq HandleInvokevirtualEPC(32) \circseq Poll \circseq OpenInputStream \circseq Poll \circseq HandleAstoreEPC(2) \circseq pc := 15 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 16 \circseq Poll \circseq HandleInvokevirtualEPC(36) \circseq Poll \circseq OpenOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq \\
    % \t3 pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq \\
    % \t3 HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq \\
    % \t3 Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 11 \circthen HandleAstoreEPC(1) \circseq pc := 12 \circseq Poll \circseq HandleAloadEPC(1) \circseq \\
    % \t3 pc := 13 \circseq Poll \circseq HandleInvokevirtualEPC(32) \circseq Poll \circseq OpenInputStream \circseq Poll \circseq HandleAstoreEPC(2) \circseq pc := 15 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 16 \circseq Poll \circseq HandleInvokevirtualEPC(36) \circseq Poll \circseq OpenOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq \\
    % \t3 pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq \\
    % \t3 HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq \\
    % \t3 Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 12 \circthen HandleAloadEPC(1) \circseq pc := 13 \circseq Poll \circseq HandleInvokevirtualEPC(32) \circseq Poll \circseq OpenInputStream \circseq Poll \circseq HandleAstoreEPC(2) \circseq pc := 15 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 16 \circseq Poll \circseq HandleInvokevirtualEPC(36) \circseq Poll \circseq OpenOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq \\
    % \t3 pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq \\
    % \t3 HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq \\
    % \t3 Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 13 \circthen HandleInvokevirtualEPC(32) \circseq Poll \circseq OpenInputStream \circseq Poll \circseq HandleAstoreEPC(2) \circseq pc := 15 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 16 \circseq Poll \circseq HandleInvokevirtualEPC(36) \circseq Poll \circseq OpenOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq \\
    % \t3 pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq \\
    % \t3 HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq \\
    % \t3 Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 14 \circthen HandleAstoreEPC(2) \circseq pc := 15 \circseq Poll \circseq HandleAloadEPC(1) \circseq \\
    % \t3 pc := 16 \circseq Poll \circseq HandleInvokevirtualEPC(36) \circseq Poll \circseq OpenOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq \\
    % \t3 pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq \\
    % \t3 HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq \\
    % \t3 Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 15 \circthen HandleAloadEPC(1) \circseq pc := 16 \circseq Poll \circseq HandleInvokevirtualEPC(36) \circseq Poll \circseq OpenOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq \\
    % \t3 pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq \\
    % \t3 HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq \\
    % \t3 Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 16 \circthen HandleInvokevirtualEPC(36) \circseq Poll \circseq OpenOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq \\
    % \t3 pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq \\
    % \t3 HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq \\
    % \t3 Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 17 \circthen HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq HandleIconstEPC(0) \circseq \\
    % \t3 pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq \\
    % \t3 HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq \\
    % \t3 Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 18 \circthen HandleIconstEPC(0) \circseq pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 19 \circthen HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 20 \circthen pc := 39 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    \t2 {} \circelse pc = 21 \circthen HandleAloadEPC(2) \circseq pc := 22 \circseq Poll \circseq \\
    \t3 HandleInvokevirtualEPC(40) \circseq Poll \circseq ConsoleInput\_Read \circseq Poll \circseq \\
    \t3 HandleInvokestaticEPC(46) \circseq Poll \circseq TPK\_f \circseq Poll \circseq HandleAstoreEPC(5) \circseq \\
    \t3 pc := 25 \circseq Poll \circseq HandleAloadEPC(5) \circseq pc := 26 \circseq HandleIconstEPC(400) \circseq \\
    \t3 pc := 27 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    \t3 pc := \IF value1 \leq value2 \THEN 32 \ELSE 28 \\
    % \t2 {} \circelse pc = 22 \circthen HandleInvokevirtualEPC(40) \circseq Poll \circseq Read \circseq Poll \circseq HandleInvokestaticEPC(46) \circseq Poll \circseq F \circseq Poll \circseq HandleAstoreEPC(5) \circseq pc := 25 \circseq Poll \circseq HandleAloadEPC(5) \circseq pc := 26 \circseq HandleIconstEPC(400) \circseq pc := 27 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq pc := \IF value1 \leq value2 \THEN 32 \ELSE 28 \\
    % \t2 {} \circelse pc = 23 \circthen HandleInvokestaticEPC(46) \circseq Poll \circseq F \circseq Poll \circseq HandleAstoreEPC(5) \circseq pc := 25 \circseq Poll \circseq HandleAloadEPC(5) \circseq pc := 26 \circseq HandleIconstEPC(400) \circseq pc := 27 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq pc := \IF value1 \leq value2 \THEN 32 \ELSE 28 \\
    % \t2 {} \circelse pc = 24 \circthen HandleAstoreEPC(5) \circseq pc := 25 \circseq Poll \circseq HandleAloadEPC(5) \circseq pc := 26 \circseq HandleIconstEPC(400) \circseq pc := 27 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq pc := \IF value1 \leq value2 \THEN 32 \ELSE 28 \\
    % \t2 {} \circelse pc = 25 \circthen HandleAloadEPC(5) \circseq pc := 26 \circseq Poll \circseq HandleIconstEPC(400) \circseq pc := 27 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq pc := \IF value1 \leq value2 \THEN 32 \ELSE 28 \\
    % \t2 {} \circelse pc = 26 \circthen HandleIconstEPC(400) \circseq pc := 27 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq pc := \IF value1 \leq value2 \THEN 32 \ELSE 28 \\
    % \t2 {} \circelse pc = 27 \circthen \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 32 \ELSE 28 \\
    % \t2 {} \circelse pc = 28 \circthen HandleAloadEPC(3) \circseq pc := 29 \circseq Poll \circseq HandleIconstEPC(0) \circseq pc := 30 \circseq Poll \circseq HandleInvokevirtualEPC(50) \circseq Poll \circseq Write \circseq Poll \circseq pc := 38 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 39 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 29 \circthen HandleIconstEPC(0) \circseq pc := 30 \circseq Poll \circseq HandleInvokevirtualEPC(50) \circseq Poll \circseq Write \circseq Poll \circseq pc := 38 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 39 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 30 \circthen HandleInvokevirtualEPC(50) \circseq Poll \circseq Write \circseq Poll \circseq pc := 38 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 39 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 31 \circthen pc := 38 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 39 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq pc := 41 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 32 \circthen HandleAloadEPC(3) \circseq pc := 33 \circseq Poll \circseq HandleAloadEPC(5) \circseq pc := 34 \circseq Poll \circseq HandleInvokevirtualEPC(50) \circseq Poll \circseq Write \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 36 \circseq Poll \circseq HandleIconstEPC(1) \circseq pc := 37 \circseq Poll \circseq HandleIaddEPC \circseq pc := 38 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 39  \\
    % \t2 {} \circelse pc = 33 \circthen HandleAloadEPC(5) \circseq pc := 34 \\
    % \t2 {} \circelse pc = 34 \circthen HandleInvokevirtualEPC(50) \\
    % \t2 {} \circelse pc = 35 \circthen HandleAloadEPC(4) \circseq pc := 36 \circseq Poll \circseq HandleIconstEPC(1) \circseq \\
    % \t3 pc := 37 \circseq Poll \circseq HandleIaddEPC \circseq pc := 38 \circseq Poll \circseq HandleAstoreEPC(4) \circseq \\
    % \t3 pc := 39 \\
    % \t2 {} \circelse pc = 36 \circthen HandleIconstEPC(1) \circseq pc := 37 \\
    % \t2 {} \circelse pc = 37 \circthen HandleIaddEPC \circseq pc := 38 \\
    % \t2 {} \circelse pc = 38 \circthen HandleAstoreEPC(4) \circseq pc := 39 \\
    \t2 {} \circelse pc = 39 \circthen HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq \\
    \t3 pc := 41 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 \t2 {} \circelse pc = 40 \circthen HandleIconstEPC(10) \circseq pc := 41 \\
    % \t2 {} \circelse pc = 41 \circthen \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    % \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
    % \t2 {} \circelse pc = 42 \circthen HandleReturnEPC \\
    \t2 {} \cdots {} \\
    \t2 {} \circelse pc = 43 \circthen TPK\_f \\
    \t2 {} \cdots {} \\
    % \t2 {} \circelse pc = 44 \circthen HandleAloadEPC(0) \circseq pc := 45 \\
    % \t2 {} \circelse pc = 45 \circthen HandleIaddEPC \circseq pc := 46 \\
    % \t2 {} \circelse pc = 46 \circthen HandleAloadEPC(0) \circseq pc := 47 \\
    % \t2 {} \circelse pc = 47 \circthen HandleIaddEPC \circseq pc := 48 \\
    % \t2 {} \circelse pc = 48 \circthen HandleIconstEPC(5) \circseq pc := 49 \\
    % \t2 {} \circelse pc = 49 \circthen HandleIaddEPC \circseq pc := 50 \\
    % \t2 {} \circelse pc = 50 \circthen HandleAreturnEPC \\
    \t2 \circfi \circseq Poll \circseq Running \\
    \t1 \circfi
  \end{circus}
  \begin{circus}
    TPK\_f \circdef HandleAloadEPC(0) \circseq pc := 44 \circseq Poll \circseq HandleAloadEPC(0) \circseq pc := 45 \circseq \\
    \t1 Poll \circseq HandleIaddEPC \circseq pc := 46 \circseq Poll \circseq HandleAloadEPC(0) \circseq pc := 47 \circseq \\
    \t1 Poll \circseq HandleIaddEPC \circseq pc := 48 \circseq Poll \circseq HandleIconstEPC(5) \circseq pc := 49 \circseq \\
    \t1 Poll \circseq HandleIaddEPC \circseq pc := 50 \circseq Poll \circseq HandleAreturnEPC
  \end{circus}
  \caption{The $Running$ action after method call resolution}
  \label{method-call-resolution-example-figure}
\end{figure}

Calls to methods with separate actions can then be resolved,
sequencing the method invocation instruction with a call to the
\Circus{} action representing its body and the instructions following
the method call. 
This occurs on line~\ref{algorithm-resolve-method-calls} of the
algorithm, and can be seen in
Figure~\ref{method-call-resolution-example-figure}, which shows our
example after method call resolution has been applied.

The target of each method call can be determined from the parameter to
the method invocation instruction.
This parameter is an index into the constant pool of the current class
that points to a reference to the method being called.
The correct current class for each bytecode instruction is always
known, since the information on the method entries and ends is
contained in the class information, and there is a one-to-one mapping
between classes and blocks of bytecode instructions that form methods.
After the target of the method call has been determined, the
invocation instruction can be sequenced with a call to the
corresponding \Circus{} action.

An example of a resolved method call is $HandleInvokestaticEPC(46)$ in
the sequence of actions at $pc = 21$.
As can be seen from Figure~\ref{example-model-figure}, the constant
pool index $46$ corresponds to the method identifier for the method
\texttt{f()} of \texttt{TPK}.
The sequence of instructions corresponding to this method is in an
action $TPK\_F$, created in the previous step, on
line~\ref{algorithm-separate-complete-methods}.
The invocation instruction $HandleInvokestaticEPC(46)$ is sequenced
with the method action $TPK\_F$, with the $Poll$ action inbetween (to
allow thread switches before the first instruction of the called
method).
The instructions following the method call are then sequenced after
it, with another $Poll$ action (to allow thread switches following the
return instruction).
Method call resolution is described in more detail in
Section~\ref{resolve-method-calls-subsection}, where we define the
\Call{SeparateCompleteMethods}{} and \Call{ResolveMethodCalls}{}
procedures.

\begin{figure}[p!]
  \setlength{\zedindent}{0cm}
  \setlength{\zedtab}{0.5cm}
  \setlength{\zedleftsep}{0.1cm}
  \begin{circus}
    Running \circdef \\
    \t1 \circif frameStack = \emptyset \circthen \Skip \\
    \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
    \t2 {} \circif pc = 0 \circthen TPK\_APEHinit \\
    \t2 {} \cdots {} \\
    \t2 {} \circelse pc = 7 \circthen TPK\_handleAsyncEvent \\
    \t2 {} \cdots {} \\
    \t2 {} \circelse pc = 43 \circthen TPK\_f \\
    \t2 {} \cdots {} \\
    \t2 \circfi \circseq Poll \circseq Running \\
    \t1 \circfi
  \end{circus}
  \vspace{-1cm}
  \begin{circus}
    TPK\_APEHinit \circdef HandleAloadEPC(0) \circseq pc := 1 \circseq Poll \circseq HandleAloadEPC(1) \circseq pc := 2 \circseq \\
    \t1 Poll \circseq HandleAloadEPC(2) \circseq pc := 3 \circseq Poll \circseq HandleAloadEPC(3) \circseq pc := 4 \circseq \\
    \t1 Poll \circseq HandleAloadEPC(4) \circseq pc := 5 \circseq Poll \circseq HandleInvokespecialEPC(8) \circseq \\
    \t1 Poll \circseq AperiodicEventHandler\_APEHinit \circseq Poll \circseq HandleReturnEPC \\
  \end{circus}
  \vspace{-1.5cm}
  \begin{circus}
    TPK\_handleAsyncEvent \circdef HandleNewEPC(27) \circseq pc := 8 \circseq Poll \circseq HandleDupEPC \circseq pc := 9 \circseq \\
    \t1 Poll \circseq HandleAconst\_nullEPC \circseq pc := 10 \circseq Poll \circseq HandleInvokespecialEPC(29) \circseq \\
    \t1 ConsoleConnection\_CCinit \circseq Poll \circseq HandleAstoreEPC(1) \circseq pc := 12 \circseq Poll \circseq \\
    \t1 HandleAloadEPC(1) \circseq pc := 13 \circseq Poll \circseq HandleInvokevirtualEPC(32) \circseq Poll \circseq \\
    \t1 ConsoleConnection\_openInputStream \circseq Poll \circseq  HandleAstoreEPC(2) \circseq pc := 15 \circseq Poll \circseq \\
    \t1 HandleAloadEPC(1) \circseq pc := 16 \circseq Poll \circseq HandleInvokevirtualEPC(36) \circseq Poll \circseq \\
    \t1 ConsoleConnection\_openOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq pc := 18 \circseq Poll \circseq \\
    \t1 HandleIconstEPC(0) \circseq pc := 19 \circseq Poll \circseq HandleAstoreEPC(4) \circseq pc := 20 \circseq Poll \circseq pc := 39 \circseq \\
    \t1 Poll \circseq\circmu Y \circspot HandleAloadEPC(4) \circseq pc := 40 \circseq Poll \circseq HandleIconstEPC(10) \circseq \\
    \t1 pc := 41 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    \t1 \circif value1 \leq value2 \circthen pc := 21 \circseq Poll \circseq HandleAloadEPC(2) \circseq pc := 22 \circseq Poll \circseq \\
    \t2 HandleInvokevirtualEPC(40) \circseq Poll \circseq InputStream\_Read \circseq Poll \circseq \\
    \t2 HandleInvokestaticEPC(46) \circseq Poll \circseq TPK\_f  \circseq Poll \circseq \\
    \t2 HandleAstoreEPC(5) \circseq pc := 25 \circseq Poll \circseq HandleAloadEPC(5) \circseq pc := 26 \circseq Poll \circseq \\
    \t2 HandleIconstEPC(400) \circseq pc := 27 \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    \t2 \circif value1 \leq value2 \circthen pc := 32 \circseq HandleAloadEPC(3) \circseq pc := 33 \circseq Poll \circseq \\
    \t3 HandleAloadEPC(5) \circseq pc := 34 \circseq Poll \circseq HandleInvokevirtualEPC(50) \circseq Poll \circseq \\
    \t3 OutputStream\_write \\
    \t2 {} \circelse value1 > value2 \circthen pc := 28 \circseq HandleAloadEPC(3) \circseq pc := 29 \circseq Poll \circseq \\
    \t3 HandleIconstEPC(0) \circseq pc := 30 \circseq Poll \circseq HandleInvokevirtualEPC(50) \circseq \\
    \t3 OutputStream\_write \\
    \t2 \circfi \circseq pc := 35 \circseq Poll \circseq HandleAloadEPC(4) \circseq pc := 36 \circseq Poll \circseq HandleIconstEPC(1) \circseq \\
    \t2 pc := 37 \circseq Poll \circseq HandleIaddEPC \circseq pc := 38 \circseq Poll \circseq HandleAstoreEPC(4) \circseq \\
    \t2 pc := 39 \circseq Poll \circseq Y \\
    \t1 {} \circelse value1 > value2 \circthen \Skip \\
    \t1 \circfi \circseq pc := 42 \circseq Poll \circseq HandleReturnEPC
  \end{circus}
  \caption{The $Running$ action after all the methods are separated}
  \label{final-method-separation-example-figure}
\end{figure}

As mentioned previously, these steps are then repeated, in the loop
beginning at line~\ref{algorithm-method-loop} of
Algorithm~\ref{epc-algorithm} to introduce the loops and conditionals
in methods that have unresolved method calls in the middle of loops
and conditionals.
Afterwards, those methods can be separated out and this loop,
conditional and method resolution repeated until every method has been
separated out in this way.
This will always terminate, since we do not allow recursion so there
in dependencies between methods.

The $Running$ action of our example at the end of the loop
in~\ref{epc-algorithm}, when all loops and conditionals have been
introduced, all the methods have been separated out, and all method
calls have been resolved, is shown in
Figure~\ref{final-method-separation-example-figure}.
At this point, the choice over the $pc$ value maps entry points of
methods onto the actions representing those methods, with the other
$pc$ values now redundant.

\begin{figure}[t!]
  \setlength{\zedindent}{0cm}
  \setlength{\zedtab}{0.3cm}
  \setlength{\zedleftsep}{0.1cm}
  \begin{circusaction}
    ExecuteMethod \circdef \circval cid : ClassID; mid : MethodID \circspot \\
    \t1 \circif (cid, mid) = (TPKClassID, APEHinit) \circthen TPK\_APEHinit \\
    \t1 {} \circelse (cid, mid) = (TPKClassID, handleAsyncEvent) \circthen TPK\_handleAsyncEvent \\
    \t1 {} \circelse (cid, mid) = (TPKClassID, f) \circthen TPK\_f \\
    \t1 {} \cdots {} \\
    \t1 \circfi
  \end{circusaction}
  \begin{circusaction}
    MainThread \circdef initMainThread?stack \then frameStackID := Initialised~stack \circseq \circmu X \circspot \\
    \t1 \circblockbegin \circblockbegin
    \circvar classID : ClassID; methodID : MethodID; methodArgs : \seq Word; class : Class \circspot \\
    executeMethod?t \prefixcolon (t = thread) ?c?m?a \then classID, methodID, methodArgs := c, m, a \circseq \\
    \lschexpract ResolveMethod[cs/cs?] \rschexpract \circseq \\
    \lschexpract \exists baseFrame? == \true @ InterpreterNewStackFrameEPC \rschexpract \circseq \\
    ExecuteMethod(classID, methodID) \circseq X \circblockend \\
    {} \extchoice {} \\
    CEEswitchThread?from?to \prefixcolon (from = thread) \then Blocked \circseq X
    \circblockend
  \end{circusaction}
  \begin{circusaction}
    NotStarted \circdef \\
    \t1 \circvar classID : ClassID; methodID : MethodID; methodArgs : \seq Word; class : Class \circspot \\
    \t1 CEEstartThread?toStart?bsid?stack?cid?mid?args \prefixcolon (toStart = thread) \then {} \\
    \t1 addThreadMemory!thread!bsid \then {} \\
    \t1 frameStackID, classID, methodID, methodArgs := Initialised~stack, cid, mid, args \circseq \\
    \t1 \lschexpract ResolveMethod[cs/cs?] \rschexpract \circseq \lschexpract \exists baseFrame? == \true @ InterpreterNewStackFrameEPC \rschexpract \circseq \\
    \t1 Blocked \circseq ExecuteMethod(classID, methodID) \circseq CEEremoveThread!thread \then {} \\
    \t1 CEEswitchThread?from?to \prefixcolon (from = thread) \then NotStarted
  \end{circusaction}
  \caption{The $ExecuteMethod$, $MainThread$, and $NotStarted$ actions
    after main action refinement}
  \label{refine-main-actions-example-figure}
\end{figure}

\begin{figure}
  \begin{circus}
    TPK\_handleAsyncEvent \circdef HandleNewEPC(27) \circseq Poll \circseq HandleDupEPC \circseq Poll \circseq \\
    \t1 HandleAconst\_nullEPC \circseq Poll \circseq HandleInvokespecialEPC(29) \circseq Poll \circseq \\
    \t1 ConsoleConnection\_CCinit \circseq Poll \circseq HandleAstoreEPC(1) \circseq Poll \circseq \\
    \t1 HandleAloadEPC(1) \circseq Poll \circseq HandleInvokevirtualEPC(32) \circseq Poll \circseq \\
    \t1 ConsoleConnection\_openInputStream \circseq Poll \circseq  HandleAstoreEPC(2) \circseq Poll \circseq \\
    \t1 HandleAloadEPC(1) \circseq Poll \circseq HandleInvokevirtualEPC(36) \circseq Poll \circseq \\
    \t1 ConsoleConnection\_openOutputStream \circseq Poll \circseq HandleAstoreEPC(3) \circseq Poll \circseq \\
    \t1 HandleIconstEPC(0) \circseq Poll \circseq HandleAstoreEPC(4) \circseq Poll \circseq \\
    \t1 Poll \circseq\circmu Y \circspot HandleAloadEPC(4) \circseq Poll \circseq HandleIconstEPC(10) \circseq \\
    \t1 Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    \t1 \circif value1 \leq value2 \circseq Poll \circseq HandleAloadEPC(2) \circseq Poll \circseq \\
    \t2 HandleInvokevirtualEPC(40) \circseq Poll \circseq InputStream\_Read \circseq Poll \circseq \\
    \t2 HandleInvokestaticEPC(46) \circseq Poll \circseq TPK\_f  \circseq Poll \circseq \\
    \t2 HandleAstoreEPC(5) \circseq Poll \circseq HandleAloadEPC(5) \circseq Poll \circseq \\
    \t2 HandleIconstEPC(400) \circseq Poll \circseq \circvar value1, value2 : Word \circspot InterpreterPop2 \circseq \\
    \t2 \circif value1 \leq value2 \circthen HandleAloadEPC(3) \circseq Poll \circseq \\
    \t3 HandleAloadEPC(5) \circseq Poll \circseq HandleInvokevirtualEPC(50) \circseq Poll \circseq \\
    \t3 OutputStream\_write \\
    \t2 {} \circelse value1 > value2 \circthen HandleAloadEPC(3) \circseq Poll \circseq \\
    \t3 HandleIconstEPC(0) \circseq Poll \circseq HandleInvokevirtualEPC(50) \circseq \\
    \t3 OutputStream\_write \\
    \t2 \circfi \circseq Poll \circseq HandleAloadEPC(4) \circseq Poll \circseq HandleIconstEPC(1) \circseq \\
    \t2 Poll \circseq HandleIaddEPC \circseq Poll \circseq HandleAstoreEPC(4) \circseq \\
    \t2 Poll \circseq Y \\
    \t1 {} \circelse value1 > value2 \circthen \Skip \\
    \t1 \circfi \circseq Poll \circseq HandleReturnEPC
  \end{circus}
  \caption{The $HandleAsyncEvent$ action after $pc$ has been eliminated from the state}
  \label{pc-elimination-HandleAsyncEvent-example-figure}
\end{figure}

The next step is then to eliminate these redundant paths and remove
the dependency on $pc$ to select the method action.
This occurs at line~\ref{algorithm-refine-main-actions} of
Algorithm~\ref{epc-algorithm}, in which the $NotStarted$ and
$MainThread$ actions are refined to replace the $Running$ action with
an $ExecuteMethod$ action that contains a choice of method action
based on the method and class identifier of the method.
This can be seen in Figure~\ref{refine-main-actions-example-figure},
which shows the $ExecuteMethod$ action corresponding to our example,
and the refined $NotStarted$ and $MainThread$ actions that reference
it.
We describe this refinement in more detail in
Section~\ref{refine-main-actions-subsection}, where we define the
\Call{RefineMainActions}{} procedure.

When all of the previous steps are completed, reliance on $pc$ to
determine control flow has been completely removed.
The $pc$ state component can then be removed in a simple data
refinement that also removes all the assignments to $pc$, resulting in
the $HandleAsyncEvent$ action shown in
Figure~\ref{pc-elimination-HandleAsyncEvent-example-figure}.
The data refinement to remove $pc$ is applied at the end of the
algorithm, on line~\ref{algorithm-remove-pc-from-state}, and is
described in more detail in
Section~\ref{remove-pc-from-state-subsection}, where we define the
\Call{RemovePCFromState}{} procedure.

The remaining instruction handling actions then only affect the stack,
the removal of which is the concern of the next stage of the
compilation strategy.

We now proceed to describe each of the steps of
Algorithm~\ref{epc-algorithm} in more detail.

\FloatBarrier

\subsection{Expand Bytecode}
\label{expand-bytecode-subsection}

Before the control flow can be introduced, the bytecode instructions
provided in the $bc$ parameter to $Thr$ must be expanded to allow
consideration of their semantics.
This is achieved using the procedure shown in
Algorithm~\ref{expand-bytecode-algorithm}.
\begin{algorithm}
  \begin{algorithmic}[1]
    \State \ApplyFor{Rule~[\nameref{pc-expansion-rule}]}{$bc$}
    \label{algorithm-introduce-choice-over-pc}
    \State \ApplyFor{Law~[\nameref{action-intro-law}]}{$Handle{*}EPC$ actions}
    \label{algorithm-introduce-handleEPC-actions}
    \For{$i \gets \dom bc$}
    \label{algorithm-expand-bytecode-loop}
    \State \ApplyFor{Rule~[\nameref{HandleInstruction-refinement-rule}]}{$bc$, $i$}
    \label{algorithm-HandleInstruction-refinement}
    \EndFor
  \end{algorithmic}
  \caption{ExpandBytecode}
  \label{expand-bytecode-algorithm}
\end{algorithm}
It begins on line~\ref{algorithm-introduce-choice-over-pc} by
applying Rule~[\nameref{pc-expansion-rule}], shown below.
It introduces a choice over all the possible values of $pc$ in the
domain of $bc$ at the $HandleInstruction$ action in $Running$.
This does not affect the behaviour of $HandleInstruction$, because it
behaves as $\Chaos$ when $pc$ is outside the domain of $bc$.
We write $HandleInstruction$ with a $bc$ subscript to indicate that it
makes use of $bc$, which is a parameter of the $Thr$ process in which
$HandleInstruction$ occurs. 
\begin{restatable}[$pc$-expansion]{crule}{PCExpansionRule}
  \label{pc-expansion-rule}
  Given $bc : ProgramAddress \pfun Bytecode$,
  \begin{circus}
    HandleInstruction_{bc} = \circif {} \circelse_{i\in\dom bc} pc = i \then HandleInstruction_{bc} \circfi
  \end{circus}
\end{restatable}
The proof of this rule and others can be found in
Appendix~\ref{compilation-rules-proofs-appendix}.
After applying Rule~[\nameref{pc-expansion-rule}], we operate on the
occurrence of $HandleInstruction$ at each branch of the conditional at
line~\ref{algorithm-expand-bytecode-loop}.
We apply Rule~[\nameref{HandleInstruction-refinement-rule}], shown
below, on line~\ref{algorithm-HandleInstruction-refinement} to refine
each occurrence to a more specific form that is easier to operate on
during the rest of the strategy.
These new actions are determined from the bytecode instruction in $bc$
at each $pc$ value by applying a syntactic function $handleAction$,
which is defined by Table~\ref{handle-action-table}.
\begin{restatable}[$HandleInstruction$-refinement]{crule}{HandleInstructionRefinementRule}
  \label{HandleInstruction-refinement-rule}
  Given $bc : ProgramAddress \pfun Bytecode$ and
  $i : ProgramAddress$, if $i \in \dom bc$ then,
  \begin{circus}
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \then HandleInstruction_{bc} \\
      {} \cdots {} \\
      \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circif {} \cdots {} \\
      {} \circelse pc = i \then handleAction(bc~i) \\
      {} \cdots {} \\
      \circfi
    \end{array}
  \end{circus}
  where $handleAction$ is a syntactic function defined by
  Table~\ref{handle-action-table}.
\end{restatable}
\begin{table}
  \centering
  \begin{tabular}{lp{8.5cm}}
    \hline
    Bytecode ($bc~i$) & Action ($handleAction(bc~i)$) \\
    \hline
    $aconst\_null$ & $HandleAconst\_nullEPC \circseq pc := i+1$ \\
    $dup$ & $HandleDupEPC \circseq pc := i+1$ \\
    $aload~lvi$ & $HandleAloadEPC(lvi) \circseq pc := i+1$ \\
    $astore~lvi$ & $HandleAstoreEPC(lvi) \circseq pc := i+1$ \\
    $iadd$ & $HandleIaddEPC \circseq pc := i+1$ \\
    $iconst~n$ & $HandleIconstEPC(n) \circseq pc := i+1$ \\
    $ineg$ & $HandleInegEPC \circseq pc := i+1$ \\
    $goto~ofst$ & $pc := i+ofst$ \\
    $if\_icmple~ofst$ & $\circvar value1, value2 : Word \circspot$ \endgraf
                         \t1 $\lschexpract InterpreterPop2EPC \rschexpract \circseq$ \endgraf
                         \t1 $pc := \IF value1 \leq value2 \THEN i+ofst \ELSE i+1$ \\
    $areturn$ & $HandleAreturnEPC$ \\
    $return$ & $HandleReturnEPC$ \\
    $new~cpi$ & $HandleNewEPC(cpi) \circseq pc := i+1$ \\
    $getfield~cpi$ & $HandleGetfieldEPC(cpi) \circseq pc := i+1$ \\
    $putfield~cpi$ & $HandlePutfieldEPC(cpi) \circseq pc := i+1$ \\
    $getstatic~cpi$ & $HandleGetstaticEPC(cpi) \circseq pc := i+1$ \\
    $putstatic~cpi$ & $HandlePutstaticEPC(cpi) \circseq pc := i+1$ \\
    $invokevirtual~cpi$ & $\{pc = i\} \circseq HandleInvokevirtualEPC(cpi)$ \\
    $invokespecial~cpi$ & $\{pc = i\} \circseq HandleInvokespecialEPC(cpi)$ \\
    $invokestatic~cpi$ & $\{pc = i\} \circseq HandleInvokestaticEPC(cpi)$ \\
    \hline
  \end{tabular}
  \caption{The syntactic function $handleAction$}
  \label{handle-action-table}
\end{table}
The actions generated by $handleAction$ use new actions for handling
the individual bytecode instructions.
These are similar to the actions used to define $HandleInstruction$
(e.g.\ $HandleDup$, $HandleAload$ etc.), which we refer to as
$Handle*$ actions.
We name the new actions used by $handleAction$ by appending $EPC$ to
the names of the $Handle*$ actions they are based on, and we refer to
them as $Handle{*}EPC$ actions.
The $Handle{*}EPC$ actions are introduced on
line~\ref{algorithm-introduce-handleEPC-actions} of
Algorithm~\ref{expand-bytecode-algorithm}, before the application of
Rule~[\nameref{HandleInstruction-refinement-rule}], by application of
Law~[\nameref{action-intro-law}], which introduces unused actions to
processes.

In addtion to the $Handle{*}EPC$ actions, the actions output from
$handleAction$ also include $pc$ updates extracted from the $Handle*$
actions.
The output from $handleAction$ for the $goto$ and $if\_icmple$
instructions consists solely of a $pc$ update with no $Handle{*}EPC$
actions, since updating the value of pc is the main effect of those
instructions.

The differences between the $Handle{*}EPC$ actions and the $Handle*$
actions on which they are based are explained using the $HandleAstore$
action as an example.
We recall that it is defined as shown below.
\begin{circusaction}
  HandleAstore \circdef \lcircguard pc \in \dom bc \land bc~pc \in \ran astore \rcircguard \circguard \\
  \t1 \circvar variableIndex : \nat \circspot variableIndex := (astore\inv)~(bc~pc) \circseq \lschexpract InterpreterAstore \rschexpract
\end{circusaction}
Its corresponding $Handle{*}EPC$ action, $HandleAstoreEPC$, is shown
below.
\begin{circusaction}
  HandleAstoreEPC \circdef \circval variableIndex : \nat \circspot \lschexpract InterpreterAstoreEPC \rschexpract
\end{circusaction}
The first difference of $HandleAstoreEPC$ from $HandleAstore$ is that
it is not guarded by the condition on the value of $bc$ at the current
$pc$ value.
The choice that such guards mediate is collapsed by
Rule~[\nameref{HandleInstruction-refinement-rule}], since the value of
$bc$ at a given $pc$ value is determined by the supplied $bc$
parameter of $Thr$.

The second difference is that the parameters of the bytecode
instructions are transferred to become parameters of the
$Handle{*}EPC$ actions, so $HandleAstoreEPC$ has a $variableIndex$
parameter.
This corresponds to the $variableIndex$ variable in $HandleAstore$,
which is used to store the value extracted from the $astore$
instruction.
This transformation is, of course, not performed for instructions that
do not take parameters.
This transformation is standard in the context of a call to a
parametrised action.

Finally, the schema $InterpreterAstore$ is replaced with a schema
$InterpreterAstoreEPC$, which does not affect $pc$, since the updates to
$pc$ are extracted from the $Handle{*}$ actions by
Rule~[\nameref{HandleInstruction-refinement-rule}].
The $pc$ updates are not removed in the case of the actions for
handling method invocation and return, where the $pc$ updates are
closely connected to the operations on the stack and require special
handling.
Instead, an assumption on the value of $pc$ is introduced for the
method invocation handling actions, since the $pc$ information is used
in setting the return address.
We discuss how we operate on the method invocation and return handling
actions in Section~\ref{resolve-method-calls-subsection}.

At the end of Algorithm~\ref{expand-bytecode-algorithm}, our example
has the form shown earlier in
Figure~\ref{bytecode-expansion-example-figure}.
After the bytecode semantics is expanded in the $Running$ action by
this step, the control flow that corresponds to each $pc$ update can
be introduced.
This is dicussed in the next section.

\subsection{Introduce Sequential Composition}
\label{introduce-forward-sequence-subsection}

\begin{algorithm}
  \begin{algorithmic}[1]
    \State $cfg \gets$ \Call{MakeControlFlowGraph}{}
    \label{algorithm-make-control-flow-graph}
    \For{$node \gets cfg$}
    \label{algorithm-sequence-cfg-loop}
    \While{\Call{HasSimpleSequence}{$node$}}
    \label{algorithm-forward-sequence-condition}
    \State \ApplyFor{Rule~[\nameref{sequence-introduction-rule}]}{$node$}
    \label{algorithm-forward-sequence-application}
    \EndWhile
    \EndFor
  \end{algorithmic}
  \caption{IntroduceSequentialComposition}
  \label{introduce-forward-sequence-algorithm}
\end{algorithm}
The simplest control flows to introduce are those of instructions
where execution continues at the next program counter value.
These control flows are introduced as shown in
Algorithm~\ref{introduce-forward-sequence-algorithm}, which defines
the \Call{IntroduceSequentialComposition}{} procedure.
The algorithm constructs a control flow graph for each method in the
program, as specified on line~\ref{algorithm-make-control-flow-graph}.
Since the introduction of sequential composition does not depend on
the relationships between methods, the control flow graph is
constructed as a disconnected graph containing the control flow of all
the methods in the program.
The nodes in this graph correspond to the branches in the choice over
$pc$ values introduced in the previous section.

We construct the control flow graph by starting at the entry point for
each method and following the $pc$ update at the end of each node,
introducing an edge in the process.
For method call instructions, we introduce an edge to the node for the
next $pc$ value, as if the instruction were replaced with
$pc := pc + 1$.
This is consistent with how method calls are handled later in the
strategy, since execution resumes at the next instruction after the
called method returns.
We do not add an edge from a return instruction, since no further
instructions are executed in the method after a return instruction.
We finish construction of the control graph for a method when there
are no further edges to add.
This terminates since there are only finitely many instructions in a
method so edges for all the reachable nodes will eventually be added.


The control flow graph for our example is shown in
Figure~\ref{example-control-flow-graph-figure}.
We label the nodes of the graph with the $pc$ values of the
instructions at the nodes.
Due to our assumptions about the source bytecode, the subgraph
corresponding to each method's control flow is a structured graph as
defined in Section~\ref{compilation-assumptions-section}.

\begin{figure}
  \begin{center}
    \footnotesize
    \begin{tikzpicture}[every new ->/.style={-latex}]
      % \node (start) at (0,0) {};
      \foreach \x in {0,...,6}  { \node (\x) at (\x, 1cm) {\x}; }
      \foreach \x in {7,...,20}  { \node (\x) at (0.85*\x - 0.85*7,0) {\x}; }
      \foreach \x in {21,...,27} { \node (\x) at (0.85*\x - 0.85*21, -2cm) {\x}; }
      \foreach \x in {28,...,31} { \node (\x) at (0.85*\x - 0.85*21, -1cm) {\x}; }
      \foreach \x in {32,...,34} { \node (\x) at (0.85*\x - 0.85*25, -3cm) {\x}; }
      \foreach \x in {35,...,42} { \node (\x) at (0.85*\x - 0.85*24.3, -2cm) {\x}; }
      \foreach \x in {43,...,50} { \node (\x) at (-43+\x, -4.5cm) {\x}; }

      \graph{ (7) -> (8) -> (9) -> (10) -> (11) -> (12) ->
        (13) -> (14) -> (15) -> (16) -> (17) -> (18) -> (19) -> (20)
        -> (39) -> (40) -> (41) -> (42); (21) -> (22) -> (23) -> (24)
        -> (25) -> (26) -> (27) -> {
          (28) -> (29) -> (30) -> (31);
          (32) -> (33) -> (34);
        } -> (35) -> (36) -> (37) -> (38) -> (39);
      };

      \graph{(0) -> (1) -> (2) -> (3) -> (4) -> (5) -> (6)};
      \graph{(43) -> (44) -> (45) -> (46) -> (47) -> (48) -> (49) -> (50)};

      \draw[-latex] (41) edge[out=270,in=270,looseness=0.35] (21);
    \end{tikzpicture}
  \end{center}
  \caption{Control flow graph for our example program}
  \label{example-control-flow-graph-figure}
\end{figure}

After the control flow graph is constructed, we consider each node in
turn, as specified by the for loop on
line~\ref{algorithm-sequence-cfg-loop}.
As mentioned earlier, we require a node to have only a single outgoing
edge and its target to have only a single incoming edge in order for
it to be considered for the introduction of sequential composition.
The reason for this is that nodes with two outgoing edges are points
at which conditionals should be introduced.
Such nodes in our example are the nodes for $pc$ values $27$ and $41$,
which represent the start of conditionals.
Likewise, nodes with multiple incoming edges represent points at which
a more complex control flows occur.
For our example, such nodes include $39$, which is the start of a
loop, and $35$, which is the end of a conditional.
These prevent introduction of sequential composition for the $pc$
values $20$, $31$, $34$, and $38$, since the targets of those nodes
are nodes $35$ and $39$.

For a node that meets the above requirement and is not a method call,
we can introduce sequential composition at that node by applying
Rule~[\nameref{sequence-introduction-rule}], on
line~\ref{algorithm-forward-sequence-application} of the algorithm.
This rule works by unrolling the loop in $Running$ to sequence an
instruction at $pc$ value $i$ with the instruction that is executed
after it, inserting $Poll$ inbetween.
It is required that the $pc$ value of the node's target, $j$, not be
the same as $i$, since that would introduce a loop, rather than a
sequential composition.
Also, the sequence of instructions at the node, $A$, must not affect
the non-emptiness of the $frameStack$ to ensure that the choice at the
start of the main loop in $Running$ can be resolved.
\begin{restatable}[sequence-intro]{crule}{SequenceIntroductionRule}
  \label{sequence-introduction-rule}
  Given $i : ProgramAddress$, if $i \neq j$ and \def\zedindent{0.25cm}
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then,
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif {} \cdots {} \\
      \t2 {} \circelse pc = i \circthen A \circseq pc := j \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = j \circthen B \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif {} \cdots {} \\
      \t2 {} \circelse pc = i \circthen {} \\
      \t3 A \circseq pc := j \circseq Poll \circseq B \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = j \circthen B \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
  \end{circus}
\end{restatable}

Since Rule~[\nameref{sequence-introduction-rule}] pulls two nodes
together, we can continue to introduce sequential composition at a
node after the first application of
Rule~[\nameref{sequence-introduction-rule}], until that node no longer
satisfies the conditions for introducing sequential composition.
This is specified by the while loop at
line~\ref{algorithm-forward-sequence-condition} of the algorithm.
This means the control flow graph is updated as
Rule~[\nameref{sequence-introduction-rule}] is applied, to take into
account the merging of nodes.
Since there are finitely many nodes, the merging of nodes eventually
results in a graph in which no further sequential compositions can be
introduced and so the loop terminates.

The resulting control flow graph after introduction of sequential
composition has been performed at every point is shown in
Figure~\ref{example-control-flow-graph-after-sequence-introduction-figure}.
We note that this graph is still a union of structured graphs since
merging sequentially composed nodes does not affect whether a graph is
structured.
This is due to the fact that sequential composition is one of the
constructs used to define structured control flow graphs
(Figure~\ref{sequence-figure}), and merging the nodes may be seen as
performing the reverse of node replacement for it.
\begin{figure}
  \begin{center}
    \begin{tikzpicture}[every new ->/.style={-latex}]
      \path (0,0) node (0) {0} -- ++(1,0) node (6) {6};
      \path (0,-1cm) node (7) {7} -- ++(1,0) node (11) {11} -- ++(1,0) node (14) {14} -- ++(1,0) node (17) {17};
      \path (0,-3cm) node (21) {21} -- ++(1,0) node (23) {23} -- ++(1,0) node (24) {24};
      \path (3,-2.3cm) node (28) {28} -- ++(1,0) node (31) {31};
      \node at (3,-3.7cm) (32) {32};
      \path (5,-3cm) node (35) {35} -- ++(1,0) node (39) {39} -- ++(1,0) node (42) {42};
      
      \graph{
        (7) -> (11) -> (14) -> (17) -> (39) -> (42);
        (21) -> (23) -> (24) -> {
          (28) -> (31);
          (32);
        } -> (35) -> (39);
      };

      \graph[grow down]{(0) -> (6)};
      \node at (0,-5cm) {43};

      \draw[-latex] (39) edge[out=270,in=270,looseness=0.6] (21);
    \end{tikzpicture}
  \end{center}
  \caption{Control flow graph for our example after sequential composition introduction}
  \label{example-control-flow-graph-after-sequence-introduction-figure}
\end{figure}

The only remaining nodes in this graph are those where the sequence of
instructions ends with a method call or return, or which represent a
more complex control flow.
In particular, the instructions for the \texttt{f()} method of
\texttt{TPK}, which begin at $pc = 43$, have been completely sequenced
together into a single node.
The code that corresponds to this control flow graph is that shown
earlier in Figure~\ref{forward-sequence-introduction-example-figure}

\subsection{Introduce Loops and Conditionals}
\label{introduce-loops-and-conditionals-subsection}

After sequential composition has been introduced for all methods, we
must begin considering each method separately to ensure method calls
are handled properly.
This means the strategy must loop, introducing loops and conditionals
to those methods that have no unresolved method calls and resolving
calls of methods that are then complete, until every method is
complete and has been separated into its own action.
Introducing loops and conditionals is performed as described by
Algorithm~\ref{introduce-loops-and-conditionals-algorithm}.
This considers each method individually, as specified by the for loop
on line~\ref{algorithm-introduce-loops-and-conditionals-method-loop}
of the algorithm. 
The condition on line~\ref{algorithm-no-unresolved-calls-condition}
ensures that only those methods where all method calls have already
been resolved undergo loop and conditional introduction.

\begin{algorithm}
  \begin{algorithmic}[1]
    \Procedure{IntroduceLoopsAndConditionals}{}
    \For{$m \gets methods$}
    \label{algorithm-introduce-loops-and-conditionals-method-loop}
    \If{\Call{HasNoUresolvedCalls}{$m$}}
    \label{algorithm-no-unresolved-calls-condition}
    \State $cfg \gets$ \Call{MakeControlFlowGraph}{$m$}
    \label{algorithm-make-control-flow-graph2}
    \For{$node \gets$ \Call{ReverseNodes}{$cfg$}}
    \label{algorithm-node-checking-loop}
    \State \Call{ApplyRule[\nameref{if-introduction-rule}]}{$node$}
    \label{algorithm-introduce-if}
    \State \Call{ApplyRule[\nameref{if-else-introduction-rule}]}{$node$}
    \label{algorithm-introduce-if-else}
    \If{\Call{IsSimpleConditional}{$node$}}
    \label{algorithm-conditional-check}
    \State \Call{ApplyRule[\nameref{conditional-introduction-rule}]}{$node$}
    \label{algorithm-introduce-conditional}
    \EndIf
    \State \Call{ApplyRule[\nameref{while-introduction-rule1}]}{$node$}
    \label{algorithm-introduce-while1}
    \State \Call{ApplyRule[\nameref{while-introduction-rule2}]}{$node$}
    \label{algorithm-introduce-while2}
    \State \Call{ApplyRule[\nameref{do-while-introduction-rule}]}{$node$}
    \label{algorithm-introduce-do-while}
    \State \Call{ApplyRule[\nameref{infinite-loop-introduction-rule}]}{$node$}
    \label{algorithm-introduce-infinite-loop}
    \If{\Call{HasSimpleSequence}{$node$}}
    \label{algorithm-lci-sequence-check}
    \State
    \Call{ApplyRule[\nameref{sequence-introduction-rule}]}{$node$}
    \label{algorithm-lci-sequence-introduction}
    \EndIf

    \EndFor
    \EndIf
    \EndFor
    \EndProcedure
  \end{algorithmic}
  \caption{Introduce Loops and Conditionals}
  \label{introduce-loops-and-conditionals-algorithm}
\end{algorithm}

For each method that undergoes loop and conditional introduction, we
must again consider the control flow graph of the method to ensure the
loops and conditionals are introduced in the correct order to properly
form the bodies of loops and conditionals.
This involves constructing a control flow graph for the method, at
line~\ref{algorithm-make-control-flow-graph2}, beginning at the entry
point of the method and following each \texttt{goto} and
\texttt{if\_icmple} instruction until a loop is detected or a
\texttt{return} or \texttt{areturn} instruction is reached.
The graph for the our example, beginning at $pc=7$ (the entry point of
the \texttt{handleAsyncEvent()} method), is shown in
Figure~\ref{example-simplified-control-flow-graph-figure}, alongside
the \Circus{} code obtained at the beginning of this stage for the
method.
The edge which forms a loop from $pc=35$ to $pc=39$ is shown as a
dashed line since looping edges are ignored at certain points in this
part of the strategy.
\begin{figure}
  \begin{center}
    \begin{multicols}{4}
      \begin{tikzpicture}
        \node (7)  at (0,0)  {7};
        \node (39)  at (0,-1) {39};
        \node (42) at (-1,-2) {42};
        \node (21) at (1,-2) {21};
        \node (28) at (0.5,-3) {28};
        \node (32) at (1.5,-3) {32};
        \node (35) at (1,-4) {35};
        \draw[-latex] (7) to (39);
        \draw[-latex] (39) to (42);
        \draw[-latex] (39) to (21);
        \draw[-latex] (21) to (28);
        \draw[-latex] (21) to (32);
        \draw[-latex] (28) to (35);
        \draw[-latex] (32) to (35);
        % \draw[-latex,red!70!black,dashed,out=0,in=0,looseness=1.1] (35) to (39);
        \draw[-latex,dashed,out=0,in=0,looseness=1.1] (35) to (39);
      \end{tikzpicture}
      \columnbreak
      \scriptsize
      \setlength{\zedindent}{0cm}
      \begin{circus}
        Running \circdef \\
        \t1 \circif frameStack = \emptyset \circthen \Skip \\
        \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
        \t2 \circif pc = 0 \circthen {} \cdots {} \\
        \t2 {} \circelse pc = 7 \circthen HandleNewEPC(27) \circseq pc := 8 \circseq Poll \circseq \cdots \circseq pc := 39 \\
        \t2 {} \cdots {} \\
        \t2 {} \circelse pc = 21 \circthen HandleAloadEPC(2) \circseq pc := 22 \circseq Poll \circseq \cdots \circseq \\
        \t3 pc := \IF value1 \leq value2 \THEN 32 \ELSE 28 \\
        \t2 {} \cdots {} \\
        \t2 {} \circelse pc = 28 \circthen HandleAloadEPC(3) \circseq pc := 29 \circseq Poll \circseq \cdots \circseq pc := 35 \\
        \t2 {} \cdots {} \\
        \t2 {} \circelse pc = 32 \circthen HandleAloadEPC(3) \circseq pc := 33 \circseq Poll \circseq \cdots \circseq pc := 35 \\
        \t2 {} \cdots {} \\
        \t2 {} \circelse pc = 35 \circthen HandleAloadEPC(4) \circseq pc := 36 \circseq Poll \circseq \cdots \circseq pc := 39 \\
        \t2 {} \cdots {} \\
        \t2 {} \circelse pc = 39 \circthen HandleAloadEPC(4) \circseq pc := 36 \circseq Poll \circseq \cdots \circseq \\
        \t3 pc := \IF value1 \leq value2 \THEN 21 \ELSE 42 \\
        \t2 {} \cdots {} \\
        \t2 {} \circelse pc = 42 \circthen HandleReturnEPC \\
        \t2 \circfi \circseq Poll \circseq Running \\
        \t1 \circfi
      \end{circus}
    \end{multicols}
  \end{center}
  \caption{Simplified control flow graph and corresponding code for our example
    program}
  \label{example-simplified-control-flow-graph-figure}
\end{figure}

% A method's control flow graph must be well-structured in order to
% properly introduce the control flow structures in this section.
% We define a rooted directed graph below. The definition is standard,
% but we include it here to introduce the terminology for the subsequent
% definition of what we mean by a structured control flow graph.
% \begin{defn}[Rooted Directed Graph] A \emph{rooted directed graph},
% $G$, is a triple $(V,E,r)$, where
%   \begin{itemize}
%   \item $V$ is a set of \emph{nodes},
%   \item $E$ is a set of ordered pairs of nodes in $V$, called
% \emph{edges}, and
%   \item $r$ is a node in $V$, called the \emph{root} of the graph.
%   \end{itemize} The first component of an edge is its \emph{source}
% and the second component is its \emph{target}. We say that an edge
% goes from its source to its target. The source of an edge going to a
% given node is said to be a \emph{predecessor} of that node; similarly,
% the target of an edge from a given node is a \emph{successor} of that
% node. For every node $n \in V$, the pair $(r,n)$ must be in the
% reflexive transitive closure of $E$, that is, there must be a path of
% edges from the root to any node in the graph.
  
%   In diagrams we represent the nodes as points or as the names of the
% nodes, the edges as arrows, and the root node as a node with an arrow
% pointing to it that does not come from another node. For a graph $G$,
% we refer to the set $T(G) = \{ n \in V | \forall m \in V.\; (n,m)
% \notin E\}$ of nodes with no edges coming from them as the set of
% \emph{end nodes} of the graph.
% \end{defn}
% Having defined a rooted directed graph, we now define what we mean by
% a structured control flow graph as a specific type of rooted directed
% graph.
% This definition we use for a structured program is based on Dijkstra's
% notion of program structure found in~\cite{dijkstra1972}.
% In that definition, there are a set of known program structures that
% are permitted, and these structures may contain further occurrences of
% the same structures (e.g.\ a conditional in which each branch is also
% a conditional).
% In order to formalise this, we first define what it means to replace a
% node with a graph.
% \begin{defn}[Node Replacement]
%   Given two rooted directed graphs $G$ and $H$, we say $G'$ is the
%   graph formed by \emph{replacing} a node $n$ of $G$ with $H$ if one
%   of the following cases holds:
%   \begin{itemize}
%   \item $n$ has no predecessors in $G$, $H$ has only one end node, and
%     \begin{itemize}
%     \item $G'$ contains all the nodes of $H$ and $G$, except $n$,
%     \item $G'$ contains the edges of $G$ except those going to or from
%       $n$,
%     \item $G'$ contains edges from the end node of $H$ to the
%       successors of $n$ in $G$, and
%     \item the root node of $H$ is the root node of $G'$;
%     \end{itemize}
%   \item $n$ has no successors in $G$, and
%     \begin{itemize}
%     \item $G'$ contains all the nodes of $H$ and $G$, except $n$,
%     \item $G'$ contains the edges of $G$ except those going to or from
%       $n$,
%     \item $G'$ contains edges from the predecessors $n$ in $G$ to the
%       root node of $H$, and
%     \item the root node of $G$ is the root node of $G'$;
%     \end{itemize}
%   \item $H$ has a single end node and
%     \begin{itemize}
%     \item $G'$ contains all the nodes of $H$ and $G$, except $n$,
%     \item $G'$ contains the edges of $G$ and the edges of $H$ except
%       those going to or from $n$,
%     \item $G'$ contains edges from the predecessors of $n$ in $G$ to
%       the root node of $H$,
%     \item $G'$ contains edges from the end node of $H$ to the
%       successors of $n$ in $G$, and
%     \item the root node of $G$ is the root node of $G'$;
%     \end{itemize}
%   \item $n$ has a single successor in $G$, $H$ has a single end
%     node, and
%     \begin{itemize}
%     \item $G'$ contains all the nodes of $H$ and $G$, except $n$ and
%       the end node of $H$,
%     \item $G'$ contains the edges of $G$ except those going to or from
%       $n$,
%     \item $G'$ contains edges from the predecessors of the end node of
%       $H$ to the successor of $n$ in $G$
%     \item $G'$ contains edges from the predecessors of $n$ in $G$ to
%       the root node of $H$, and
%     \item the root node of $G$ is the root node of $G'$.
%     \end{itemize}
%   \end{itemize}
% \end{defn}
% Each of the different cases of node replacement represents a different
% way of placing a graph inside another graph.
% We show an example of each of these cases in
% Figure~\ref{node-replacement-example-figures}.
% The example used is that of an \texttt{if}-\texttt{else} conditional,
% introduced later in Figure~\ref{if-else-figure}, with one of its nodes
% replaced with another \texttt{if}-\texttt{else} conditional whose
% nodes are shown in white.

% The first case (Figure~\ref{root-replacement-figure}) is that of
% placing a graph at the start of another graph, i.e.\ replacing the
% root node of a graph that does not have a loop to its root node.
% The second case (Figure~\ref{end-replacement-figure}) is that of
% replacing one of the end nodes of a graph.
% The third case (Figure~\ref{internal-replacement-figure}) is that of
% replacing an internal node of the graph. 
% There must be a single end node in this case in order to have a source
% for the outgoing edges of the replaced node.
% At the end of one of the branches of a conditional, the end node of
% the replacing graph may be unified with the node at the end of the
% conditional.
% This represents such cases as loops and conditionals occurring at the
% end of a branch of a conditional, with no instructions following them
% inside the conditional, and is handled by the fourth case of node
% replacement, shown in Figure~\ref{branch-end-replacement-figure}.
% \begin{figure}
%   \begin{subfigure}{0.24\textwidth}
%     \begin{center}
%       \begin{tikzpicture}
%         \node at (0,2) (start) {};
%         \node at ( 0, 1)  (A) {$\circ$};
%         \node at (-1, 0)  (B) {$\circ$};
%         \node at ( 1, 0)  (C) {$\circ$};
%         \node at ( 0,-1)  (D) {$\circ$};
%         \node at (-1,-2)  (E) {$\bullet$};
%         \node at ( 1,-2)  (F) {$\bullet$};
%         \node at ( 0,-3)  (G) {$\bullet$};
%         \draw[-latex] (start) -- (A);
%         \draw[-latex] (A) -- (B);
%         \draw[-latex] (A) -- (C);
%         \draw[-latex] (B) -- (D);
%         \draw[-latex] (C) -- (D);
%         \draw[-latex] (D) -- (E);
%         \draw[-latex] (D) -- (F);
%         \draw[-latex] (E) -- (G);
%         \draw[-latex] (F) -- (G);
%       \end{tikzpicture}
%     \caption{\centering root node\newline replacement}
%     \label{root-replacement-figure}
%   \end{center}
%   \end{subfigure}
%   \begin{subfigure}{0.24\textwidth}
%     \begin{center}
%       \begin{tikzpicture}
%         \node at (0,2) (start) {};
%         \node at ( 0, 1)  (A) {$\bullet$};
%         \node at (-1, 0)  (B) {$\bullet$};
%         \node at ( 1, 0)  (C) {$\bullet$};
%         \node at ( 0,-1)  (D) {$\circ$};
%         \node at (-1,-2)  (E) {$\circ$};
%         \node at ( 1,-2)  (F) {$\circ$};
%         \node at ( 0,-3)  (G) {$\circ$};
%         \draw[-latex] (start) -- (A);
%         \draw[-latex] (A) -- (B);
%         \draw[-latex] (A) -- (C);
%         \draw[-latex] (B) -- (D);
%         \draw[-latex] (C) -- (D);
%         \draw[-latex] (D) -- (E);
%         \draw[-latex] (D) -- (F);
%         \draw[-latex] (E) -- (G);
%         \draw[-latex] (F) -- (G);
%       \end{tikzpicture}
%     \caption{\centering end node\newline replacement}
%     \label{end-replacement-figure}
%     \end{center}
%   \end{subfigure}
%   \begin{subfigure}{0.24\textwidth}
%     \begin{center}
%       \begin{tikzpicture}
%         \node at (0,3) (start) {};
%         \node at ( 0, 2)  (A) {$\bullet$};
%         \node at (-1, 1)  (B) {$\circ$};
%         \node at ( 1, 0)  (C) {$\bullet$};
%         \node at (-2, 0)  (D) {$\circ$};
%         \node at ( 0, 0)  (E) {$\circ$};
%         \node at (-1,-1)  (F) {$\circ$};
%         \node at ( 0,-2)  (G) {$\bullet$};
%         \draw[-latex] (start) -- (A);
%         \draw[-latex] (A) -- (B);
%         \draw[-latex] (A) -- (C);
%         \draw[-latex] (B) -- (D);
%         \draw[-latex] (B) -- (E);
%         \draw[-latex] (D) -- (F);
%         \draw[-latex] (E) -- (F);
%         \draw[-latex] (F) -- (G);
%         \draw[-latex] (C) -- (G);
%       \end{tikzpicture}
%       \caption{\centering internal node\newline replacement}
%       \label{internal-replacement-figure}
%     \end{center}
%   \end{subfigure}
%   \begin{subfigure}{0.24\textwidth}
%     \begin{center}
%       \begin{tikzpicture}
%         \node at (0,3) (start) {};
%         \node at ( 0, 2)  (A) {$\bullet$};
%         \node at (-1, 1)  (B) {$\circ$};
%         \node at ( 1, 0)  (C) {$\bullet$};
%         \node at (-2, 0)  (D) {$\circ$};
%         \node at ( 0, 0)  (E) {$\circ$};
%         \node at ( 0,-2)  (F) {$\bullet$};
%         \draw[-latex] (start) -- (A);
%         \draw[-latex] (A) -- (B);
%         \draw[-latex] (A) -- (C);
%         \draw[-latex] (B) -- (D);
%         \draw[-latex] (B) -- (E);
%         \draw[-latex] (D) -- (F);
%         \draw[-latex] (E) -- (F);
%         \draw[-latex] (C) -- (F);
%       \end{tikzpicture}
%     \caption{\centering branch end\newline replacement}
%     \label{branch-end-replacement-figure}
%   \end{center}
%   \end{subfigure}
%   \caption{Examples of the different cases of node replacement}
%   \label{node-replacement-example-figures}
% \end{figure}

% With node replacement defined, we can now define what we mean by a
% structure control flow graph in terms of node replacement and the structured graphs shown in Figure~\ref{structured-cfg-figures}

% \begin{defn}[Structured Control Flow Graph]
%   If $G$ is a rooted directed graph, we say $G$ is a \emph{structured
%     control flow graph} if $G$ is the trivial graph (the graph with a
%   single node, which is also the root, and no edges) or if $G$ can be
%   created by starting with the trivial graph and performing a finite
%   number of node replacements to replace nodes with graphs of the
%   forms shown in Figure~\ref{structured-cfg-figures}.
% \end{defn}

% % In particular, we target the requirements imposed by
% % MISRA-C~\cite{misra2012}.
% % This means that we do not allow \texttt{goto}s in the final C code and
% % that loops must have a simple structure, with no use of
% % \texttt{continue} and a single exit point.
% % A single return per method is also a requirement of MISRA-C, but in a
% % control flow graph there is no way to distinguish between a
% % conditional return in the middle of a method and a conditional at the
% % end of a method of which both branches are returns.
% % Thus we treat all occurrences of returns in the middle of functions in
% % the second way, which can then be treated as a single return at the
% % end of the function in the translation to C code by extracting the
% % returns from each branch.

% \begin{figure}
%   \begin{subfigure}{0.26\textwidth}
%     \begin{center}
%       \begin{tikzpicture}
%         \useasboundingbox (-0.5,-1) rectangle (0.5,2);
%         \node at (0,1.7) (start) {};
%         \node at (0,1)  (A) {$\bullet$};
%         \node at (0,-1) (B) {$\bullet$};
%         \draw[-latex] (start) -- (A);
%         \draw[-latex] (A) -- (B);
%       \end{tikzpicture}
%     \end{center}
%     \caption{sequential composition}
%     \label{sequence-figure}
%   \end{subfigure}
%   \begin{subfigure}{0.23\textwidth}
%     \begin{center}
%       \begin{tikzpicture}
%         \useasboundingbox (-1,-1) rectangle (0,2);
%         \node at (0,1.7) (start) {};
%         \node at (0,1)  (A) {$\bullet$};
%         \node at (-1,0) (B) {$\bullet$};
%         \node at (0,-1) (C) {$\bullet$};
%         \draw[-latex] (start) -- (A);
%         \draw[-latex] (A) -- (B);
%         \draw[-latex] (A) -- (C);
%         \draw[-latex] (B) -- (C);
%       \end{tikzpicture}
%     \end{center}
%     \caption{\texttt{if} conditional}
%     \label{if-figure}
%   \end{subfigure}
%   \begin{subfigure}{0.23\textwidth}
%     \begin{center}
%       \begin{tikzpicture}
%         \useasboundingbox (-1,-1) rectangle (1,2);
%         \node at (0,1.7) (start) {};
%         \node at (0,1)  (A) {$\bullet$};
%         \node at (1,0)  (B) {$\bullet$};
%         \node at (-1,0) (C) {$\bullet$};
%         \node at (0,-1) (D) {$\bullet$};
%         \draw[-latex] (start) -- (A);
%         \draw[-latex] (A) -- (B);
%         \draw[-latex] (A) -- (C);
%         \draw[-latex] (B) -- (D);
%         \draw[-latex] (C) -- (D);
%       \end{tikzpicture}
%     \end{center}
%     \caption{\texttt{if}-\texttt{else} conditional}
%     \label{if-else-figure}
%   \end{subfigure}
%   \begin{subfigure}{0.23\textwidth}
%     \begin{center}
%       \begin{tikzpicture}
%         \useasboundingbox (-1,0) rectangle (1,3);
%         \node at (0,1.7) (start) {};
%         \node at (0,1)  (A) {$\bullet$};
%         \node at (1,0)  (B) {$\bullet$};
%         \node at (-1,0) (C) {$\bullet$};
%         \draw[-latex] (start) -- (A);
%         \draw[-latex] (A) -- (B);
%         \draw[-latex] (A) -- (C);
%       \end{tikzpicture}
%     \end{center}
%     \caption{divergent conditional}
%     \label{divergent-figure}
%   \end{subfigure} 
%   \\
%   \begin{subfigure}{0.33\textwidth}
%     \begin{center}
%       \begin{tikzpicture}
%         \useasboundingbox (-1,-1) rectangle (1,2);
%         \node at (0,1.7) (start) {};
%         \node at (0,1) (A) {$\bullet$};
%         \node at (0,-1) (B) {$\bullet$};
%         \node at (1,-1) (C) {$\bullet$};
%         \draw[-latex] (start) -- (A);
%         \draw[-latex] (A) to (B);
%         \draw[-latex] (A) to (C);
%         \draw[-latex] (B) to[in=200,out=150] (A);
%       \end{tikzpicture}
%     \end{center}
%     \caption{\texttt{while} loop}
%     \label{while-figure}
%   \end{subfigure}
%   \begin{subfigure}{0.33\textwidth}
%     \begin{center}
%       \begin{tikzpicture}
%         \useasboundingbox (-1,0) rectangle (1,3);
%         \node at (0,1.7) (start) {};
%         \node at (0,1)  (A) {$\bullet$};
%         \node at (1,0)  (B) {$\bullet$};
%         \draw[-latex] (start) -- (A);
%         \draw[-latex] (A) to (B);
%         \draw[-latex] (A) to[out=235,in=180,looseness=10] (A);
%       \end{tikzpicture}
%     \end{center}
%     \caption{\texttt{do}-\texttt{while} loop}
%     \label{do-while-figure}
%   \end{subfigure}
%   \begin{subfigure}{0.33\textwidth}
%     \begin{center}
%       \begin{tikzpicture}
%         \useasboundingbox (-1,0) rectangle (1,3);
%         \node at (0,1.7) (start) {};
%         \node at (0,1)  (A) {$\bullet$};
%         \draw[-latex] (start) -- (A);
%         \draw[-latex] (A) to[out=270,in=180,looseness=10] (A);
%       \end{tikzpicture}
%     \end{center}
%     \caption{infinite loop}
%     \label{infinite-loop-figure}
%   \end{subfigure}
%   \caption{Control flow graphs of program structures}
%   \label{structured-cfg-figures}
% \end{figure}

% The first structure (Figure~\ref{sequence-figure}) is that of simple
% sequential composition, with an edge going from the root node to a
% single end node.
% The next three structures
% (Figure~\ref{if-figure}--\subref{divergent-figure}) are conditional
% structures:~Figure~\ref{if-figure} shows an \texttt{if} statement with
% no \texttt{else} clause, Figure~\ref{if-else-figure} shows an
% \texttt{if} statement with an \texttt{else} clause, and
% Figure~\ref{divergent-figure} shows a conditional in which both
% branches end with a (infinite) loop or a return so that there is
% nothing following the conditional, we refer to such conditionals as
% divergent conditionals since the branches do not come back together.
% The remaining three structures
% (Figure~\ref{while-figure}--\subref{infinite-loop-figure}) are all
% loop structures:~Figure~\ref{while-figure} shows a loop in which the
% loop condition is checked at the beginning (a \texttt{while} loop),
% Figure~\ref{do-while-figure} show a loop in which the loop condition
% is checked at the end (a \texttt{do}-\texttt{while} loop), and
% Figure~\ref{infinite-loop-figure} shows a loop which loops
% unconditionally, forming an infinite loop.

% From this definition it is clear that the control flow graph of our
% example, shown in
% Figure~\ref{example-simplified-control-flow-graph-figure}, is a
% structured control flow graph.
% It may be obtained from the trivial graph by replacing the node with a
% sequential composition, replacing the end node of the sequential
% composition with a \texttt{while} loop, and then replacing the node
% inside the \texttt{while} loop with an \texttt{if}-\texttt{else}
% conditional.

In the strategy we check that the control flow graph is structured
when we construct it in this section, and abort the strategy if it
does not have the required structure.
The introduction of sequential composition does not cause the control
flow graph of a structured program to cease being structured, so we
may also check that the control flow graph is structured when we
construct it in
Section~\ref{introduce-forward-sequence-subsection}.
%TODO: mention the Dijkstra Graphs paper

%TODO: explain how our definition of structure differs from that of
% MISRA - leave for final considerations?

Since we have defined the desired program structure in terms of a
small number of standard structures, we can identify each of these
structures in the control flow graph and introduce them into the
program, collapsing the control flow graph in the process.
In order to easily identify the structures in isolation from other
structures, we begin at the end nodes of the method (ignoring looping
edges for the purposes of determining end nodes) and work backwards,
considering each node in turn.
This is specified by the loop beginning on
line~\ref{algorithm-node-checking-loop} of
Algorithm~\ref{introduce-loops-and-conditionals-algorithm}.
In our example this means we consider the $pc=42$ and $pc=35$ nodes
first, then $pc=28$ and $pc=32$, then $pc=21$, $pc=39$, and finally
$pc=7$.

For each node, we check each type of structure to see if the control
flow graph starting at that point matches the structure, and introduce
the structure if it does.
The first type of structure we check for are conditionals, beginning
with those conditionals that are followed by another node, that is,
those shown in Figure~\ref{if-figure} and~\subref{if-else-figure}.
These may be nested within one of the branches of another conditional
in one of the two ways shown below:
\begin{center}
  \begin{tikzpicture}
    \node (1) at (0, 0.0) {$\bullet$};
    \node (2) at (2, 0.5) {$\bullet$};
    \node (3) at (2,-0.5) {$\bullet$};
    \node (4) at (4, 1.0) {$\bullet$};
    \node (5) at (4,-1.0) {$\bullet$};
    \node (6) at (4, 0.2) {$\bullet$};
    \node (7) at (4,-0.2) {$\bullet$};
    \node (8) at (6, 0.0) {$\bullet$};
    
    \draw[-latex] (-1,0) to (1);
    
    \draw[-latex] (1) to (2);
    \draw[-latex] (1) to (3);
    \draw[-latex] (2) to (4);
    \draw[-latex] (3) to (5);
    \draw[-latex] (2) to (6);
    \draw[-latex] (3) to (7);
    \draw[-latex] (4) to (8);
    \draw[-latex] (5) to (8);
    \draw[-latex] (6) to (8);
    \draw[-latex] (7) to (8);
  \end{tikzpicture}
  \hfill
  \begin{tikzpicture}
    \node (1) at (0.0, 0.0) {$\bullet$};
    \node (2) at (1.5, 0.5) {$\bullet$};
    \node (3) at (1.5,-0.5) {$\bullet$};
    \node (4) at (3.0, 1.0) {$\bullet$};
    \node (5) at (3.0,-1.0) {$\bullet$};
    \node (6) at (3.0, 0.2) {$\bullet$};
    \node (7) at (3.0,-0.2) {$\bullet$};
    \node (8) at (4.0, 0.5) {$\bullet$};
    \node (9) at (4.0,-0.5) {$\bullet$};
    \node (0) at (5.0, 0.0) {$\bullet$};
    
    \draw[-latex] (-1,0) to (1);
    
    \draw[-latex] (1) to (2);
    \draw[-latex] (1) to (3);
    \draw[-latex] (2) to (4);
    \draw[-latex] (3) to (5);
    \draw[-latex] (2) to (6);
    \draw[-latex] (3) to (7);
    \draw[-latex] (4) to (8);
    \draw[-latex] (5) to (9);
    \draw[-latex] (6) to (8);
    \draw[-latex] (7) to (9);
    \draw[-latex] (8) to (0);
    \draw[-latex] (9) to (0);
  \end{tikzpicture}
\end{center}
In the first case the sequential composition with the node at the end
cannot be introduced until the outermost conditional is introduced,
because both of the inner conditionals end at the same point.
However, in the second case the inner conditionals can be completely
introduced, including the sequential composition with the node after
the end of each inner conditional, before the outer conditional is
introduced.
To ensure both cases are covered, we separate the introduction of the
conditional itself and the sequential composition with the node after
the conditional. 
In the first case the introduction of the sequential composition is
deferred until after the outermost conditional is resolved, whereas in
the second case it may be performed immediately after the introduction
of the conditional.

We provide separate compilation rules for introducing \texttt{if}
conditionals and \texttt{if}-\texttt{else} conditionals.
An \texttt{if} conditional with no else branch may be recognised from
the control flow graph as having the form shown in
Figure~\ref{if-figure}.
However, it can also be recognised from the form of the \Circus{} code
in the $Running$ action, which will be that of a node whose sequence
of instructions ends with an assignment of the form
$pc := \IF b \THEN x \ELSE y$, and for which the $pc = y$ node ends in
an assignment $pc := x$.
Note that the branches will not be the other way round (i.e. 
the $pc = x$ branch will not be the body of the conditional) since the
conditional branches come from Java's branching instructions which
branch to the specified address if the condition is true and go to the
next instruction if it is false.
We provide Rule [\nameref{if-introduction-rule}] for introducing such
conditionals.
\begin{restatable}[\texttt{if}-conditional-introduction]{crule}{IfConditionalIntroductionRule}
  \label{if-introduction-rule}
  \setlength{\zedindent}{0.25cm}
  % \setlength{\abovedisplayskip}{0.1cm}
  % \setlength{\belowdisplayskip}{0.1cm}
  If $i \neq j$, $i \neq k$, and 
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 pc := \IF b \THEN j \ELSE k \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 \circif b \circthen \Skip \\
      \t3 {} \circelse \lnot b \circthen pc := k \circseq Poll \circseq B \\
      \t3 \circfi \circseq pc := j \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen B \circseq pc := j \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}
Rule [\nameref{if-introduction-rule}] introduces a conditional for
nodes that match the form described above, which in the rule is the
$pc = i$ node.
The conditional is introduced with the true branch being empty
(represented here by $\Skip$) and the false branch containing the
instructions in the body of the conditional.
The assignment $pc := j$ is moved outside the conditional from both
the empty true branch and the end of the false branch, so that a
sequential composition with the node after the conditional can be
introduced later on.
As in Rule [\nameref{sequence-introduction-rule}], the sequence of
actions for the node must not affect the nonemptiness of the
$frameStack$.
A similar condition is required for all the rules in this section.
We also require that the targets of the conditional are different from
the node at which the conditional is introduced, since that would
introduce a loop, which is not the purpose of this rule.
Rule [\nameref{if-introduction-rule}] is applied on
line~\ref{algorithm-introduce-if} of
Algorithm~\ref{introduce-loops-and-conditionals-algorithm}.
Note that, since the structure can be identified from the form of the
\Circus{} code alone, it is node necessary to guard the application of
the rule with a condition on the control flow graph.

After attempting to introduce an \texttt{if} conditional, we attempt
to introduce an \texttt{if}-\texttt{else} conditional, the form of
which is shown in Figure~\ref{if-else-figure}.
As with an \texttt{if} conditional, a node with an
\texttt{if}-\texttt{else} conditional will end with an assignment of
the form $pc := \IF b \THEN x \ELSE y$, but the $pc = x$ and $pc = y$
nodes are required to end with a common assignment $pc := z$.
Conditionals matching this form may be introduced using
Rule [\nameref{if-else-introduction-rule}].
\begin{restatable}[\texttt{if}-\texttt{else} conditional introduction]{crule}{IfElseConditionalIntroductionRule}
  \label{if-else-introduction-rule}
  \setlength{\zedindent}{0.25cm}
  % \setlength{\abovedisplayskip}{0.1cm}
  % \setlength{\belowdisplayskip}{0.1cm}
  If $i \neq j$, $i \neq k$, and 
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 pc := \IF b \THEN j \ELSE k \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = j \circthen B \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen C \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 \circif b \circthen pc := j \circseq Poll \circseq B \\
      \t3 {} \circelse \lnot b \circthen pc := k \circseq Poll \circseq C \\
      \t3 \circfi \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = j \circthen B \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen C \circseq pc := x \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}
Rule [\nameref{if-else-introduction-rule}] operates similarly to
Rule [\nameref{if-introduction-rule}] in how it introduces the conditional
and moves the common $pc$ assignment outside the conditional.
However, Rule [\nameref{if-else-introduction-rule}] includes sequences of
instructions for both branches of the introduced conditional, each of
which end with a $pc$ assignment to jump to the node after the
conditional.
The preconditions of Rule [\nameref{if-else-introduction-rule}] are the
same as those of Rule [\nameref{if-introduction-rule}].
Rule [\nameref{if-else-introduction-rule}] is applied on
line~\ref{algorithm-introduce-if-else} of
Algorithm~\ref{introduce-loops-and-conditionals-algorithm}.

Having attempted to introduce conditionals with a node following them,
we then consider conditionals that are not followed by a node.
These conditionals are those where both branches end in a return or an
infinite loop.
This includes conditionals where both branches are a return, which can
arise from multiple returns in the Java source code. 
Though multiple returns are not allowed in the final C code, the
returns will all end up in branches of conditionals at the end of the
method, so the actual return statement can be placed after the
conditionals to create a single return statement at the end of the C
function.

The form of this type of conditionals is that shown in
Figure~\ref{divergent-figure}.
We require that the nodes in both branches of the conditional have
only a single incoming edge each, and do not have any outgoing edges
(at the point in the strategy where this type of conditional is
introduced, that is, there may be more complex structures that have
already been introduced in the branches).
We check that the control flow graph beginning at the node being
considered has this form on line~\ref{algorithm-conditional-check} of
the algorithm.
This is to ensure unstructured conditionals such as the one shown
below are ruled out by the strategy.
\begin{center}
  \begin{tikzpicture}
    \node (0) at (-2, 0.0) {$\cdots$};
    \node (1) at (0, 0.0) {$\bullet$};
    \node (2) at (2, 0.5) {$\bullet$};
    \node (3) at (2,-0.5) {$\bullet$};
    \node (4) at (4, 1.0) {$\bullet$};
    \node (5) at (4,-1.0) {$\bullet$};
    \node (6) at (4, 0.0) {$\bullet$};

    \draw[-latex] (0) to (1);
    \draw[-latex] (1) to (2);
    \draw[-latex] (1) to (3);
    \draw[-latex] (2) to (4);
    \draw[-latex] (3) to (5);
    \draw[-latex] (2) to (6);
    \draw[-latex] (3) to (6);
  \end{tikzpicture}
\end{center}

If the correct structure is present, then we introduce the conditional
by applying Rule [\nameref{conditional-introduction-rule}] on
line~\ref{algorithm-introduce-conditional}.
This rule introduces the conditional in much the same way as
Rule [\nameref{if-introduction-rule}] and
Rule [\nameref{if-else-introduction-rule}], but it does not place any
requirement on the structure of the conditional or move a $pc$
assignment outside of it.
\begin{restatable}[Conditional introduction]{crule}{ConditionalIntroductionRule}
  \label{conditional-introduction-rule}
  \setlength{\zedindent}{0.25cm}
  % \setlength{\abovedisplayskip}{0.1cm}
  % \setlength{\belowdisplayskip}{0.1cm}
  If $i \neq j$, $i \neq k$, and 
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 pc := \IF b \THEN j \ELSE k \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = j \circthen B \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen C \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 pc := \IF b \THEN j \ELSE k \circseq Poll \circseq \\
      \t3 \circif b \circthen B \\
      \t3 {} \circelse \lnot b \circthen C \\
      \t3 \circfi \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = j \circthen B \\
      \t2 {} \cdots {} \\
      \t2 {} \circelse pc = k \circthen C \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}

After attempting to introduce conditionals, we may attempt to
introduce loops.
There are three types of loop to consider, as shown earlier:
\texttt{while} loops (Figure~\ref{while-figure}),
\texttt{do}-\texttt{while} loops (Figure~\ref{do-while-figure}), and
infinite loops (Figure~\ref{infinite-loop-figure}).
A \texttt{while} loop has a form similar to that of a conditional,
except that one of the branches ends with a jump back to the beginning
of the node with the conditional.
This structure may be introduced using
Rule [\nameref{while-introduction-rule1}].
This rule introduces a conditional at a node $pc=i$ with its false
branch ending in an assignment of $i$ to $pc$, and introduces a
recursion to the beginning of the $pc=i$ node in that branch of the
conditional, representing a loop.
Since this loop may be within a conditional, we simply move the $pc$
assignment for the true branch outside the conditional.
A sequential composition can then be introduced later, as with
\texttt{if} and \texttt{if}-\texttt{else} conditionals.
\begin{restatable}[\texttt{while} loop introduction 1]{crule}{WhileLoopIntroductionRuleA}
  \label{while-introduction-rule1}
  \def\zedindent{0.25cm}
  If $i \neq j$,
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 pc := \IF b \THEN j \ELSE k \\
      \t2 \cdots \\
      \t2 {} \circelse pc = j \circthen B \\
      \t2 \cdots \\
      \t2 {} \circelse pc = k \circthen C \circseq pc := i \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen \circmu Y \circspot A \circseq \\
      \t3 pc := \IF b \THEN j \ELSE k \circseq Poll \circseq \\
      \t3 \circif b \circthen \Skip \\
      \t3 {} \circelse \lnot b \circthen C \circseq pc := i \circseq Poll \circseq Y \\
      \t3 \circfi \circseq pc := j \\
      \t2 \cdots \\
      \t2 {} \circelse pc = j \circthen B \\
      \t2 \cdots \\
      \t2 {} \circelse pc = k \circthen C \circseq pc := i \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}%
As a \texttt{while} loop may occur with the loop at the end of either
condition branch (since the loop may be created by a \texttt{goto}
instruction in the Java bytecode), we also provide a similar rule,
Rule [\nameref{while-introduction-rule2}], that introduces the loop in the
true branch of the conditional.
These two rules are applied on lines~\ref{algorithm-introduce-while1}
and~\ref{algorithm-introduce-while2} of the algorithm.

The next type of loop we consider is the \texttt{do}-\texttt{while}
loop, which has the form shown in Figure~\ref{do-while-figure}.
These loops are distinguished from \texttt{while} loops by the fact
that the conditional $pc$ assignment which causes the loop is at the
end of the loop, rather than at the beginning or in the middle.
We introduce these loops using Rule
[\nameref{do-while-introduction-rule}].
\begin{restatable}[\texttt{do}-\texttt{while} loop introduction]{crule}{DoWhileLoopIntroductionRule}
  \label{do-while-introduction-rule}
  \def\zedindent{0.25cm}
  If $i \neq j$,
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 pc := \IF b \THEN i \ELSE j \\
      \t2 \cdots \\
      \t2 {} \circelse pc = j \circthen B \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen \circmu Y \circspot A \\
      \t3 pc := \IF b \THEN i \ELSE j \circseq Poll \circseq \\
      \t3 \circif b \circthen Y \\
      \t3 {} \circelse \lnot b \circthen \Skip \\
      \t3 \circfi \circseq pc := j \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
\end{restatable}%
This rule introduces a conditional, as with Rule
[\nameref{while-introduction-rule1}], but the true branch contains
just the recursive call, since the conditional occurs at the end of
the loop.
The $pc$ assignment for the false branch is moved outside the
conditional to allow a sequential composition to be introduced later,
as in previous rules.
Note that the false branch can never cause the loop in this case,
since it will just go to the next instruction.
Attempting to redirect it and create the loop with a \texttt{goto}
instruction would add an instruction within the loop after the
conditional, so it would be dealt with as a \texttt{while} loop.
Therefore, it is not necessary to provide two compilation rules for
\texttt{do}-\texttt{while} loops, unlike \texttt{while} loops where
both cases must be accounted for.
Rule [\nameref{do-while-introduction-rule}] is applied on
line~\ref{algorithm-introduce-do-while} of the algorithm.

The final loop structure that we attempt to introduce is that of an
infinite loop.
Infinite loops are rare in most programs, but an infinite loop is
nonetheless a well-structured program construct that has use in a few
cases so we handle it here.
An infinite loop may be identified as a block of instructions that
ends with a $pc$ assignment that causes a jump back to the beginning
of the block of instructions.
Such a block will have a control flow graph of the form shown in
Figure~\ref{infinite-loop-figure}.
We introduce these loops using Rule
[\nameref{infinite-loop-introduction-rule}], which introduces a
recursive call after the $pc$ assignment that causes the loop.
This rule is applied on line~\ref{algorithm-introduce-infinite-loop}
of the algorithm.
\begin{restatable}[Infinite loop introduction]{crule}{InfiniteLoopIntroductionRule}
  \label{infinite-loop-introduction-rule}
  If
  \begin{circus}
    \{frameStack \neq \emptyset\} \circseq A \\
    {} = {} \\
    \{frameStack \neq \emptyset\} \circseq A \circseq \{frameStack \neq \emptyset\}
  \end{circus}
  then
  \def\zedindent{0.25cm}
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen {} \\
      \t3 A \circseq pc := i \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen {} \\
      \t3 \circmu Y \circspot A \circseq pc := i \circseq Poll \circseq Y \\
      \t2 {} \cdots {} \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
  \end{circus}
\end{restatable}%

After we have attempted to introduce each of the structures for a
particular node, we attempt to introduce a sequential composition.
This ensures that \texttt{if}, \texttt{if}-\texttt{else},
\texttt{while} and \texttt{do}-\texttt{while} structures that occur
within conditionals are sequentially composed with the node following
them if possible.
It also handles cases where sequential compositions occur before
loops, preventing them from being introduced in
Section~\ref{introduce-forward-sequence-subsection} without
interfering with the introduction of the loop.
Such a case occurs at the $pc=7$ node in our example.
The requirement for sequential composition to be introduced is the
same as in Section~\ref{introduce-forward-sequence-subsection}:~it
must be a simple sequential composition from a node with a single
outgoing edge to a node with a single incoming edge.
Thus we check for a simple sequence on
line~\ref{algorithm-lci-sequence-check} of
Algorithm~\ref{introduce-loops-and-conditionals-algorithm}.
The sequential composition is then introduced on
line~\ref{algorithm-lci-sequence-introduction} if it is a simple
sequential composition.

As mentioned earlier, these steps are repeated for each node, working
backwards through the control flow graph of each method.
Given a structured control flow graph at the beginning, this means all
the structures in the method are introduced, reducing the control flow
graph to a single node.

In our example, we begin at the $pc=35$ node, where there are no
structures to introduce. 
The same holds true of the $pc=28$ and $pc=32$ nodes (note that the
edges coming from them are not simple sequential compositions).
An \texttt{if}-\texttt{else} conditional is introduced at $pc=21$,
absorbing the $pc=28$ and $pc=32$ nodes.
The sequential composition from the $pc=21$ node to the $pc=35$ node
can then be introduced immediately as it is now a simple sequential
composition (because it is not at the end of an outer conditional).
We then introduce a \texttt{while} loop at the $pc=39$ loop (using
Rule [\nameref{while-introduction-rule2}]), and the sequential composition
with the $pc=42$ node is introduced afterwards.
Finally, a sequential composition from the $pc=7$ to the $pc=39$ node
is introduced, collapsing the control flow graph to a single node.
The code at $pc=7$ is then that shown earlier in
Figure~\ref{loop-and-conditional-introduction-example-figure}.

\subsection{Resolve Method Calls}
\label{resolve-method-calls-subsection}

When a method is complete, calls to that method can then be resolved.
This is performed after introduction of loops and conditionals,
ensuring methods with loops and conditionals are complete so that this
step can be applied.
% As mentioned previously, since this requires all the method calls in a
% given method to be resolved first, we do not allow recursion.

This step begins with the copying of the method into a separate
action, so that it can be referenced elsewhere.
This is performed by as described by
Algorithm~\ref{separate-complete-methods-algorithm}.
\begin{algorithm}
  \begin{algorithmic}[1]
    \Procedure{SeparateCompleteMethods}{}
    \For{$m \gets methods$} \label{algorithm-method-separation-loop}
    % \For{$mc \gets$ \Call{MethodsCalls}{$m$}}
    % \EndFor
    \If{\Call{MethodIsComplete}{$m$}} \label{algorithm-check-method-completeness}
    \State \Call{ApplyCopyRule}{$m$}
    \EndIf
    \EndFor
    \EndProcedure
  \end{algorithmic}
  \caption{Separate Complete Methods}
  \label{separate-complete-methods-algorithm}
\end{algorithm}

Algorithm~\ref{separate-complete-methods-algorithm} looks at each
method separately, as specified by the loop on
line~\ref{algorithm-method-separation-loop}, and determines if it is
complete, on line~\ref{algorithm-check-method-completeness}.
This involves a simple syntactic check that each conditional branch
ends in a return instruction or a recursion.
Those methods that are complete are moved into a separate action by an
application of the copy rule.

In our example, the method \texttt{f()} of the \texttt{TPK} class,
which starts at $pc = 43$, is complete on the first iteration of the
loop on line~\ref{algorithm-method-loop} of
Algorithm~\ref{epc-algorithm}, with the $Running$ action as shown
below.
The method is complete in this case because it consists of a straight
sequence of instructions ending with $HandleAreturnEPC$, which
represents the \texttt{areturn} instruction.
\begin{circus}
  Running \circdef \\
  \t1 \circif frameStack = \emptyset \circthen \Skip \\
  \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
  \t2 \circif pc = 0 \circthen {} \cdots {} \\
  \t2 {} \cdots {} \\
  \t2 {} \circelse pc = 43 \circthen HandleAloadEPC(0) \circseq Poll \circseq HandleAloadEPC(0) \circseq \\
  \t3 Poll \circseq HandleIaddEPC \circseq Poll \circseq HandleAloadEPC(0) \circseq Poll \circseq \\
  \t3 HandleIaddEPC \circseq Poll \circseq HandleIconstEPC(5) \circseq Poll \circseq \\
  \t3 HandleIaddEPC \circseq Poll \circseq HandleAreturnEPC \\
  \t2 {} \cdots {} \\
  \t2 \circfi \circseq Poll \circseq Running \\
  \t1 \circfi
\end{circus}
The sequence of instructions at $pc = 43$ can then be copied into a
separate action, shown below.
The name of this action contains the name of the class and method
identifier of the method it represents.
\begin{circus}
  TPK\_f \circdef HandleAloadEPC(0) \circseq Poll \circseq HandleAloadEPC(0) \circseq Poll \circseq \\
  \t1 HandleIaddEPC \circseq Poll \circseq HandleAloadEPC(0) \circseq Poll \circseq HandleIaddEPC \circseq \\
  \t1 Poll \circseq HandleIconstEPC(5) \circseq Poll \circseq  HandleIaddEPC \circseq Poll \circseq \\
  \t1 HandleAreturnEPC 
\end{circus}

After all the complete methods have been copied into separate actions,
calls to those methods are resolved.
This is performed as described by
Algorithm~\ref{resolve-method-calls-algorithm}.
\begin{algorithm}
  \begin{algorithmic}[1]
    \Procedure{ResolveMethodCalls}{}
    \For{$m \gets methods$}
    \For{$mc \gets$ \Call{UnresolvedMethodsCalls}{$m$}}
    \State $targets \gets$ \Call{DetermineMethodCallTargets}{$mc$}
    \If{$\# targets = 1$}
    \State \Call{ApplyRule[\nameref{method-call-resolution-rule}]}{}
    \Else
    \State \Call{ApplyRule[\nameref{dynamic-method-call-resolution-rule}]}{}
    \EndIf
    \EndFor
    \EndFor
    \EndProcedure
  \end{algorithmic}
  \caption{Resolve Method Calls}
  \label{resolve-method-calls-algorithm}
\end{algorithm}


%%%%

To resolve a method call, the type of method call must be considered.
Some methods are handled directly by the SCJVM as they relate to the
SCJVM services.
Such methods are treated specially by the interpreter, communicating
with the launcher to perform the behaviour of the method.
In cases where the method invocation is simply handled by
communication with the launcher and then followed by execution of the
next instruction, the control flow can be introduced using
Rule [\nameref{sequence-introduction-rule}] as for other instructions with
simple control flow.

% TODO: discuss special methods with nested calls here

For method calls that do not require special handling, the control
flow is that of the corresponding method's action, followed by
execution of the next instruction.
If the method is called with static dispatch (as is the case with the
\texttt{invokespecial} and \texttt{invokestatic} instructions), the
correct method, and hence the corresponding action can be easily
determined.
The method call is then resolved using
Rule [\nameref{method-call-resolution-rule}].
We require as a precondition of the rule that the method action
returns to the return address stored on the stack, to ensure that the
control flow is resolved correctly.
This will be the case for a method where every path of execution ends
in a return or loop, since returns establish the condition and loops
will either lead to a return eventually or form an infinite loop that
may be followed by any action (including the assumption we require).
%
\begin{restatable}[Method call resolution]{crule}{MethodCallResolutionRule}
  \label{method-call-resolution-rule}
  If an action $M$ is such that
  \[\{ (head~frameStack).storedPC = i \land frameStack = fs \} \circseq M \\
    {} = {} \\
    \{ (head~frameStack).storedPC = i \land frameStack = fs \}
    \circseq M \circseq \\
    \t1 \{ pc = i \land frameStack = tail~fs \}\]
  and $i \neq j$,
  \setlength{\zedindent}{0.25cm}
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 \{ pc = k \} \circseq \\
      \t3 \lschexpract \exists retAddr? == pc+1 @ \\
      \t4 SetReturnAddr \rschexpract \circseq \\
      \t3 pc := j \\
      \t2 {} \circelse pc = k+1 \circthen B \\
      \t2 {} \circelse pc = j \circthen M \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A \circseq \\
      \t3 \{ pc = k \} \circseq \\
      \t3 \lschexpract \exists retAddr? == pc+1 @ \\
      \t4 SetReturnAddr \rschexpract \circseq \\
      \t3 pc := j \circseq Poll \circseq M \circseq Poll \circseq B \\
      \t2 {} \circelse pc = k+1 \circthen B \\
      \t2 {} \circelse pc = j \circthen M \\
      \t2 \cdots \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
  \end{circus}
  %TODO: elimination of pc assignment
\end{restatable}
%
For method calls that have dynamic dispatch (as in the case of
\texttt{invokevirtual} instructions), we must determine what classes
the method may be called on.
The control flow is then a choice over the class of the object the
method is called on, with the method action corresponding to that
class chosen.
As with the static case, we require the method action to return to the
return address stored on the stack.
In the dynamic case, this requirement must be met by all the method
actions so that the next instruction can be executed after the choice
of methods.
Rule [\nameref{dynamic-method-call-resolution-rule}] is used to
introduce this choice.
%
\begin{restatable}[Dynamic method call resolution]{crule}{DynamicMethodCallResolutionRule}
  \label{dynamic-method-call-resolution-rule}
  If actions $M_1, \dots, M_n$ are such that
  \[\{ returnAddress = i \land frameStack = fs \} \circseq M_k \\
    {} = {} \\
    \{ returnAddress = i \land frameStack = fs \}
    \circseq M_k \circseq \{ pc = i \land frameStack = tail~fs \}\]
   for $k in \{ 1, \dots, n \}$ and $i \neq j$,
  \setlength{\zedindent}{0.25cm}
  \begin{circus}
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A(class, method) \circseq \\
      \t3 \{ class \in \{ c_1, \dots, c_n \}\} \circseq \\
      \t3 \lschexpract \exists retAddr? == pc+1 @ \\
      \t4 SetReturnAddr \rschexpract \circseq \\
      \t3 pc := entry(class, method) \\
      \t2 {} \circelse pc = k+1 \circthen B \\
      \t2 {} \circelse pc = j_1 \circthen M_1 \\
      \t2 \cdots \\
      \t2 {} \circelse pc = j_n \circthen M_n \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi 
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse frameStack \neq \emptyset \circthen {} \\
      \t2 \circif \cdots \\
      \t2 {} \circelse pc = i \circthen A(class, method) \circseq \\
      \t3 \{ class \in \{ c_1, \dots, c_n \} \circseq \\
      \t3 \lschexpract \exists retAddr? == pc+1 @ \\
      \t4 SetReturnAddr \rschexpract \circseq \\
      \t3 pc := entry(class, method) \circseq Poll \circseq \\
      \t3 \circif class = c_1 \circthen M_1 \\
      \t3 \cdots \\
      \t3 {} \circelse class = c_n \circthen M_n \\
      \t3 \circfi \circseq Poll \circseq B \\
      \t2 {} \circelse pc = k+1 \circthen B \\
      \t2 {} \circelse pc = j_1 \circthen M_1 \\
      \t2 \cdots \\
      \t2 {} \circelse pc = j_n \circthen M_n \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
  \end{circus}
  %TODO: elimination of pc assignment
\end{restatable}

The resolution of loops, conditionals and methods is performed in a
loop until all the methods have been separated into their own action.
The remaining use of the program counter in the main actions of $Thr$
can then be eliminated as described in the next section.

\subsection{Refine Main Actions}
\label{refine-main-actions-subsection}

At this stage of the strategy, the only place that the program counter
is used is when the first method is started, when it is used to select
the method action to execute, which will then proceed without any need
for the program counter value.
This can be eliminated by replacing it with a choice over the method
rather than the program counter.
This must be performed in the two places that the $Running$ action
occurs:~the $MainThread$ and $NotStarted$ actions.
Since the main action of $Thr$ is a guarded choice of these actions
depending on whether its thread parameter is the $main$ thread, these
actions may be thought of as two alternative main actions for $Thr$.

The context of the $Running$ action in both of these main actions is
the same:~the frame stack has only one frame and the program counter
is set to the entry point of a method.
This means that the same rule can be used for both main actions by
introducing an assumption that states that context.
Additionally, we can use the fact that each method action will, when
started with a frame stack containing a single frame, cause the frame
stack to become empty.
This allows us to eliminate the loop in $Running$, reducing it
entirely to a choice of method action from the class and method
identifier.
The overall transformation of $Running$ in its context is described by
Rule [\nameref{main-action-refinement-rule}].
\begin{restatable}[Main Action Refinement]{crule}{MainActionRefinementRule}
  \label{main-action-refinement-rule}
  If $entry(c_i,m_i) = j_i$ for $i \in \{1, \dots, n\}$ and
  \begin{circus}
    \{ \# frameStack = 1 \} \circseq M_i \\
    {} = {} \\
    \{ \# frameStack = 1 \} \circseq M_i \circseq \{ frameStack = \emptyset \}
  \end{circus}
  \setlength{\zedindent}{0.25cm}
  \begin{circus}
    \begin{array}{l}
      \{ \# frameStack = 1 \\
      \t1 {} \land pc = entry(cid, mid) \} \circseq \\
      \circmu X \circspot \\
      \t1 \circif frameStack = \emptyset \circthen \Skip \\
      \t1 {} \circelse framestack \neq \emptyset \circthen {}  \\
      \t2 \circif pc = j_1 \circthen M_1 \\
      \t2 \cdots \\
      \t2 {} \circelse pc = j_n \circthen M_n \\
      \t2 \circfi \circseq Poll \circseq X \\
      \t1 \circfi
    \end{array}
    \circrefines_A
    \begin{array}{l}
      \{ \# frameStack = 1 \} \circseq \\
      \circif (cid, mid) = (c_1, m_1) \circthen M_1 \\
      \cdots \\
      {} \circelse (cid, mid) = (c_n, m_n) \circthen M_n \\
      \circfi \\
    \end{array}
  \end{circus}
\end{restatable}
Once this has been performed, the program counter value is no longer
used to determine the control flow of the program, so a trivial data
refinement can be performed to eliminate $pc$ from the state of the
$Thr$ process.

\subsection{Remove $pc$ From State}
\label{remove-pc-from-state-subsection}

\section{Elimination of Frame Stack}
\label{elimination-of-frame-stack-section}

\section{Data Refinement of Objects}
\label{data-refinement-of-objects-section}

\section{Final Considerations}
\label{compilation-final-considerations-section}
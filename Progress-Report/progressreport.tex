\documentclass[a4paper,10pt]{report}

\usepackage[in]{fullpage}
\usepackage{parskip}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{pgfgantt}
\usepackage{amsmath}
\usepackage[backend=bibtex,style=numeric-comp,sorting=nyt,sortcites=true,maxnames=4]{biblatex}
\usepackage[section]{placeins}
\usepackage[color]{circus}
\usepackage{fixltx2e}
\usepackage{rotating}

\title{A Framework for Verifying Safety-Critical Java Virtual Machines}
\author{James Baxter}
\date{}

\bibliography{../Qualifying-Dissertation/literature} 

%TC:group zed 0 displaymath
%TC:group axdef 0 displaymath
%TC:group schema 1 displaymath
%TC:group circus 0 displaymath
%TC:group circusaction 0 displaymath
%TC:macroword \Circus 1 

\begin{document}
\maketitle

\begin{abstract}
  Abstract goes here
\end{abstract}

\tableofcontents

\chapter{Introduction}

% short explanation of chapter: motivation, objectives, document
% structure

\section{Motivation}

The Java programming language~\cite{gosling2013} has achieved great
popularity and is now used in a wide variety of areas.
One particular area of interest in which Java is used is that of
embedded systems, where it was realised that the features of
portability, modularity, safety and security that Java offers could be
of use~\cite{mulchandani1998}.
As Java programs are compiled to be run by the Java Virtual Machine
(JVM), this required creating JVMs for embedded devices and, indeed,
research has gone into making smaller and smaller JVMs to accommodate
a wider range of embedded devices~\cite{caska2011,thomm2010}.

However, many embedded systems have real-time requirements, meaning
that strict timing properties are required to be adhered to.
Features of Java such as the garbage collector and its concurrency
model make it difficult to ensure such properties, thus making
standard Java unsuitable for real-time systems.
To address this problem, the Real-Time Specification for Java
(RTSJ)~\cite{gosling2000} was created.
The RTSJ extends Java with some additional features that allow for
greater time predictability.
One feature the RTSJ adds is scoped memory, allowing memory to be
allocated for use in a particular scope and deallocated when that
scope in left, thus allowing for prediction of when memory
deallocations occur.
Another feature of the RTSJ is a more predictable priority scheduler
that better allows the execution time of higher priority threads to be
computed.

Though the RTSJ provides for real-time considerations, many real-time
embedded systems require certification under safety standards such as
\mbox{DO-178C} and ISO~26262.
To facilitate the certification of such systems, Safety-Critical Java
(SCJ)~\cite{locke2013} was created.
SCJ is based on the RTSJ but removes the features of the RTSJ that
would make it diffcult to certify programs written using it.
Some particular differences of SCJ from standard Java are in the areas
of scheduling and memory management.

SCJ's scheduling model is based around organising a program into a
series of missions, which are executed sequentially in an order chosen
by a programmer-supplied mission sequencer.
Each mission may contain multiple asynchronous event handler threads,
which are created when the mission is initialised and run throughout
the duration of the mission.
The event handlers within a mission are scheduled according to a
priority scheduling system, in which the running handler is always one
of the released handlers with the highest priority so that high
priority handlers are not sharing processor time with low priority
handlers.
highest priority released handler.
Once the mission is requested to terminate, the event handler threads
are stopped, the mission's resources are cleaned up, and the mission
sequencer selects the next mission.

The memory management of SCJ makes use of the scoped memory areas of
RTSJ, adapted for the SCJ mission model.
Memory is allocated in memory areas, which have varying lifetimes.
Each mission has a memory area associated with it that persists for
the duration of the mission, while each event handler within the
mission has a memory area that persists only during releases of the
handler.
Additional nested private memory areas can be created, which can be
entered and left as needed, being cleared when they are left.
There is also an immortal memory area, in which memory is never freed
and persists for the entire duration of the program.
A system of annotations allows for static checking that dangling
pointers cannot arise from misuse of the scoped memory
model~\cite{tang2010}.

Due to the safety-critical nature of the software SCJ is designed to
create, it is necessary to show that they are correct.
While the design of SCJ allows for it to be more easily shown that
programs will execute correctly, greater certainty and precision can
be obtained through the use of formal methods.
There has already been work on generating correct SCJ programs from
formal specifications~\cite{cavalcanti2011, cavalcanti2013}, which
ensures that an SCJ program will have the behaviour intended.
Some work has also been done on formalising the SCJ memory
model~\cite{cavalcanti2011a}, allowing its correctness to be ensured.

However, although SCJ can be compiled by a standard Java compiler, SCJ
requires a specialised virtual machine due to the differences between
SCJ and standard Java.
There have been several SCJ virtual machines (SCJVMs) created,
including the icecap HVM~\cite{sondergaard2012}, Fiji
VM~\cite{pizlo2009}, OVM~\cite{armbruster2007},
HVM\textsubscript{TP}~\cite{luckow2014} and PERC Pico~\cite{atego2015,
  richard2010}.
Of these, only Fiji VM and icecap HVM appear to be maintained and,
while icecap provides support for most of SCJ, Fiji VM does not
necessariy provide proper support for all aspects of SCJ.
Since the correct execution of an SCJ program depends on the
correctness of the underlying virtual machine, it must be ensured in
addition to checking the correctness of the program.
While there has been work on using formal methods to show SCJ program
correctness, no SCJVM has been verified.

Additionally, having to execute a program via a virtual machine
presents a cost in terms of memory and time resources, which may not
be available on the embedded real-time systems SCJ targets.
For this reason, all known SCJVMs, including the ones listed above
compile the Java bytecode to native code ahead-of-time.
This can be particularly seen in the examples of Fiji VM and the
icecap HVM, which compile Java bytecode to C code.
The correctness of this compilation to native code must also be
ensured, in addition to the correctness of the infrastructure
supporting the running program.
So the problem of ensuring the correctness of an SCJVM is, in part, a
compiler verification problem.

There has already been much research in the area of compiler
correctness, with most of the research following one of two
approaches.
The majority of the literature on compiler correctness follows a
commuting-diagram approach, in which the compilation function is shown
to commute with functions defining the semantics of the source and
target languages.
This approach was first identified by Lockwood
Morris~\cite{morris1973} and later refined by Thatcher \emph{et
  al.}~\cite{thatcher1979}, but can be seen in much of the earlier
work, including the earliest work by McCarthy and
Painter~\cite{mccarthy1967}.
The commuting-diagram approach has also been used in more recent work,
including some very comprehensive work as part of the CompCert
project~\cite{leroy2009a, leroy2009b}.
As this approach is based on the use of ordinary functions to describe
compiler correctness, it can be readily encoded in an automated
theorem prover and there have been several works that have made use of
automated theorem provers~\cite{klein2006, milner1972, nipkow2000}.

A recent variation of the commuting-diagram approach is based on an
operational semantics of the source language~\cite{bahr2015}.
In this work, the operational semantics of the source language and a
way of relating the source and target semantics are used to derive a
different operational semantics of the source language acting on the
state of the target machine.
The semantics of the target language are then identified as part of
that operational semantics and it is transformed to extract a
compilation function.
This approach may be viewed as variant of the commuting-diagram
approach in which the compilation function is derived from the source
and target semantics and the relationship between them, rather than
being verified by those elements of the commuting-diagram.

The second main approach to compiler verification is the algebraic
approach proposed by Hoare~\cite{hoare1991} and implemented by
Sampaio~\cite{hoare1993, sampaio1993}.
The algebraic approach is based around the notion of refinement, which
formally captures the idea of a program being an implementation of a
less deterministic specification.
In the algebraic approach, the source and target languages are defined
in the same semantic space and proven refinement laws are used to
refine the source program to a normal form representing the target
machine running the target code.
This approach has the advantage that the rules used to perform the
compilation are known to be correct, thus making the resultant
compiler correct by construction.
It also allows for passing seamlessly from the source language to the
target language using algebraic laws, since the source and target
languages are in the same semantic space.
The algebraic approach has not been used particularly widely but, in
addition to Sampaio's work, there has been work using the algebraic
approach for compilation of object-oriented languages~\cite{duran2005,
  duran2010} and for hardware compilation~\cite{perna2010, perna2011}.

\section{Objectives}
\label{objectives-section}

Since there appears to be no formally verified SCJVM and formal
verification of an SCJVM is desirable, we propose to create a
framework for formal verification of an SCJVM.
This framework will consist of the following parts:
\begin{itemize}
\item A specification of the services required to be provided by an
  SCJVM,
\item A compilation strategy from Java bytecode to C,
\item A formal model of the specification and compilation strategy,
\item Proofs of the correctness of the formal model, and
\item A mechanisation of the proofs in an automated theorem prover.
\end{itemize}
Each of these parts will be discussed in what follows.

First, it is necessary to have an explicit account of what is required
of an SCJVM.
Even though the ultimate aim is one of formal verification, an
informal specification is still needed to guide the development of the
formal model.
There is currently no clear specification for SCJVMs.

It should be noted that the role of an SCJVM is not merely to execute
bytecode instructions.
An SCJVM must also provide services to support the SCJ API in areas
such as scheduling and memory management.
An informal specification of all aspects of the SCJVM is required to
support creation of a formal model.
On the other hand, the semantics of SCJ bytecode does not differ much
from that of standard Java bytecode, so much of the Java Virtual
Machine specification~\cite{lindholm2014} also applies to SCJVMs.

The need for a compilation strategy arises from the fact that most
exising SCJVMs compile Java bytecode to some native code in order to
improve performance on embedded systems.
We will focus on compilation from Java bytecode to C for much the same
reasons as the icecap HVM and Fiji VM:~C is a language already widely
used in embedded systems and is suffciently low level to enable its
use as an efficient target language while retaining enough abstraction
to be used by the programmer.

The specification and compilation strategy must be formalised.
As noted previously, there are two main approaches to formalising
compilers and showing their correctness: the commuting-diagram
approach and the algebraic approach.
We will follow the algebraic approach in our work as it relates the
source and target languages in a clearer way than the
commuting-diagram approach.
Additionally, the commuting-diagram approach requires the definition
of additional functions to relate the source and target semantics,
thus relying more on definitions, which may be incorrect, than on
mathematically derived results.
The approach of deriving a compiler from an operational semantics
could be of use as it does not have this issue.
That approach, however, relies on knowledge of the state of the target
machine and a way of identifying the semantics of the target code
within the compilation function.
This is not easily done with a complex language like C, though it
works well for machine languages.

We require a formal language in which to specify the source and target
languages, as well as for specifying the virtual machine services.
For this we will use the \Circus{} specification
language~\cite{oliveira2009}, which is based on Z
notation~\cite{woodcock1996} and CSP~\cite{roscoe2011}.
\Circus{} uses CSP to specify processes that communicate over channels
and uses Z notation to specify state and data operations that can be
encapsulated in processes.
The reason for the choice of \Circus{} as our formal notation is due
to the fact that \Circus{} is designed as a notation for refinement
and so works well with the algebraic approach.
The combination of Z notation and CSP also gives far greater
expressive power than using those languages separately.
Finally, the use of \Circus{} helps to tie this work into the existing
specification work surrounding SCJ~\cite{cavalcanti2011,
  cavalcanti2011a, cavalcanti2013, zeyda2011}.

The consistency of the specification and the correctness of the
compilation strategy must be proved by formal mathematical proof from
algebraic laws known to be correct.
\Circus{} has many such laws already developed and has an underlying
semantics given using the model of Hoare and He's Unifying Thories of
Programming (UTP)~\cite{hoare1998} that can be used to verify the
correctness of the laws.

To ensure the laws are understood and applied correctly, it is helpful
to mechanise the proofs in an automated theorem prover.
There are a variety of tools for machine checking of \Circus{}
specifications.
The \Circus{} parser and typechecker included as part of the Community
Z Tools~\cite{malik2011, xavier2008, malik2005, miller2005} can be
used to perform basic checking of a \Circus{} specification and
integration with the Z/Eves theorem prover~\cite{saaltink1997} can be
used to prove the Z portions of the \Circus{} specification.
Process properties such as deadlock-freedom can be checked by
translating the \Circus{} specification to CSP and checking with a
tool such as FDR~\cite{gibson-robinson2014}.
For more comprehensive proving of properties about \Circus{}
specifications, recent work on Isabelle/UTP~\cite{foster2015} can be
used to permit reasoning about \Circus{} in the Isabelle theorem
prover~\cite{nipkow2002}.

Altogether, our objective is a framework for verification SCJVMs
consisting of mechanised formal models together with proofs of
properties about them.
These formal models will cover both the services that must be provided
by a running SCJVM and a compilation strategy for translating Java
bytecode to native code.
With our results, SCJVM developers will be able to create provably
correct ahead-of-time compiling SCJVM implementations and check the
correctness of those implementations.


\section{Document Structure}

\chapter{Progress Report}

\section{Review of Research Progress}

% Explain initial plan - verified model of compilation from Java
% bytecode to native code; explain necessity of having an SCJVM model;
% describe the structure of an SCJVM and the division into two parts:
% the core execution environment and the SCJVM services - use the
% diagram.


\begin{figure}[ht]
  \centering
  \begin{tikzpicture}

    \coordinate (width)  at (10cm,0cm);
    \coordinate (height) at (0cm,7cm);

    \path (0,0) -- (height)
    coordinate[pos=0.18] (OS boundary)
    coordinate[pos=0.20] (VM part bottom)
    coordinate[pos=0.57] (VM part top)
    coordinate[pos=0.60] (API boundary)
    coordinate[pos=0.82] (App boundary);

    \path (0,0) -- (width)
    coordinate[pos=0.04] (CEE left)
    coordinate[pos=0.48] (CEE right)
    coordinate[pos=0.52] (VM Services left)
    coordinate[pos=0.96] (VM Services right);

    \path (0,0) to node[pos=0.5] (mid) {} (width);
    \path (0,0) to node[pos=0.25] (quart) {} (width);

    \draw (0,0) rectangle (width |- height);

    \draw (OS boundary) -- ++(width);
    \path (0,0) rectangle node[pos=0.5] (OS) {} (width |- OS boundary);
    \draw (mid |- API boundary) rectangle node[pos=0.5] (API) {} (width |- App boundary);
    \draw (App boundary) -- ++(width);
    \path (App boundary) rectangle node[pos=0.5] (App) {} (width |- height);

    \path (quart |- API boundary) rectangle node[pos=0.4] (SCJVM) {} (quart |- App boundary);
    \draw (CEE left |- VM part bottom) rectangle node[pos=0.5] (CEE) {} (CEE right |- VM part top);
    \draw (VM Services left |- VM part bottom) rectangle node[pos=0.5] (VM Services) {} (VM Services right |- VM part top);

    \node[align=center] at (App)   {SCJ Application};
    \node[align=center] at (API)   {SCJ\\Infrastructure\\and API};
    \node[align=center] at (SCJVM) {SCJ\\Virtual Machine};
    \node[align=center] at (CEE)   {Core Execution\\Environment};
    \node[align=center] at (VM Services)  {SCJVM\\Services};
    \node[align=center] at (OS)    {Operating System/Hardware Abstraction Layer};

  \end{tikzpicture}
  \caption{A diagram showing the structure of an SCJVM and its
    relation to the SCJ infrastructure and the operating
    system/hardware abstraction layer}
  \label{scjvm-fig}
\end{figure}

\section{Safety-Critical Java Virtual Machine Services}

% Briefly explain the different SCJVM services and give a very brief
% overview of the structure of the model; mention the JTRES paper and
% the Z/Eves proofs of the model

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}

    \coordinate (width)  at (10cm,0cm);
    \coordinate (height) at (0cm,7cm);

    \path (0,0) -- (height)
    coordinate[pos=0.18] (OS boundary)
    coordinate[pos=0.20] (VM part bottom)
    coordinate[pos=0.57] (VM part top)
    coordinate[pos=0.60] (API boundary)
    coordinate[pos=0.82] (App boundary);
    
    \path (VM part bottom) -- (VM part top)
    coordinate[pos=0.7] (VM Service top);

    \path (VM part bottom) -- (VM part top)
    coordinate[pos=0.85] (VM Services ypos);

    \path (0,0) -- (width)
    coordinate[pos=0.04] (CEE left)
    coordinate[pos=0.27] (CEE right)
    coordinate[pos=0.29] (VM Services left)
    coordinate[pos=0.96] (VM Services right)
    coordinate[pos=0.17] (VM Service width)
    coordinate[pos=0.04] (VM Service sep);

    \path (VM Services left) -- (VM Services right)
    coordinate[pos=0.5] (VM Services xpos);

    \path (0,0) to node[pos=0.5] (mid) {} (width);
    \path (0,0) to node[pos=0.25] (quart) {} (width);

    \draw (0,0) rectangle (width |- height);

    \draw (OS boundary) -- ++(width);
    \path (0,0) rectangle node[pos=0.5] (OS) {} (width |- OS boundary);
    \draw (mid |- API boundary) rectangle node[pos=0.5] (API) {} (width |- App boundary);
    \draw (App boundary) -- ++(width);
    \path (App boundary) rectangle node[pos=0.5] (App) {} (width |- height);

    \path (quart |- API boundary) rectangle node[pos=0.4] (SCJVM) {} (quart |- App boundary);
    \draw (CEE left |- VM part bottom) rectangle node[pos=0.5] (CEE) {} (CEE right |- VM part top);
    \draw (VM Services left |- VM part bottom) rectangle (VM Services right |- VM part top);
    \coordinate (VM Services) at (VM Services xpos |- VM Services ypos);

    \node[align=center] at (App)   {SCJ Application};
    \node[align=center] at (API)   {SCJ\\Infrastructure\\and API};
    \node[align=center] at (SCJVM) {SCJ\\Virtual Machine};
    \node[align=center] at (CEE)   {Core\\Execution\\Environment};
    \node[align=center] at (OS)    {Operating System/Hardware Abstraction Layer};
    
    \foreach \x in {1,...,3}
    \pgfmathsetmacro{\a}{0.333*(\x - 1)}
    \pgfmathsetmacro{\b}{0.333*\x}
    \path ($(VM Services left) + (VM part bottom)!0.07!(VM part top)$) -- 
    node[pos=\a] (VM Service \x start) {}
    node[pos=\b] (VM Service \x end) {}
    ($(VM Services right) + (VM part bottom)!0.07!(VM part top) - (VM Service sep)$);

    \foreach \x in {1,...,3} 
    \draw ($(VM Service \x start) + (VM Service sep)$)
    rectangle node[pos=0.5] (VM Service \x) {}
    (VM Service \x end |- VM Service top);

    \node[align=center] at (VM Services)  {VM Services};
    \node[align=center] at (VM Service 1) {Memory\\Manager};
    \node[align=center] at (VM Service 2) {Scheduler};
    \node[align=center] at (VM Service 3) {Real-time\\Clock};
  \end{tikzpicture}
  \caption{A diagram showing the structure of an SCJVM and its
    relation to the SCJ infrastructure and the operating
    system/hardware abstraction layer, focusing on the SCJVM services}
  \label{scjvm-services-fig}
\end{figure}

\section{The Core Execution Environment}

% Explain the structure of the core execution environment model and
% describe the bytecode subset, justifying the design decisions taken

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}

    \coordinate (width)  at (10cm,0cm);
    \coordinate (height) at (0cm,7cm);

    \path (0,0) -- (height)
    coordinate[pos=0.18] (OS boundary)
    coordinate[pos=0.20] (VM part bottom)
    coordinate[pos=0.57] (VM part top)
    coordinate[pos=0.60] (API boundary)
    coordinate[pos=0.82] (App boundary);
    
    \path (VM part bottom) -- (VM part top)
    coordinate[pos=0.7] (CEE part top);

    \path (VM part bottom) -- (VM part top)
    coordinate[pos=0.85] (CEE ypos);

    \path (0,0) -- (width)
    coordinate[pos=0.04] (CEE left)
    coordinate[pos=0.76] (CEE right)
    coordinate[pos=0.78] (VM Services left)
    coordinate[pos=0.96] (VM Services right)
    coordinate[pos=0.01] (CEE part sep);

    \path (CEE left) -- (CEE right)
    coordinate[pos=0.5] (CEE xpos);

    \path (0,0) to node[pos=0.5] (mid) {} (width);
    \path (0,0) to node[pos=0.25] (quart) {} (width);

    \draw (0,0) rectangle (width |- height);

    \draw (OS boundary) -- ++(width);
    \path (0,0) rectangle node[pos=0.5] (OS) {} (width |- OS boundary);
    \draw (mid |- API boundary) rectangle node[pos=0.5] (API) {} (width |- App boundary);
    \draw (App boundary) -- ++(width);
    \path (App boundary) rectangle node[pos=0.5] (App) {} (width |- height);

    \path (quart |- API boundary) rectangle node[pos=0.4] (SCJVM) {} (quart |- App boundary);
    \draw (CEE left |- VM part bottom) rectangle (CEE right |- VM part top);
    \draw (VM Services left |- VM part bottom) rectangle node[pos=0.5] (VM Services) {} (VM Services right |- VM part top);
    \coordinate (CEE) at (CEE xpos |- CEE ypos);

    \node[align=center] at (App)   {SCJ Application};
    \node[align=center] at (API)   {SCJ\\Infrastructure\\and API};
    \node[align=center] at (SCJVM) {SCJ\\Virtual Machine};
    \node[align=center] at (CEE)   {Core Execution Environment};
    \node[align=center] at (VM Services)  {SCJVM\\Services};
    \node[align=center] at (OS)    {Operating System/Hardware Abstraction Layer};

    \foreach \x in {1,...,4}
    \pgfmathsetmacro{\a}{0.25*(\x - 1)}
    \pgfmathsetmacro{\b}{0.25*\x}
    \path ($(CEE left) + (VM part bottom)!0.07!(VM part top)$) -- 
    node[pos=\a] (CEE part \x start) {}
    node[pos=\b] (CEE part \x end) {}
    ($(CEE right) + (VM part bottom)!0.07!(VM part top) - (CEE part sep)$);

    \foreach \x in {1,...,4} 
    \draw ($(CEE part \x start) + (CEE part sep)$)
    rectangle node[pos=0.5] (CEE part \x) {}
    (CEE part \x end |- CEE part top);

    \node[align=center] at (CEE part 1) {\small Code\\Area};
    \node[align=center] at (CEE part 2) {\small Memory};
    \node[align=center] at (CEE part 3) {\small Interpreter};
    \node[align=center] at (CEE part 4) {\small Launcher};
  \end{tikzpicture}
  \caption{A diagram showing the structure of an SCJVM and its
    relation to the SCJ infrastructure and the operating
    system/hardware abstraction layer, focusing on the core execution
    environment}
  \label{cee-fig}
\end{figure}

\section{Other Activities}

% Mention any other activities undertaken in the course of the
% research programme, including modules demonstrated for and work on
% the programme committee of YDS


\chapter{Research Plan}

In this chapter we describe the plan for the rest of the research,
explaining each of the steps to be taken and giving and estimate of
the amount of time each will take.

Having already constructed formal models of the SCJVM services and
core execution environment, the bulk of the remaining work centres
around the construction and proof of soundness of the compilation
strategy.
A summary of the tasks involved in this, with an estimate of the time
needed and dates during which the work will be carried out, is given
in Table~\ref{research-plan-table}

\begin{table}[ht]
  \centering
  \begin{tabular}{llll}
    \hline
    Task & Time Needed & Start Date & End Date  \\
    \hline
    Define C subset semantics & 2 months & 2016-02-01 & 2016-03-31 \\
    Develop compilation strategy & 4 months & 2016-04-01 & 2016-07-31 \\
    Hand proofs of compilation rules & 6 months & 2016-07-01 & 2016-12-31 \\
    Mechanise proofs of compilation rules & 3 months & 2016-12-01 & 2017-02-28 \\
    Implementation and example development & 2 months & 2017-03-01 & 2017-04-30 \\
    Writing up results & 5 months & 2017-05-01 & 2017-09-30 \\
    \hline
  \end{tabular}
  \caption{A table showing the proposed plan for the remainder of the research}
  \label{research-plan-table}
\end{table}

\section{C Subset Semantics}

The first task is to define the target language for the compilation
strategy.
As mentioned in Section~\ref{objectives-section}, the focus is on C,
since that is the target language used by several existing SCJVMs.
However, since C is being used as a target language and not as a
high-level source language, not all features of C will be required.
This means that we must first determine a subset of C that will be
sufficiently powerful to support the compilation but sufficiently
small to permit reasoning.

The C subset will be determined by consideration of the parts of C
used by existing SCJVMs such as the icecap HVM.
We will also do some preliminary thinking about the compilation
strategy at this stage to identify the parts of C required for it.

Once the C subset is determined, its semantics must be defined.
In order to apply the algebraic approach, the semantics must be
described in the same semantic space as the source language and SCJVM,
model so that there will be a refinement relation between them.
This means an existing C semantics cannot necessarily be used
as-is:~we need a \Circus{} semantics.

Nevertheless, consideration of existing C semantics can be of use in
defining the semantics of our subset.
This is particularly true in light of the fact that the generated C
code, generated by applying the compilation strategy will then need to
be compiled correctly.
So, it is wise to ensure that our semantics is a valid account of the
accepted semantics of the subset of C of interest.
We will validate our C semantics by comparing it to existing models of
the semantics of C and carefully checking it against the C standard.
The soundness of the semantics will be ensured by the same proof
techniques as for the SCJVM model.
Overall, due to the small size of our subset and the fact that some
existing models of C semantics can be referenced, we do not expect the
process of defining the subset and its semantics to take very long and
so we have allotted two months for it.

\section{Development of Compilation Strategy}

The next task is the construction of the compilation strategy to go
from the source language to the target language.
The approach taken in earlier works using the algebraic
approach~\cite{sampaio1993,duran2005} is to divide the compilation
into stages with compilation rules for each stage.
This is a sensible approach to adopt in developing the compilation
strategy, so we will proceed by identifying the main transformations
that must be performed and then breaking them down into specific rules
to transform each program element.
As this is a significant part of our research, we have allowed four
months for it.

Additionally, while constructing the compilation strategy, we will
also construct some example SCJ programs that can be used as case
studies for the compilation strategy.
This will support us in ensuring that the compilation strategy is
designed to work for actual programs and it also means the
compilation strategy can be easily compared to existing SCJVMs.

\section{Proof of Compilation Rules}

While the top-down approach described above enables construction of
the compilation strategy, proof of its correctness must follow a 
bottom-up approach starting from basic axioms and using
those to prove the compilation rules.
With that in mind, the next stage after drawing up the compilation
strategy is to prove it sound.
Because machine-checked proofs can take a long time to write and
hand-written proofs can be better for reading and understanding,
we will initially construct proofs by hand before translating them
into an automated theorem prover.
We have allowed six months for the hand-written proofs as they may be
difficult to construct and form an important part of the work.

The hand-written proofs then need to be performed in an automated
theorem prover in order to have them machine-checked.
The theorem prover we will use is Isabelle, due to the fact that it is
well developed and there is an implementation of UTP in Isabelle that
can be used to work with \Circus{}.
We have allowed three months for completing this stage of the proof as
Isabelle provides a lot of proof automation and the main outline of
the proofs should already exist from the previous stage.

\section{Implementation and Example Development}

With the main task of developing and proving the compilation strategy
performed, we will implement the compilation strategy.
This should be a relatively simple task since the compilation rules
will take the form of rewrite rules that can be turned into functions.
Isabelle's code generation facilities can be used to check the
functions against the proved compilation laws and convert them to
executable code.
At this stage more work can also be done developing example SCJ
programs whose bytecode can then be passed through the implementation
of the compilation strategy and the output compared to that of other
SCJVMs.
We have allowed two months for this work.

\section{Writing Up Results}

Finally, we have left five months at the end of the project for final
writing up of results.
However, the main writing up effort will be carried out as part of the
other stages of the work.
If there is any extra time available, it would be good to implement
additional bytecode instructions not in the original subset at this
stage, especially if they may be required by the examples we create.

In conclusion, upon successful completion of this work we will have
created a framework that will allow creation of a formally verified
virtual machine for SCJ.
This will offer a certainty of correctness not offered by existing
SCJVMs and so facilitate the use of SCJ.

\begin{sidewaysfigure}
\centering
\begin{minipage}{\textheight}
\centering
\begin{ganttchart}[
  vgrid,
  x unit=0.7cm,
  time slot format = isodate-yearmonth,
  compress calendar
  ]{2016-01}{2017-12}
  \gantttitlecalendar{year, month=shortname} \\
  \ganttbar{Define C subset semantics}{2016-02}{2016-03} \\
  \ganttbar{Develop compilation strategy}{2016-04}{2016-07} \\
  \ganttbar{Hand proofs of compilation rules}{2016-07}{2016-12} \\
  \ganttbar{Mechanise proofs of compilation rules}{2016-12}{2017-02} \\
  \ganttbar{Implementation and example development}{2017-03}{2017-04} \\
  \ganttbar{Writing up results}{2016-03}{2016-03}
  \ganttbar{}{2016-07}{2016-07}
  \ganttbar{}{2017-05}{2017-09} \\
\end{ganttchart}
\end{minipage}
\caption{A Gantt chart showing the schedule for the planned research}
\end{sidewaysfigure}

\printbibliography

\end{document}
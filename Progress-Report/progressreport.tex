\documentclass[a4paper,10pt]{report}

\usepackage[in]{fullpage}
\usepackage{parskip}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage[backend=bibtex,style=numeric-comp,sorting=nyt,sortcites=true,maxnames=4]{biblatex}
\usepackage[section]{placeins}
\usepackage[color]{circus}
\usepackage{fixltx2e}

\title{A Framework for Verifying Safety-Critical Java Virtual Machines}
\author{James Baxter}
\date{}

\bibliography{../Qualifying-Dissertation/literature} 

%TC:group zed 0 displaymath
%TC:group axdef 0 displaymath
%TC:group schema 1 displaymath
%TC:group circus 0 displaymath
%TC:group circusaction 0 displaymath
%TC:macroword \Circus 1 

\begin{document}
\maketitle

\begin{abstract}
  Abstract goes here
\end{abstract}

\tableofcontents

\chapter{Introduction}

% short explanation of chapter: motivation, objectives, document
% structure

\section{Motivation}

The Java programming language~\cite{gosling2013} has achieved great
popularity and is now used in a wide variety of areas.
One particular area of interest in which Java is used is that of
embedded systems, where it was realised that the features of
portability, modularity, safety and security that Java offers could be
of use in those areas~\cite{mulchandani1998}.
As Java programs are compiled to be run by the Java Virtual Machine
(JVM), this required creating JVMs for embedded devices and, indeed,
research has gone into making smaller and smaller JVMs to accommodate
a wider range of embedded devices~\cite{caska2011,thomm2010}.

However, many embedded systems have real-time requirements, meaning
that strict timing properties are required to be adhered to.
Features of Java such as the garbage collector and its concurrency
model make it difficult to ensure such properties, thus making
standard Java unsuitable for real-time systems.
To address this problem, the Real-Time Specification for Java
(RTSJ)~\cite{gosling2000} was created.
The RTSJ extends Java with some additional features that allow for
greater time predictability.
One feature the RTSJ adds is scoped memory, allowing memory to
allocated for use in a particular scope and deallocated when that
scope in left, thus allowing for prediction of when memory
deallocations will occur.
Another feature of the RTSJ is a more predictable priority scheduler
that better allows the execution time of higher priority threads to be
computed.

Though the RTSJ provides for real-time considerations, many real-time
embedded systems require certification under safety standards such as
\mbox{DO-178C}.
To better facilitate the certification of such systems,
Safety-Critical Java (SCJ)~\cite{locke2013} was created.
SCJ is based on the RTSJ but removes the features of the RTSJ that
would make it diffcult to certify programs written using it.
Some particular differences of SCJ from standard Java are in the areas
of scheduling and memory management.

SCJ's scheduling model is based around organising a program into a
series of missions, which are executed sequentially in an order chosen
by a programmer-supplied mission sequencer.
Each mission may contain multiple asynchronous event handler threads,
which are created when the mission is initialised and run throughout
the duration of the mission.
The event handlers within a mission are scheduled according to a
priority scheduling system, in which the running handler is always the
highest priority relesed handler.
Once the mission is requested to terminate, the event handler threads
are stopped, the mission's resources are cleaned up, and the mission
sequencer selects the next mission.

The memory management of SCJ makes use of the scoped memory areas of
RTSJ, adapted for the SCJ mission model.
Memory is allocated in memory areas, which have varying lifetimes.
Each mission has a memory area associated with it that persists for
the duration of the mission, while each event handler within the
mission has a memory area that persists only during releases of the
handler.
Additional nested private memory areas can be created, which can be
entered and left as needed, being cleared when they are left.
There is also an immortal memory area, in which memory is never freed
and persists for the entire duration of the program.
A system of annotations allows for static checking that dangling
pointers cannot arise from misuse of the scoped memory model.

% mention the existing work on formal verification of SCJ programs

Due to the differences between SCJ and standard Java, SCJ requires a
specialised virtual machine, although SCJ has been designed with no
syntactic modifications so it can be compiled by a standard Java
compiler.
There have been several SCJ virtual machines (SCJVMs) created,
including the icecap HVM~\cite{sondergaard2012}, Fiji
VM~\cite{pizlo2009}, OVM~\cite{armbruster2007},
HVM\textsubscript{TP}~\cite{luckow2014} and PERC Pico~\cite{atego2015,
  richard2010}.
Of these, only Fiji VM and icecap HVM appear to be maintained
and, while icecap provides support for most of SCJ, Fiji VM does not
necessariy provide proper support for all aspects of SCJ.
None of the SCJVMs produced to date have been formally
verified, which is desirable given the safety-critical nature of the
applications and the fact that correct execution of a program depends
on virtual machine correctness.

Additionally, having to execute a program via a virtual machine
presents a cost in terms of memory and time resources, which may not
be available on the embedded real-time systems SCJ is targetting.
For this reason, most SCJVMs, including the ones listed above compile
the Java bytecode to native code ahead-of-time.
This can be particularly seen in the examples of Fiji VM and the
icecap HVM, which compile Java bytecode to C code.
The correctness of this compilation to native code must also be
ensured, in addition to the correctness of the infrastructure
supporting the running program, and so the problem of ensuring the
correctness of an SCJVM is, in part, a compiler verification problem.

There has already been much research in the area of compiler
correctness, with most of the research following one of two
approaches.
The majority of the literature on compiler correctness follows a
commuting-diagram approach, in which the compilation function is shown
to commute with functions defining the semantics of the source and
target languages.
This approach was first identified by Lockwood
Morris~\cite{morris1973} and later refined by Thatcher \emph{et
  al.}~\cite{thatcher1979}, but can be seen in much of the earlier
work, including the earliest work by McCarthy and
Painter~\cite{mccarthy1967}.
The commuting-diagram approach has also been used in more recent work,
including some very comprehensive work as part of the CompCert
project~\cite{leroy2009a, leroy2009b}.
As this approach is based on the use of ordinary functions to describe
compiler correctness, it can be readily encoded in an automated
theorem prover and there have been several works that have made use of
automated theorem provers~\cite{klein2006, milner1972, nipkow2000}.


\printbibliography


\end{document}